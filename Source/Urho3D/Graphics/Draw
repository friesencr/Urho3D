AnimatedModel.h:2:// Copyright (c) 2008-2015 the Urho3D project.
AnimatedModel.h:60:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
AnimatedModel.h:147:    /// Return per-geometry bone mappings.
AnimatedModel.h:149:    /// Return per-geometry skin matrices. If empty, uses global skinning
AnimatedModel.h:157:    /// Recalculate the world-space bounding box.
Animation.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Animation.cpp:49:        index = keyFrames_.Size() - 1;
Animation.cpp:53:        --index;
Animation.cpp:56:    while (index < keyFrames_.Size() - 1 && time >= keyFrames_[index + 1].time_)
Animation.cpp:72:    context->RegisterFactory<Animation>();
Animation.cpp:126:    SharedPtr<XMLFile> file(cache->GetTempResource<XMLFile>(xmlName, false));
Animation.cpp:129:        XMLElement rootElem = file->GetRoot();
Animation.cpp:184:            String xmlName = ReplaceExtension(destFile->GetName(), ".xml");
Animation.cpp:187:            XMLElement rootElem = xml->CreateRoot("animation");
Animation.cpp:197:            xml->Save(xmlFile);
Animation.cpp:257:        if (i->name_ == name)
Animation.cpp:268:        if (i->nameHash_ == nameHash)
Animation.h:2:// Copyright (c) 2008-2015 the Urho3D project.
AnimatedModel.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
AnimatedModel.cpp:53:    return lhs->GetLayer() < rhs->GetLayer();
AnimatedModel.cpp:63:    animationLodTimer_(-1.0f),
AnimatedModel.cpp:81:    if (rootBone && rootBone->node_)
AnimatedModel.cpp:83:        Node* parent = rootBone->node_->GetParent();
AnimatedModel.cpp:84:        if (parent && !parent->GetComponent<AnimatedModel>())
AnimatedModel.cpp:91:    context->RegisterFactory<AnimatedModel>(GEOMETRY_CATEGORY);
AnimatedModel.cpp:136:    // If no bones or no bone-level testing, use the StaticModel test
AnimatedModel.cpp:144:    // Check ray hit distance to AABB before proceeding with bone-level tests
AnimatedModel.cpp:164:            const Matrix3x4& transform = bone.node_->GetWorldTransform();
AnimatedModel.cpp:180:            boneSphere.center_ = bone.node_->GetWorldPosition();
AnimatedModel.cpp:192:        result.normal_ = -query.ray_.direction_;
AnimatedModel.cpp:205:    if (frame.camera_ && abs((int)frame.frameNumber_ - (int)viewFrameNumber_) > 1)
AnimatedModel.cpp:210:        float distance = frame.camera_->GetDistance(node_->GetWorldPosition());
AnimatedModel.cpp:215:        animationLodDistance_ = frame.camera_->GetLodDistance(distance, scale, lodBias_);
AnimatedModel.cpp:226:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
AnimatedModel.cpp:228:    distance_ = frame.camera_->GetDistance(worldBoundingBox.Center());
AnimatedModel.cpp:230:    // Note: per-geometry distances do not take skinning into account. Especially in case of a ragdoll they may be
AnimatedModel.cpp:237:            batches_[i].distance_ = frame.camera_->GetDistance(worldTransform * geometryData_[i].center_);
AnimatedModel.cpp:244:    float newLodDistance = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
AnimatedModel.cpp:285:        debug->AddBoundingBox(GetWorldBoundingBox(), Color::GREEN, depthTest);
AnimatedModel.cpp:286:        debug->AddSkeleton(skeleton_, Color(0.75f, 0.75f, 0.75f), depthTest);
AnimatedModel.cpp:306:        SetNumGeometries(model->GetNumGeometries());
AnimatedModel.cpp:307:        const Vector<Vector<SharedPtr<Geometry> > >& geometries = model->GetGeometries();
AnimatedModel.cpp:308:        const PODVector<Vector3>& geometryCenters = model->GetGeometryCenters();
AnimatedModel.cpp:316:        const Vector<PODVector<unsigned> >& geometryBoneMappings = model->GetGeometryBoneMappings();
AnimatedModel.cpp:322:        // Copy morphs. Note: morph vertex buffers will be created later on-demand
AnimatedModel.cpp:325:        const Vector<ModelMorph>& morphs = model->GetMorphs();
AnimatedModel.cpp:336:                morphElementMask_ |= j->second_.elementMask_;
AnimatedModel.cpp:341:        SetBoundingBox(model->GetBoundingBox());
AnimatedModel.cpp:345:        SetSkeleton(model->GetSkeleton(), createBones);
AnimatedModel.cpp:354:                // Check if model has per-geometry bone mappings
AnimatedModel.cpp:370:                batches_[i].worldTransform_ = &node_->GetWorldTransform();
AnimatedModel.cpp:394:        LOGERROR("Can not add animation state to non-master model");
AnimatedModel.cpp:415:        RemoveAnimationState(animation->GetNameHash());
AnimatedModel.cpp:421:            if (!state->GetAnimation())
AnimatedModel.cpp:441:        Animation* animation = state->GetAnimation();
AnimatedModel.cpp:445:            if (animation->GetNameHash() == animationNameHash || animation->GetAnimationNameHash() == animationNameHash)
AnimatedModel.cpp:514:        // For a master model, set the same morph weight on non-master models
AnimatedModel.cpp:523:                if (!models[i]->isMaster_)
AnimatedModel.cpp:524:                    models[i]->SetMorphWeight(morphs_[index].nameHash_, weight);
AnimatedModel.cpp:560:        i->weight_ = 0.0f;
AnimatedModel.cpp:562:    // For a master model, reset weights on non-master models
AnimatedModel.cpp:570:            if (!models[i]->isMaster_)
AnimatedModel.cpp:571:                models[i]->ResetMorphWeights();
AnimatedModel.cpp:588:        if (i->name_ == name)
AnimatedModel.cpp:589:            return i->weight_;
AnimatedModel.cpp:599:        if (i->nameHash_ == nameHash)
AnimatedModel.cpp:600:            return i->weight_;
AnimatedModel.cpp:610:        if ((*i)->GetAnimation() == animation)
AnimatedModel.cpp:626:        Animation* animation = (*i)->GetAnimation();
AnimatedModel.cpp:630:            if (animation->GetNameHash() == animationNameHash || animation->GetAnimationNameHash() == animationNameHash)
AnimatedModel.cpp:695:            if (i->collisionMask_ & BONECOLLISION_BOX && i->boundingBox_.Size().Length() < M_EPSILON)
AnimatedModel.cpp:696:                i->collisionMask_ &= ~BONECOLLISION_BOX;
AnimatedModel.cpp:697:            if (i->collisionMask_ & BONECOLLISION_SPHERE && i->radius_ < M_EPSILON)
AnimatedModel.cpp:698:                i->collisionMask_ &= ~BONECOLLISION_SPHERE;
AnimatedModel.cpp:707:                Node* boneNode = node_->CreateChild(i->name_, LOCAL);
AnimatedModel.cpp:708:                boneNode->AddListener(this);
AnimatedModel.cpp:709:                boneNode->SetTransform(i->initialPosition_, i->initialRotation_, i->initialScale_);
AnimatedModel.cpp:710:                i->node_ = boneNode;
AnimatedModel.cpp:717:                    bones[parentIndex].node_->AddChild(bones[i].node_);
AnimatedModel.cpp:725:        node_->SendEvent(E_BONEHIERARCHYCREATED, eventData);
AnimatedModel.cpp:729:        // For non-master models: use the bone nodes of the master model
AnimatedModel.cpp:737:                Node* boneNode = node_->GetChild(i->name_, true);
AnimatedModel.cpp:739:                    boneNode->AddListener(this);
AnimatedModel.cpp:740:                i->node_ = boneNode;
AnimatedModel.cpp:755:    // When loading a scene, set model without creating the bone nodes (will be assigned later during post-load)
AnimatedModel.cpp:756:    SetModel(cache->GetResource<Model>(value.name_), !loading_);
AnimatedModel.cpp:779:    while (numStates--)
AnimatedModel.cpp:785:            SharedPtr<AnimationState> newState(new AnimationState(this, cache->GetResource<Animation>(animRef.name_)));
AnimatedModel.cpp:788:            newState->SetStartBone(skeleton_.GetBone(value[index++].GetString()));
AnimatedModel.cpp:789:            newState->SetLooped(value[index++].GetBool());
AnimatedModel.cpp:790:            newState->SetWeight(value[index++].GetFloat());
AnimatedModel.cpp:791:            newState->SetTime(value[index++].GetFloat());
AnimatedModel.cpp:792:            newState->SetLayer(value[index++].GetInt());
AnimatedModel.cpp:826:        ret.Push(i->animated_);
AnimatedModel.cpp:838:        Animation* animation = state->GetAnimation();
AnimatedModel.cpp:839:        Bone* startBone = state->GetStartBone();
AnimatedModel.cpp:841:        ret.Push(startBone ? startBone->name_ : String::EMPTY);
AnimatedModel.cpp:842:        ret.Push(state->IsLooped());
AnimatedModel.cpp:843:        ret.Push(state->GetWeight());
AnimatedModel.cpp:844:        ret.Push(state->GetTime());
AnimatedModel.cpp:845:        ret.Push((int)state->GetLayer());
AnimatedModel.cpp:854:        attrBuffer_.WriteUByte((unsigned char)(i->weight_ * 255.0f));
AnimatedModel.cpp:887:        worldBoundingBox_ = boneBoundingBox_.Transformed(node_->GetWorldTransform());
AnimatedModel.cpp:891:        // Non-master animated models get the bounding box from the master
AnimatedModel.cpp:893:        AnimatedModel* master = node_->GetComponent<AnimatedModel>();
AnimatedModel.cpp:898:            worldBoundingBox_ = master->GetWorldBoundingBox();
AnimatedModel.cpp:914:        Node* boneNode = node_->GetChild(i->name_, true);
AnimatedModel.cpp:918:            boneNode->AddListener(this);
AnimatedModel.cpp:920:        i->node_ = boneNode;
AnimatedModel.cpp:926:        SetSkeleton(model_->GetSkeleton(), true);
AnimatedModel.cpp:928:    // Re-assign the same start bone to animations to get the proper bone node this time
AnimatedModel.cpp:932:        state->SetStartBone(state->GetStartBone());
AnimatedModel.cpp:939:    if (rootBone && rootBone->node_)
AnimatedModel.cpp:940:        rootBone->node_->Remove();
AnimatedModel.cpp:968:    const Vector<SharedPtr<VertexBuffer> >& originalVertexBuffers = model_->GetVertexBuffers();
AnimatedModel.cpp:975:        if (model_->GetMorphRangeCount(i))
AnimatedModel.cpp:978:            clone->SetShadowed(true);
AnimatedModel.cpp:979:            clone->SetSize(original->GetVertexCount(), morphElementMask_ & original->GetElementMask(), true);
AnimatedModel.cpp:980:            void* dest = clone->Lock(0, original->GetVertexCount());
AnimatedModel.cpp:983:                CopyMorphVertices(dest, original->GetShadowData(), original->GetVertexCount(), clone, original);
AnimatedModel.cpp:984:                clone->Unlock();
AnimatedModel.cpp:1003:            const Vector<SharedPtr<VertexBuffer> >& originalBuffers = original->GetVertexBuffers();
AnimatedModel.cpp:1011:            clone->SetNumVertexBuffers(totalBuf);
AnimatedModel.cpp:1017:                unsigned originalMask = original->GetVertexElementMask(k);
AnimatedModel.cpp:1022:                    clone->SetVertexBuffer(l++, originalBuffer, originalMask & ~clonedBuffer->GetElementMask());
AnimatedModel.cpp:1023:                    clone->SetVertexBuffer(l++, clonedBuffer, originalMask & clonedBuffer->GetElementMask());
AnimatedModel.cpp:1026:                    clone->SetVertexBuffer(l++, originalBuffer, originalMask);
AnimatedModel.cpp:1029:            clone->SetIndexBuffer(original->GetIndexBuffer());
AnimatedModel.cpp:1030:            clone->SetDrawRange(original->GetPrimitiveType(), original->GetIndexStart(), original->GetIndexCount());
AnimatedModel.cpp:1031:            clone->SetLodDistance(original->GetLodDistance());
AnimatedModel.cpp:1044:    unsigned mask = destBuffer->GetElementMask() & srcBuffer->GetElementMask();
AnimatedModel.cpp:1045:    unsigned normalOffset = srcBuffer->GetElementOffset(ELEMENT_NORMAL);
AnimatedModel.cpp:1046:    unsigned tangentOffset = srcBuffer->GetElementOffset(ELEMENT_TANGENT);
AnimatedModel.cpp:1047:    unsigned vertexSize = srcBuffer->GetVertexSize();
AnimatedModel.cpp:1051:    while (vertexCount--)
AnimatedModel.cpp:1100:    // Reserve space for per-geometry skinning matrices
AnimatedModel.cpp:1105:    // Build original-to-skinindex matrix pointer mapping for fast copying
AnimatedModel.cpp:1146:            (*i)->Apply();
AnimatedModel.cpp:1149:        node_->MarkDirty();
AnimatedModel.cpp:1164:        Matrix3x4 inverseNodeTransform = node_->GetWorldTransform().Inverse();
AnimatedModel.cpp:1169:            Node* boneNode = i->node_;
AnimatedModel.cpp:1175:            if (i->collisionMask_ & BONECOLLISION_BOX)
AnimatedModel.cpp:1176:                boneBoundingBox_.Merge(i->boundingBox_.Transformed(inverseNodeTransform * boneNode->GetWorldTransform()));
AnimatedModel.cpp:1177:            else if (i->collisionMask_ & BONECOLLISION_SPHERE)
AnimatedModel.cpp:1178:                boneBoundingBox_.Merge(Sphere(inverseNodeTransform * boneNode->GetWorldPosition(), i->radius_ * 0.5f));
AnimatedModel.cpp:1191:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
AnimatedModel.cpp:1200:                skinMatrices_[i] = bone.node_->GetWorldTransform() * bone.offsetMatrix_;
AnimatedModel.cpp:1205:    // Skinning with per-geometry matrices
AnimatedModel.cpp:1212:                skinMatrices_[i] = bone.node_->GetWorldTransform() * bone.offsetMatrix_;
AnimatedModel.cpp:1216:            // Copy the skin matrix to per-geometry matrices as needed
AnimatedModel.cpp:1239:                VertexBuffer* originalBuffer = model_->GetVertexBuffers()[i];
AnimatedModel.cpp:1240:                unsigned morphStart = model_->GetMorphRangeStart(i);
AnimatedModel.cpp:1241:                unsigned morphCount = model_->GetMorphRangeCount(i);
AnimatedModel.cpp:1243:                void* dest = buffer->Lock(morphStart, morphCount);
AnimatedModel.cpp:1247:                    CopyMorphVertices(dest, originalBuffer->GetShadowData() + morphStart * originalBuffer->GetVertexSize(),
AnimatedModel.cpp:1256:                                ApplyMorph(buffer, dest, morphStart, k->second_, morphs_[j].weight_);
AnimatedModel.cpp:1260:                    buffer->Unlock();
AnimatedModel.cpp:1271:    unsigned elementMask = morph.elementMask_ & buffer->GetElementMask();
AnimatedModel.cpp:1273:    unsigned normalOffset = buffer->GetElementOffset(ELEMENT_NORMAL);
AnimatedModel.cpp:1274:    unsigned tangentOffset = buffer->GetElementOffset(ELEMENT_TANGENT);
AnimatedModel.cpp:1275:    unsigned vertexSize = buffer->GetVertexSize();
AnimatedModel.cpp:1280:    while (vertexCount--)
AnimatedModel.cpp:1282:        unsigned vertexIndex = *((unsigned*)srcData) - morphRangeStart;
AnimatedModel.cpp:1318:    model_.Reset(); // Set null to allow to be re-set
AnimationController.h:2:// Copyright (c) 2008-2015 the Urho3D project.
AnimationController.h:64:    /// Animation autofade on stop -time, 0 if disabled.
AnimationController.h:66:    /// Set time command time-to-live.
AnimationController.h:68:    /// Set weight command time-to-live.
AnimationController.h:125:    /// Set animation autofade on stop (non-looped animations only.) Zero time disables. Return true on success.
AnimationController.h:185:    /// Handle scene post-update event.
AnimationController.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
AnimationController.cpp:62:    context->RegisterFactory<AnimationController>(LOGIC_CATEGORY);
AnimationController.cpp:88:        AnimationState* state = GetAnimationState(i->hash_);
AnimationController.cpp:94:            if (i->speed_ != 0.0f)
AnimationController.cpp:95:                state->AddTime(i->speed_ * timeStep);
AnimationController.cpp:97:            float targetWeight = i->targetWeight_;
AnimationController.cpp:98:            float fadeTime = i->fadeTime_;
AnimationController.cpp:100:            // If non-looped animation at the end, activate autofade as applicable
AnimationController.cpp:101:            if (!state->IsLooped() && state->GetTime() >= state->GetLength() && i->autoFadeTime_ > 0.0f)
AnimationController.cpp:104:                fadeTime = i->autoFadeTime_;
AnimationController.cpp:108:            float currentWeight = state->GetWeight();
AnimationController.cpp:117:                        currentWeight = Max(currentWeight - weightDelta, targetWeight);
AnimationController.cpp:118:                    state->SetWeight(currentWeight);
AnimationController.cpp:121:                    state->SetWeight(targetWeight);
AnimationController.cpp:125:            if (state->GetWeight() == 0.0f && (targetWeight == 0.0f || fadeTime == 0.0f))
AnimationController.cpp:129:        // Decrement the command time-to-live values
AnimationController.cpp:130:        if (i->setTimeTtl_ > 0.0f)
AnimationController.cpp:131:            i->setTimeTtl_ = Max(i->setTimeTtl_ - timeStep, 0.0f);
AnimationController.cpp:132:        if (i->setWeightTtl_ > 0.0f)
AnimationController.cpp:133:            i->setWeightTtl_ = Max(i->setWeightTtl_ - timeStep, 0.0f);
AnimationController.cpp:148:        (*i)->Apply();
AnimationController.cpp:160:        Animation* newAnimation = GetSubsystem<ResourceCache>()->GetResource<Animation>(name);
AnimationController.cpp:169:        Animation* animation = state->GetAnimation();
AnimationController.cpp:170:        newControl.name_ = animation->GetName();
AnimationController.cpp:171:        newControl.hash_ = animation->GetNameHash();
AnimationController.cpp:173:        index = animations_.Size() - 1;
AnimationController.cpp:176:    state->SetLayer(layer);
AnimationController.cpp:177:    state->SetLooped(looped);
AnimationController.cpp:211:        AnimationState* state = GetAnimationState(i->hash_);
AnimationController.cpp:212:        if (state && state->GetLayer() == layer)
AnimationController.cpp:214:            i->targetWeight_ = 0.0f;
AnimationController.cpp:215:            i->fadeTime_ = fadeOutTime;
AnimationController.cpp:230:            i->targetWeight_ = 0.0f;
AnimationController.cpp:231:            i->fadeTime_ = fadeOutTime;
AnimationController.cpp:260:    unsigned char layer = state->GetLayer();
AnimationController.cpp:269:            if (otherState && otherState->GetLayer() == layer)
AnimationController.cpp:289:    state->SetLayer(layer);
AnimationController.cpp:301:    AnimationState* state = model->GetAnimationState(name);
AnimationController.cpp:305:    Bone* bone = model->GetSkeleton().GetBone(startBoneName);
AnimationController.cpp:306:    state->SetStartBone(bone);
AnimationController.cpp:319:    time = Clamp(time, 0.0f, state->GetLength());
AnimationController.cpp:320:    state->SetTime(time);
AnimationController.cpp:322:    animations_[index].setTime_ = (unsigned short)(time / state->GetLength() * 65535.0f);
AnimationController.cpp:351:    state->SetWeight(weight);
AnimationController.cpp:366:    state->SetLooped(enable);
AnimationController.cpp:400:    return animations_[index].fadeTime_ && animations_[index].targetWeight_ > state->GetWeight();
AnimationController.cpp:411:    return (animations_[index].fadeTime_ && animations_[index].targetWeight_ < state->GetWeight())
AnimationController.cpp:412:        || (!state->IsLooped() && state->GetTime() >= state->GetLength() && animations_[index].autoFadeTime_);
AnimationController.cpp:418:    return state ? state->GetLayer() : 0;
AnimationController.cpp:424:    return state ? state->GetStartBone() : 0;
AnimationController.cpp:430:    return bone ? bone->name_ : String::EMPTY;
AnimationController.cpp:436:    return state ? state->GetTime() : 0.0f;
AnimationController.cpp:442:    return state ? state->GetWeight() : 0.0f;
AnimationController.cpp:448:    return state ? state->IsLooped() : false;
AnimationController.cpp:454:    return state ? state->GetLength() : 0.0f;
AnimationController.cpp:499:        return model->GetAnimationState(nameHash);
AnimationController.cpp:504:        Animation* animation = (*i)->GetAnimation();
AnimationController.cpp:505:        if (animation->GetNameHash() == nameHash || animation->GetAnimationNameHash() == nameHash)
AnimationController.cpp:517:    while (index + 4 < value.Size())    // Prevent out-of-bound index access
AnimationController.cpp:540:    while (numAnimations--)
AnimationController.cpp:550:            Animation* newAnimation = GetSubsystem<ResourceCache>()->GetResource<Animation>(animName);
AnimationController.cpp:574:        state->SetLayer(buf.ReadUByte());
AnimationController.cpp:575:        state->SetLooped((ctrl & CTRL_LOOPED) != 0);
AnimationController.cpp:583:                state->SetStartBone(model->GetSkeleton().GetBone(boneHash));
AnimationController.cpp:586:            state->SetStartBone(0);
AnimationController.cpp:598:                state->SetTime(((float)setTime / 65535.0f) * state->GetLength());
AnimationController.cpp:609:                state->SetWeight((float)setWeight / 255.0f);
AnimationController.cpp:618:        if (!processedAnimations.Contains(i->hash_))
AnimationController.cpp:620:            i->targetWeight_ = 0.0f;
AnimationController.cpp:621:            i->fadeTime_ = EXTRA_ANIM_FADEOUT_TIME;
AnimationController.cpp:639:    while (numStates--)
AnimationController.cpp:645:            SharedPtr<AnimationState> newState(new AnimationState(GetNode(), cache->GetResource<Animation>(animRef.name_)));
AnimationController.cpp:648:            newState->SetLooped(value[index++].GetBool());
AnimationController.cpp:649:            newState->SetTime(value[index++].GetFloat());
AnimationController.cpp:666:        ret.Push(i->name_);
AnimationController.cpp:667:        ret.Push(i->speed_);
AnimationController.cpp:668:        ret.Push(i->targetWeight_);
AnimationController.cpp:669:        ret.Push(i->fadeTime_);
AnimationController.cpp:670:        ret.Push(i->autoFadeTime_);
AnimationController.cpp:684:        if (GetAnimationState(i->hash_))
AnimationController.cpp:691:        AnimationState* state = GetAnimationState(i->hash_);
AnimationController.cpp:696:        Bone* startBone = state->GetStartBone();
AnimationController.cpp:697:        if (state->IsLooped())
AnimationController.cpp:699:        if (startBone && model && startBone != model->GetSkeleton().GetRootBone())
AnimationController.cpp:701:        if (i->autoFadeTime_ > 0.0f)
AnimationController.cpp:703:        if (i->setTimeTtl_ > 0.0f)
AnimationController.cpp:705:        if (i->setWeightTtl_ > 0.0f)
AnimationController.cpp:708:        attrBuffer_.WriteString(i->name_);
AnimationController.cpp:710:        attrBuffer_.WriteUByte(state->GetLayer());
AnimationController.cpp:711:        attrBuffer_.WriteShort((short)Clamp(i->speed_ * 2048.0f, -32767.0f, 32767.0f));
AnimationController.cpp:712:        attrBuffer_.WriteUByte((unsigned char)(i->targetWeight_ * 255.0f));
AnimationController.cpp:713:        attrBuffer_.WriteUByte((unsigned char)Clamp(i->fadeTime_ * 64.0f, 0.0f, 255.0f));
AnimationController.cpp:715:            attrBuffer_.WriteStringHash(startBone->nameHash_);
AnimationController.cpp:717:            attrBuffer_.WriteUByte((unsigned char)Clamp(i->autoFadeTime_ * 64.0f, 0.0f, 255.0f));
AnimationController.cpp:720:            attrBuffer_.WriteUByte(i->setTimeRev_);
AnimationController.cpp:721:            attrBuffer_.WriteUShort(i->setTime_);
AnimationController.cpp:725:            attrBuffer_.WriteUByte(i->setWeightRev_);
AnimationController.cpp:726:            attrBuffer_.WriteUByte(i->setWeight_);
AnimationController.cpp:741:        Animation* animation = state->GetAnimation();
AnimationController.cpp:743:        ret.Push(state->IsLooped());
AnimationController.cpp:744:        ret.Push(state->GetTime());
AnimationController.cpp:767:        return model->AddAnimationState(animation);
AnimationController.cpp:784:        model->RemoveAnimationState(state);
AnimationController.cpp:808:        nameHash = state->GetAnimation()->GetNameHash();
AnimationState.h:2:// Copyright (c) 2008-2015 the Urho3D project.
AnimationState.h:39:/// %Animation instance per-track data.
AnimationState.h:70:    /// Set start bone. Not supported in node animation mode. Resets any assigned per-bone weights.
AnimationState.h:78:    /// Set per-bone blending weight by track index. Default is 1.0 (full), is multiplied  with the state's blending weight when applying the animation. Optionally recurses to child bones.
AnimationState.h:80:    /// Set per-bone blending weight by name.
AnimationState.h:82:    /// Set per-bone blending weight by name hash.
AnimationState.h:99:    /// Return per-bone blending weight by track index.
AnimationState.h:101:    /// Return per-bone blending weight by name.
AnimationState.h:103:    /// Return per-bone blending weight by name.
AnimationState.h:147:    /// Per-track data.
AnimationState.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
AnimationState.cpp:75:            const Vector<AnimationTrack>& tracks = animation_->GetTracks();
AnimationState.cpp:84:                if (node_->GetNameHash() == nameHash || tracks.Size() == 1)
AnimationState.cpp:88:                    Node* targetNode = node_->GetChild(nameHash, true);
AnimationState.cpp:92:                        LOGWARNING("Node " + tracks[i].name_ + " not found for node animation " + animation_->GetName());
AnimationState.cpp:112:    Skeleton& skeleton = model_->GetSkeleton();
AnimationState.cpp:127:    const Vector<AnimationTrack>& tracks = animation_->GetTracks();
AnimationState.cpp:130:    if (!startBone->node_)
AnimationState.cpp:142:        if (nameHash == startBone->nameHash_)
AnimationState.cpp:146:            Node* trackBoneNode = startBone->node_->GetChild(nameHash, true);
AnimationState.cpp:151:        if (trackBone && trackBone->node_)
AnimationState.cpp:154:            stateTrack.node_ = trackBone->node_;
AnimationState.cpp:159:    model_->MarkAnimationDirty();
AnimationState.cpp:176:            model_->MarkAnimationDirty();
AnimationState.cpp:186:    time = Clamp(time, 0.0f, animation_->GetLength());
AnimationState.cpp:191:            model_->MarkAnimationDirty();
AnimationState.cpp:206:            model_->MarkAnimationDirty();
AnimationState.cpp:214:            const Vector<SharedPtr<Node> >& children = boneNode->GetChildren();
AnimationState.cpp:248:    float length = animation_->GetLength();
AnimationState.cpp:257:            time -= length;
AnimationState.cpp:265:    if (animation_->GetNumTriggers())
AnimationState.cpp:273:                oldTime -= length;
AnimationState.cpp:281:                time -= length;
AnimationState.cpp:288:        const Vector<AnimationTriggerPoint>& triggers = animation_->GetTriggers();
AnimationState.cpp:291:            float frameTime = i->time_;
AnimationState.cpp:299:                Node* senderNode = model_ ? model_->GetNode() : node_;
AnimationState.cpp:301:                VariantMap& eventData = senderNode->GetEventDataMap();
AnimationState.cpp:303:                eventData[P_NAME] = animation_->GetAnimationName();
AnimationState.cpp:304:                eventData[P_TIME] = i->time_;
AnimationState.cpp:305:                eventData[P_DATA] = i->data_;
AnimationState.cpp:306:                senderNode->SendEvent(E_ANIMATIONTRIGGER, eventData);
AnimationState.cpp:318:            model_->MarkAnimationOrderDirty();
AnimationState.cpp:357:        if (node && node->GetName() == name)
AnimationState.cpp:380:        if (node && node->GetNameHash() == nameHash)
AnimationState.cpp:389:    return animation_ ? animation_->GetLength() : 0.0f;
AnimationState.cpp:411:        if (Equals(finalWeight, 0.0f) || !stateTrack.bone_->animated_)
AnimationState.cpp:433:    if (track->keyFrames_.Empty() || !node)
AnimationState.cpp:437:    track->GetKeyFrameIndex(time_, frame);
AnimationState.cpp:442:    if (nextFrame >= track->keyFrames_.Size())
AnimationState.cpp:453:    const AnimationKeyFrame* keyFrame = &track->keyFrames_[frame];
AnimationState.cpp:454:    unsigned char channelMask = track->channelMask_;
AnimationState.cpp:460:            node->SetPosition(keyFrame->position_);
AnimationState.cpp:462:            node->SetRotation(keyFrame->rotation_);
AnimationState.cpp:464:            node->SetScale(keyFrame->scale_);
AnimationState.cpp:468:        const AnimationKeyFrame* nextKeyFrame = &track->keyFrames_[nextFrame];
AnimationState.cpp:469:        float timeInterval = nextKeyFrame->time_ - keyFrame->time_;
AnimationState.cpp:471:            timeInterval += animation_->GetLength();
AnimationState.cpp:472:        float t = timeInterval > 0.0f ? (time_ - keyFrame->time_) / timeInterval : 1.0f;
AnimationState.cpp:476:            node->SetPosition(keyFrame->position_.Lerp(nextKeyFrame->position_, t));
AnimationState.cpp:478:            node->SetRotation(keyFrame->rotation_.Slerp(nextKeyFrame->rotation_, t));
AnimationState.cpp:480:            node->SetScale(keyFrame->scale_.Lerp(nextKeyFrame->scale_, t));
AnimationState.cpp:489:    if (track->keyFrames_.Empty() || !node)
AnimationState.cpp:493:    track->GetKeyFrameIndex(time_, frame);
AnimationState.cpp:498:    if (nextFrame >= track->keyFrames_.Size())
AnimationState.cpp:509:    const AnimationKeyFrame* keyFrame = &track->keyFrames_[frame];
AnimationState.cpp:510:    unsigned char channelMask = track->channelMask_;
AnimationState.cpp:516:            node->SetPositionSilent(keyFrame->position_);
AnimationState.cpp:518:            node->SetRotationSilent(keyFrame->rotation_);
AnimationState.cpp:520:            node->SetScaleSilent(keyFrame->scale_);
AnimationState.cpp:524:        const AnimationKeyFrame* nextKeyFrame = &track->keyFrames_[nextFrame];
AnimationState.cpp:525:        float timeInterval = nextKeyFrame->time_ - keyFrame->time_;
AnimationState.cpp:527:            timeInterval += animation_->GetLength();
AnimationState.cpp:528:        float t = timeInterval > 0.0f ? (time_ - keyFrame->time_) / timeInterval : 1.0f;
AnimationState.cpp:532:            node->SetPositionSilent(keyFrame->position_.Lerp(nextKeyFrame->position_, t));
AnimationState.cpp:534:            node->SetRotationSilent(keyFrame->rotation_.Slerp(nextKeyFrame->rotation_, t));
AnimationState.cpp:536:            node->SetScaleSilent(keyFrame->scale_.Lerp(nextKeyFrame->scale_, t));
AnimationState.cpp:545:    if (track->keyFrames_.Empty() || !node)
AnimationState.cpp:549:    track->GetKeyFrameIndex(time_, frame);
AnimationState.cpp:554:    if (nextFrame >= track->keyFrames_.Size())
AnimationState.cpp:565:    const AnimationKeyFrame* keyFrame = &track->keyFrames_[frame];
AnimationState.cpp:566:    unsigned char channelMask = track->channelMask_;
AnimationState.cpp:572:            node->SetPositionSilent(node->GetPosition().Lerp(keyFrame->position_, weight));
AnimationState.cpp:574:            node->SetRotationSilent(node->GetRotation().Slerp(keyFrame->rotation_, weight));
AnimationState.cpp:576:            node->SetScaleSilent(node->GetScale().Lerp(keyFrame->scale_, weight));
AnimationState.cpp:580:        const AnimationKeyFrame* nextKeyFrame = &track->keyFrames_[nextFrame];
AnimationState.cpp:581:        float timeInterval = nextKeyFrame->time_ - keyFrame->time_;
AnimationState.cpp:583:            timeInterval += animation_->GetLength();
AnimationState.cpp:584:        float t = timeInterval > 0.0f ? (time_ - keyFrame->time_) / timeInterval : 1.0f;
AnimationState.cpp:589:            node->SetPositionSilent(node->GetPosition().Lerp(
AnimationState.cpp:590:                keyFrame->position_.Lerp(nextKeyFrame->position_, t), weight));
AnimationState.cpp:594:            node->SetRotationSilent(node->GetRotation().Slerp(
AnimationState.cpp:595:                keyFrame->rotation_.Slerp(nextKeyFrame->rotation_, t), weight));
AnimationState.cpp:599:            node->SetScaleSilent(node->GetScale().Lerp(
AnimationState.cpp:600:                keyFrame->scale_.Lerp(nextKeyFrame->scale_, t), weight));
Batch.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Batch.h:106:    /// 8-bit light mask for stencil marking in deferred rendering.
Batch.h:165:    /// Pre-set the instance transforms. Buffer must be big enough to hold all transforms.
Batch.h:172:    /// Instance stream start index, or M_MAX_UNSIGNED if transforms not pre-set.
Batch.h:214:/// Queue that contains both instanced and non-instanced draw calls.
Batch.h:220:    /// Sort non-instanced draw calls back to front.
Batch.h:222:    /// Sort instanced and non-instanced draw calls front to back.
Batch.h:226:    /// Pre-set instance transforms of all groups. The vertex buffer must be big enough to hold all transforms.
Batch.h:237:    /// Shader remapping table for 2-pass state and distance sort.
Batch.h:239:    /// Material remapping table for 2-pass state and distance sort.
Batch.h:241:    /// Geometry remapping table for 2-pass state and distance sort.
Batch.h:244:    /// Unsorted non-instanced draw calls.
Batch.h:246:    /// Sorted non-instanced draw calls.
Batch.h:272:    /// Per-pixel light.
Batch.h:280:    /// Lit geometry draw calls, non-base (additive)
Batch.h:284:    /// Per-vertex lights.
Batch.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Batch.cpp:47:    if (lhs->sortKey_ != rhs->sortKey_)
Batch.cpp:48:        return lhs->sortKey_ < rhs->sortKey_;
Batch.cpp:50:        return lhs->distance_ < rhs->distance_;
Batch.cpp:55:    if (lhs->distance_ != rhs->distance_)
Batch.cpp:56:        return lhs->distance_ < rhs->distance_;
Batch.cpp:58:        return lhs->sortKey_ < rhs->sortKey_;
Batch.cpp:63:    if (lhs->distance_ != rhs->distance_)
Batch.cpp:64:        return lhs->distance_ > rhs->distance_;
Batch.cpp:66:        return lhs->sortKey_ < rhs->sortKey_;
Batch.cpp:76:    Camera* shadowCamera = queue->shadowSplits_[split].shadowCamera_;
Batch.cpp:77:    const IntRect& viewport = queue->shadowSplits_[split].shadowViewport_;
Batch.cpp:80:    Matrix3x4 shadowView(shadowCamera->GetView());
Batch.cpp:81:    Matrix4 shadowProj(shadowCamera->GetProjection());
Batch.cpp:84:    Texture2D* shadowMap = queue->shadowMap_;
Batch.cpp:88:    float width = (float)shadowMap->GetWidth();
Batch.cpp:89:    float height = (float)shadowMap->GetHeight();
Batch.cpp:103:    // Add pixel-perfect offset if needed by the graphics API
Batch.cpp:111:    offset.y_ = 1.0f - offset.y_;
Batch.cpp:113:    scale.y_ = -scale.y_;
Batch.cpp:117:    if (renderer->GetShadowQuality() & SHADOWQUALITY_HIGH_16BIT)
Batch.cpp:119:        offset.x_ -= 0.5f / width;
Batch.cpp:120:        offset.y_ -= 0.5f / height;
Batch.cpp:130:    Node* lightNode = light->GetNode();
Batch.cpp:132:    Matrix3x4 spotView = Matrix3x4(lightNode->GetWorldPosition(), lightNode->GetWorldRotation(), 1.0f).Inverse();
Batch.cpp:137:    float h = 1.005f / tanf(light->GetFov() * M_DEGTORAD * 0.5f);
Batch.cpp:138:    float w = h / light->GetAspectRatio();
Batch.cpp:141:    spotProj.m22_ = 1.0f / Max(light->GetRange(), M_EPSILON);
Batch.cpp:146:    texAdjust.SetScale(Vector3(0.5f, -0.5f, 0.5f));
Batch.cpp:149:    texAdjust.SetScale(Vector3(0.5f, -0.5f, 1.0f));
Batch.cpp:160:    if (pass_ && pass_->GetAlphaMask())
Batch.cpp:176:    Graphics* graphics = view->GetGraphics();
Batch.cpp:177:    Renderer* renderer = view->GetRenderer();
Batch.cpp:178:    Node* cameraNode = camera_ ? camera_->GetNode() : 0;
Batch.cpp:179:    Light* light = lightQueue_ ? lightQueue_->light_ : 0;
Batch.cpp:180:    Texture2D* shadowMap = lightQueue_ ? lightQueue_->shadowMap_ : 0;
Batch.cpp:183:    graphics->SetShaders(vertexShader_, pixelShader_);
Batch.cpp:185:    // Set pass / material-specific renderstates
Batch.cpp:188:        BlendMode blend = pass_->GetBlendMode();
Batch.cpp:190:        if (light && light->IsNegative())
Batch.cpp:197:        graphics->SetBlendMode(blend);
Batch.cpp:199:        bool isShadowPass = pass_->GetIndex() == Technique::shadowPassIndex;
Batch.cpp:200:        renderer->SetCullMode(isShadowPass ? material_->GetShadowCullMode() : material_->GetCullMode(), camera_);
Batch.cpp:203:            const BiasParameters& depthBias = material_->GetDepthBias();
Batch.cpp:204:            graphics->SetDepthBias(depthBias.constantBias_, depthBias.slopeScaledBias_);
Batch.cpp:208:        graphics->SetFillMode((FillMode)(Max(camera_->GetFillMode(), material_->GetFillMode())));
Batch.cpp:209:        graphics->SetDepthTest(pass_->GetDepthTestMode());
Batch.cpp:210:        graphics->SetDepthWrite(pass_->GetDepthWrite() && allowDepthWrite);
Batch.cpp:213:    // Set global (per-frame) shader parameters
Batch.cpp:214:    if (graphics->NeedParameterUpdate(SP_FRAME, (void*)0))
Batch.cpp:215:        view->SetGlobalShaderParameters();
Batch.cpp:219:    IntRect viewport = graphics->GetViewport();
Batch.cpp:222:    if (graphics->NeedParameterUpdate(SP_CAMERA, reinterpret_cast<const void*>(cameraHash + viewportHash)))
Batch.cpp:224:        view->SetCameraShaderParameters(camera_, true);
Batch.cpp:225:        // During renderpath commands the G-Buffer or viewport texture is assumed to always be viewport-sized
Batch.cpp:226:        view->SetGBufferShaderParameters(viewSize, IntRect(0, 0, viewSize.x_, viewSize.y_));
Batch.cpp:230:    if (setModelTransform && graphics->NeedParameterUpdate(SP_OBJECT, worldTransform_))
Batch.cpp:234:            graphics->SetShaderParameter(VSP_SKINMATRICES, reinterpret_cast<const float*>(worldTransform_), 
Batch.cpp:238:            graphics->SetShaderParameter(VSP_MODEL, *worldTransform_);
Batch.cpp:244:                graphics->SetShaderParameter(VSP_BILLBOARDROT, worldTransform_[1].RotationMatrix());
Batch.cpp:246:                graphics->SetShaderParameter(VSP_BILLBOARDROT, cameraNode->GetWorldRotation().RotationMatrix());
Batch.cpp:250:    // Set zone-related shader parameters
Batch.cpp:251:    BlendMode blend = graphics->GetBlendMode();
Batch.cpp:257:    if (zone_ && graphics->NeedParameterUpdate(SP_ZONE, reinterpret_cast<const void*>(zoneHash)))
Batch.cpp:259:        graphics->SetShaderParameter(VSP_AMBIENTSTARTCOLOR, zone_->GetAmbientStartColor());
Batch.cpp:260:        graphics->SetShaderParameter(VSP_AMBIENTENDCOLOR, zone_->GetAmbientEndColor().ToVector4() - zone_->GetAmbientStartColor().ToVector4());
Batch.cpp:262:        const BoundingBox& box = zone_->GetBoundingBox();
Batch.cpp:267:        Matrix3x4 zoneTransform = adjust * zone_->GetInverseWorldTransform();
Batch.cpp:268:        graphics->SetShaderParameter(VSP_ZONE, zoneTransform);
Batch.cpp:270:        graphics->SetShaderParameter(PSP_AMBIENTCOLOR, zone_->GetAmbientColor());
Batch.cpp:271:        graphics->SetShaderParameter(PSP_FOGCOLOR, overrideFogColorToBlack ? Color::BLACK : zone_->GetFogColor());
Batch.cpp:273:        float farClip = camera_->GetFarClip();
Batch.cpp:274:        float fogStart = Min(zone_->GetFogStart(), farClip);
Batch.cpp:275:        float fogEnd = Min(zone_->GetFogEnd(), farClip);
Batch.cpp:276:        if (fogStart >= fogEnd * (1.0f - M_LARGE_EPSILON))
Batch.cpp:277:            fogStart = fogEnd * (1.0f - M_LARGE_EPSILON);
Batch.cpp:278:        float fogRange = Max(fogEnd - fogStart, M_EPSILON);
Batch.cpp:281:        Node* zoneNode = zone_->GetNode();
Batch.cpp:282:        if (zone_->GetHeightFog() && zoneNode)
Batch.cpp:284:            Vector3 worldFogHeightVec = zoneNode->GetWorldTransform() * Vector3(0.0f, zone_->GetFogHeight(), 0.0f);
Batch.cpp:286:            fogParams.w_ = zone_->GetFogHeightScale() / Max(zoneNode->GetWorldScale().y_, M_EPSILON);
Batch.cpp:289:        graphics->SetShaderParameter(PSP_FOGPARAMS, fogParams);
Batch.cpp:292:    // Set light-related shader parameters
Batch.cpp:295:        if (light && graphics->NeedParameterUpdate(SP_LIGHT, lightQueue_))
Batch.cpp:297:            // Deferred light volume batches operate in a camera-centered space. Detect from material, zone & pass all being null
Batch.cpp:300:            Matrix3x4 cameraEffectiveTransform = camera_->GetEffectiveWorldTransform();
Batch.cpp:303:            Node* lightNode = light->GetNode();
Batch.cpp:304:            Matrix3 lightWorldRotation = lightNode->GetWorldRotation().RotationMatrix();
Batch.cpp:306:            graphics->SetShaderParameter(VSP_LIGHTDIR, lightWorldRotation * Vector3::BACK);
Batch.cpp:308:            float atten = 1.0f / Max(light->GetRange(), M_EPSILON);
Batch.cpp:309:            graphics->SetShaderParameter(VSP_LIGHTPOS, Vector4(lightNode->GetWorldPosition(), atten));
Batch.cpp:311:            if (graphics->HasShaderParameter(VSP_LIGHTMATRICES))
Batch.cpp:313:                switch (light->GetLightType())
Batch.cpp:318:                    unsigned numSplits = Min(MAX_CASCADE_SPLITS, (int)lightQueue_->shadowSplits_.Size());
Batch.cpp:323:                    graphics->SetShaderParameter(VSP_LIGHTMATRICES, shadowMatrices[0].Data(), 16 * numSplits);
Batch.cpp:332:                    bool isShadowed = shadowMap && graphics->HasTextureUnit(TU_SHADOWMAP);
Batch.cpp:336:                    graphics->SetShaderParameter(VSP_LIGHTMATRICES, shadowMatrices[0].Data(), isShadowed ? 32 : 16);
Batch.cpp:342:                    Matrix4 lightVecRot(lightNode->GetWorldRotation().RotationMatrix());
Batch.cpp:346:                    graphics->SetShaderParameter(VSP_LIGHTMATRICES, lightVecRot.Data(), 16);
Batch.cpp:348:                    graphics->SetShaderParameter(VSP_LIGHTMATRICES, lightVecRot.Data(), 12);
Batch.cpp:356:            float fadeEnd = light->GetDrawDistance();
Batch.cpp:357:            float fadeStart = light->GetFadeDistance();
Batch.cpp:360:            if (light->GetLightType() != LIGHT_DIRECTIONAL && fadeEnd > 0.0f && fadeStart > 0.0f && fadeStart < fadeEnd)
Batch.cpp:361:                fade = Min(1.0f - (light->GetDistance() - fadeStart) / (fadeEnd - fadeStart), 1.0f);
Batch.cpp:364:            graphics->SetShaderParameter(PSP_LIGHTCOLOR, Color(light->GetEffectiveColor().Abs(),
Batch.cpp:365:                light->GetEffectiveSpecularIntensity()) * fade);
Batch.cpp:366:            graphics->SetShaderParameter(PSP_LIGHTDIR, lightWorldRotation * Vector3::BACK);
Batch.cpp:367:            graphics->SetShaderParameter(PSP_LIGHTPOS, Vector4((isLightVolume ? (lightNode->GetWorldPosition() -
Batch.cpp:368:                cameraEffectivePos) : lightNode->GetWorldPosition()), atten));
Batch.cpp:370:            if (graphics->HasShaderParameter(PSP_LIGHTMATRICES))
Batch.cpp:372:                switch (light->GetLightType())
Batch.cpp:377:                    unsigned numSplits = Min(MAX_CASCADE_SPLITS, (int)lightQueue_->shadowSplits_.Size());
Batch.cpp:384:                    graphics->SetShaderParameter(PSP_LIGHTMATRICES, shadowMatrices[0].Data(), 16 * numSplits);
Batch.cpp:393:                    bool isShadowed = lightQueue_->shadowMap_ != 0;
Batch.cpp:400:                    graphics->SetShaderParameter(PSP_LIGHTMATRICES, shadowMatrices[0].Data(), isShadowed ? 32 : 16);
Batch.cpp:406:                    Matrix4 lightVecRot(lightNode->GetWorldRotation().RotationMatrix());
Batch.cpp:410:                    graphics->SetShaderParameter(PSP_LIGHTMATRICES, lightVecRot.Data(), 16);
Batch.cpp:412:                    graphics->SetShaderParameter(PSP_LIGHTMATRICES, lightVecRot.Data(), 12);
Batch.cpp:424:                    unsigned faceWidth = shadowMap->GetWidth() / 2;
Batch.cpp:425:                    unsigned faceHeight = shadowMap->GetHeight() / 3;
Batch.cpp:426:                    float width = (float)shadowMap->GetWidth();
Batch.cpp:427:                    float height = (float)shadowMap->GetHeight();
Batch.cpp:429:                    float mulX = (float)(faceWidth - 3) / width;
Batch.cpp:430:                    float mulY = (float)(faceHeight - 3) / height;
Batch.cpp:434:                    float mulX = (float)(faceWidth - 4) / width;
Batch.cpp:435:                    float mulY = (float)(faceHeight - 4) / height;
Batch.cpp:440:                    if (renderer->GetShadowQuality() & SHADOWQUALITY_HIGH_16BIT)
Batch.cpp:442:                        addX -= 0.5f / width;
Batch.cpp:443:                        addY -= 0.5f / height;
Batch.cpp:445:                    graphics->SetShaderParameter(PSP_SHADOWCUBEADJUST, Vector4(mulX, mulY, addX, addY));
Batch.cpp:451:                    Camera* shadowCamera = lightQueue_->shadowSplits_[0].shadowCamera_;
Batch.cpp:452:                    float nearClip = shadowCamera->GetNearClip();
Batch.cpp:453:                    float farClip = shadowCamera->GetFarClip();
Batch.cpp:454:                    float q = farClip / (farClip - nearClip);
Batch.cpp:455:                    float r = -q * nearClip;
Batch.cpp:457:                    const CascadeParameters& parameters = light->GetShadowCascade();
Batch.cpp:458:                    float viewFarClip = camera_->GetFarClip();
Batch.cpp:462:                    float fadeRange = fadeEnd - fadeStart;
Batch.cpp:464:                    graphics->SetShaderParameter(PSP_SHADOWDEPTHFADE, Vector4(q, r, fadeStart, 1.0f / fadeRange));
Batch.cpp:468:                    float intensity = light->GetShadowIntensity();
Batch.cpp:469:                    float fadeStart = light->GetShadowFadeDistance();
Batch.cpp:470:                    float fadeEnd = light->GetShadowDistance();
Batch.cpp:472:                        intensity = Lerp(intensity, 1.0f, Clamp((light->GetDistance() - fadeStart) / (fadeEnd - fadeStart), 0.0f, 1.0f));
Batch.cpp:473:                    float pcfValues = (1.0f - intensity);
Batch.cpp:474:                    float samples = renderer->GetShadowQuality() >= SHADOWQUALITY_HIGH_16BIT ? 4.0f : 1.0f;
Batch.cpp:476:                    graphics->SetShaderParameter(PSP_SHADOWINTENSITY, Vector4(pcfValues / samples, intensity, 0.0f, 0.0f));
Batch.cpp:479:                float sizeX = 1.0f / (float)shadowMap->GetWidth();
Batch.cpp:480:                float sizeY = 1.0f / (float)shadowMap->GetHeight();
Batch.cpp:481:                graphics->SetShaderParameter(PSP_SHADOWMAPINVSIZE, Vector4(sizeX, sizeY, 0.0f, 0.0f));
Batch.cpp:484:                if (lightQueue_->shadowSplits_.Size() > 1)
Batch.cpp:485:                    lightSplits.x_ = lightQueue_->shadowSplits_[0].farSplit_ / camera_->GetFarClip();
Batch.cpp:486:                if (lightQueue_->shadowSplits_.Size() > 2)
Batch.cpp:487:                    lightSplits.y_ = lightQueue_->shadowSplits_[1].farSplit_ / camera_->GetFarClip();
Batch.cpp:488:                if (lightQueue_->shadowSplits_.Size() > 3)
Batch.cpp:489:                    lightSplits.z_ = lightQueue_->shadowSplits_[2].farSplit_ / camera_->GetFarClip();
Batch.cpp:491:                graphics->SetShaderParameter(PSP_SHADOWSPLITS, lightSplits);
Batch.cpp:494:        else if (lightQueue_->vertexLights_.Size() && graphics->HasShaderParameter(VSP_VERTEXLIGHTS) &&
Batch.cpp:495:            graphics->NeedParameterUpdate(SP_LIGHT, lightQueue_))
Batch.cpp:498:            const PODVector<Light*>& lights = lightQueue_->vertexLights_;
Batch.cpp:503:                Node* vertexLightNode = vertexLight->GetNode();
Batch.cpp:504:                LightType type = vertexLight->GetLightType();
Batch.cpp:511:                    invRange = 1.0f / Max(vertexLight->GetRange(), M_EPSILON);
Batch.cpp:514:                    cutoff = Cos(vertexLight->GetFov() * 0.5f);
Batch.cpp:515:                    invCutoff = 1.0f / (1.0f - cutoff);
Batch.cpp:519:                    cutoff = -1.0f;
Batch.cpp:525:                float fadeEnd = vertexLight->GetDrawDistance();
Batch.cpp:526:                float fadeStart = vertexLight->GetFadeDistance();
Batch.cpp:529:                if (vertexLight->GetLightType() != LIGHT_DIRECTIONAL && fadeEnd > 0.0f && fadeStart > 0.0f && fadeStart < fadeEnd)
Batch.cpp:530:                    fade = Min(1.0f - (vertexLight->GetDistance() - fadeStart) / (fadeEnd - fadeStart), 1.0f);
Batch.cpp:532:                Color color = vertexLight->GetEffectiveColor() * fade;
Batch.cpp:536:                vertexLights[i * 3 + 1] = Vector4(-(vertexLightNode->GetWorldDirection()), cutoff);
Batch.cpp:539:                vertexLights[i * 3 + 2] = Vector4(vertexLightNode->GetWorldPosition(), invCutoff);
Batch.cpp:542:            graphics->SetShaderParameter(VSP_VERTEXLIGHTS, vertexLights[0].Data(), lights.Size() * 3 * 4);
Batch.cpp:546:    // Set material-specific shader parameters and textures
Batch.cpp:549:        if (graphics->NeedParameterUpdate(SP_MATERIAL, reinterpret_cast<const void*>(material_->GetShaderParameterHash())))
Batch.cpp:551:            const HashMap<StringHash, MaterialShaderParameter>& parameters = material_->GetShaderParameters();
Batch.cpp:553:                graphics->SetShaderParameter(i->first_, i->second_.value_);
Batch.cpp:556:        const HashMap<TextureUnit, SharedPtr<Texture> >& textures = material_->GetTextures();
Batch.cpp:559:            if (graphics->HasTextureUnit(i->first_))
Batch.cpp:560:                graphics->SetTexture(i->first_, i->second_.Get());
Batch.cpp:564:    // Set light-related textures
Batch.cpp:567:        if (shadowMap && graphics->HasTextureUnit(TU_SHADOWMAP))
Batch.cpp:568:            graphics->SetTexture(TU_SHADOWMAP, shadowMap);
Batch.cpp:569:        if (graphics->HasTextureUnit(TU_LIGHTRAMP))
Batch.cpp:571:            Texture* rampTexture = light->GetRampTexture();
Batch.cpp:573:                rampTexture = renderer->GetDefaultLightRamp();
Batch.cpp:574:            graphics->SetTexture(TU_LIGHTRAMP, rampTexture);
Batch.cpp:576:        if (graphics->HasTextureUnit(TU_LIGHTSHAPE))
Batch.cpp:578:            Texture* shapeTexture = light->GetShapeTexture();
Batch.cpp:579:            if (!shapeTexture && light->GetLightType() == LIGHT_SPOT)
Batch.cpp:580:                shapeTexture = renderer->GetDefaultLightSpot();
Batch.cpp:581:            graphics->SetTexture(TU_LIGHTSHAPE, shapeTexture);
Batch.cpp:587:    if (zone_ && graphics->HasTextureUnit(TU_ZONE))
Batch.cpp:588:        graphics->SetTexture(TU_ZONE, zone_->GetZoneTexture());
Batch.cpp:594:    if (!geometry_->IsEmpty())
Batch.cpp:597:        geometry_->Draw(view->GetGraphics());
Batch.cpp:619:    Graphics* graphics = view->GetGraphics();
Batch.cpp:620:    Renderer* renderer = view->GetRenderer();
Batch.cpp:622:    if (instances_.Size() && !geometry_->IsEmpty())
Batch.cpp:625:        VertexBuffer* instanceBuffer = renderer->GetInstancingBuffer();
Batch.cpp:630:            graphics->SetIndexBuffer(geometry_->GetIndexBuffer());
Batch.cpp:631:            graphics->SetVertexBuffers(geometry_->GetVertexBuffers(), geometry_->GetVertexElementMasks());
Batch.cpp:635:                if (graphics->NeedParameterUpdate(SP_OBJECT, instances_[i].worldTransform_))
Batch.cpp:636:                    graphics->SetShaderParameter(VSP_MODEL, *instances_[i].worldTransform_);
Batch.cpp:638:                graphics->Draw(geometry_->GetPrimitiveType(), geometry_->GetIndexStart(), geometry_->GetIndexCount(),
Batch.cpp:639:                    geometry_->GetVertexStart(), geometry_->GetVertexCount());
Batch.cpp:649:                (geometry_->GetVertexBuffers());
Batch.cpp:650:            PODVector<unsigned>& elementMasks = const_cast<PODVector<unsigned>&>(geometry_->GetVertexElementMasks());
Batch.cpp:652:            elementMasks.Push(instanceBuffer->GetElementMask());
Batch.cpp:654:            graphics->SetIndexBuffer(geometry_->GetIndexBuffer());
Batch.cpp:655:            graphics->SetVertexBuffers(vertexBuffers, elementMasks, startIndex_);
Batch.cpp:656:            graphics->DrawInstanced(geometry_->GetPrimitiveType(), geometry_->GetIndexStart(), geometry_->GetIndexCount(),
Batch.cpp:657:                geometry_->GetVertexStart(), geometry_->GetVertexCount(), instances_.Size());
Batch.cpp:697:        sortedBatchGroups_[index++] = &i->second_;
Batch.cpp:712:        if (i->second_.instances_.Size() <= maxSortedInstances_)
Batch.cpp:714:            Sort(i->second_.instances_.Begin(), i->second_.instances_.End(), CompareInstancesFrontToBack);
Batch.cpp:715:            if (i->second_.instances_.Size())
Batch.cpp:716:                i->second_.distance_ = i->second_.instances_[0].distance_;
Batch.cpp:721:            for (PODVector<InstanceData>::ConstIterator j = i->second_.instances_.Begin(); j != i->second_.instances_.End(); ++j)
Batch.cpp:722:                minDistance = Min(minDistance, j->distance_);
Batch.cpp:723:            i->second_.distance_ = minDistance;
Batch.cpp:731:        sortedBatchGroups_[index++] = &i->second_;
Batch.cpp:738:    // Mobile devices likely use a tiled deferred approach, with which front-to-back sorting is irrelevant. The 2-pass
Batch.cpp:754:        unsigned shaderID = (batch->sortKey_ >> 32);
Batch.cpp:757:            shaderID = j->second_;
Batch.cpp:764:        unsigned short materialID = (unsigned short)(batch->sortKey_ & 0xffff0000);
Batch.cpp:767:            materialID = k->second_;
Batch.cpp:774:        unsigned short geometryID = (unsigned short)(batch->sortKey_ & 0xffff);
Batch.cpp:777:            geometryID = l->second_;
Batch.cpp:784:        batch->sortKey_ = (((unsigned long long)shaderID) << 32) || (((unsigned long long)materialID) << 16) | geometryID;
Batch.cpp:799:        i->second_.SetTransforms(lockedData, freeIndex);
Batch.cpp:804:    Graphics* graphics = view->GetGraphics();
Batch.cpp:805:    Renderer* renderer = view->GetRenderer();
Batch.cpp:810:        graphics->SetScissorTest(false);
Batch.cpp:812:        // During G-buffer rendering, mark opaque pixels' lightmask to stencil buffer if requested
Batch.cpp:814:            graphics->SetStencilTest(false);
Batch.cpp:822:            graphics->SetStencilTest(true, CMP_ALWAYS, OP_REF, OP_KEEP, OP_KEEP, group->lightMask_);
Batch.cpp:824:        group->Draw(view, allowDepthWrite);
Batch.cpp:826:    // Non-instanced
Batch.cpp:831:            graphics->SetStencilTest(true, CMP_ALWAYS, OP_REF, OP_KEEP, OP_KEEP, batch->lightMask_);
Batch.cpp:835:            if (!batch->isBase_ && batch->lightQueue_)
Batch.cpp:836:                renderer->OptimizeLightByScissor(batch->lightQueue_->light_, batch->camera_);
Batch.cpp:838:                graphics->SetScissorTest(false);
Batch.cpp:841:        batch->Draw(view, allowDepthWrite);
Batch.cpp:851:       if (i->second_.geometryType_ == GEOM_INSTANCED)
Batch.cpp:852:            total += i->second_.instances_.Size();
BillboardSet.h:2:// Copyright (c) 2008-2015 the Urho3D project.
BillboardSet.h:42:    /// Two-dimensional size.
BillboardSet.h:73:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
BillboardSet.h:130:    /// Recalculate the world-space bounding box.
BillboardSet.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
BillboardSet.cpp:60:    return lhs->sortDistance_ > rhs->sortDistance_;
BillboardSet.cpp:81:    geometry_->SetVertexBuffer(0, vertexBuffer_, MASK_POSITION | MASK_COLOR | MASK_TEXCOORD1 | MASK_TEXCOORD2);
BillboardSet.cpp:82:    geometry_->SetIndexBuffer(indexBuffer_);
BillboardSet.cpp:96:    context->RegisterFactory<BillboardSet>(GEOMETRY_CATEGORY);
BillboardSet.cpp:116:    // If no billboard-level testing, use the Drawable test
BillboardSet.cpp:123:    // Check ray hit distance to AABB before proceeding with billboard-level tests
BillboardSet.cpp:127:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
BillboardSet.cpp:147:            result.normal_ = -query.ray_.direction_;
BillboardSet.cpp:166:    Vector3 worldPos = node_->GetWorldPosition();
BillboardSet.cpp:167:    Vector3 offset = (worldPos - frame.camera_->GetNode()->GetWorldPosition());
BillboardSet.cpp:172:    distance_ = frame.camera_->GetDistance(GetWorldBoundingBox().Center());
BillboardSet.cpp:178:        lodDistance_ = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
BillboardSet.cpp:185:    transforms_[0] = relative_ ? node_->GetWorldTransform() : Matrix3x4::IDENTITY;
BillboardSet.cpp:187:    transforms_[1] = Matrix3x4(Vector3::ZERO, faceCameraMode_ != FC_NONE ? frame.camera_->GetFaceCameraRotation(
BillboardSet.cpp:188:        node_->GetWorldPosition(), node_->GetWorldRotation(), faceCameraMode_) : node_->GetWorldRotation(), Vector3::ONE);
BillboardSet.cpp:193:    if (bufferSizeDirty_ || indexBuffer_->IsDataLost())
BillboardSet.cpp:196:    if (bufferDirty_ || sortThisFrame_ || vertexBuffer_->IsDataLost())
BillboardSet.cpp:199:    // If using camera facing, re-update the rotation for the current view now
BillboardSet.cpp:202:        transforms_[1] = Matrix3x4(Vector3::ZERO, frame.camera_->GetFaceCameraRotation(node_->GetWorldPosition(),
BillboardSet.cpp:203:            node_->GetWorldRotation(), faceCameraMode_), Vector3::ONE);
BillboardSet.cpp:210:    if (bufferDirty_ || bufferSizeDirty_ || vertexBuffer_->IsDataLost() || indexBuffer_->IsDataLost() || sortThisFrame_)
BillboardSet.cpp:300:    SetMaterial(cache->GetResource<Material>(value.name_));
BillboardSet.cpp:311:        i->position_ = value[index++].GetVector3();
BillboardSet.cpp:312:        i->size_ = value[index++].GetVector2();
BillboardSet.cpp:314:        i->uv_ = Rect(uv.x_, uv.y_, uv.z_, uv.w_);
BillboardSet.cpp:315:        i->color_ = value[index++].GetColor();
BillboardSet.cpp:316:        i->rotation_ = value[index++].GetFloat();
BillboardSet.cpp:317:        i->enabled_ = value[index++].GetBool();
BillboardSet.cpp:331:        i->position_ = buf.ReadVector3();
BillboardSet.cpp:332:        i->size_ = buf.ReadVector2();
BillboardSet.cpp:333:        i->uv_ = buf.ReadRect();
BillboardSet.cpp:334:        i->color_ = buf.ReadColor();
BillboardSet.cpp:335:        i->rotation_ = buf.ReadFloat();
BillboardSet.cpp:336:        i->enabled_ = buf.ReadBool();
BillboardSet.cpp:355:        ret.Push(i->position_);
BillboardSet.cpp:356:        ret.Push(i->size_);
BillboardSet.cpp:357:        ret.Push(Vector4(i->uv_.min_.x_, i->uv_.min_.y_, i->uv_.max_.x_, i->uv_.max_.y_));
BillboardSet.cpp:358:        ret.Push(i->color_);
BillboardSet.cpp:359:        ret.Push(i->rotation_);
BillboardSet.cpp:360:        ret.Push(i->enabled_);
BillboardSet.cpp:373:        attrBuffer_.WriteVector3(i->position_);
BillboardSet.cpp:374:        attrBuffer_.WriteVector2(i->size_);
BillboardSet.cpp:375:        attrBuffer_.WriteRect(i->uv_);
BillboardSet.cpp:376:        attrBuffer_.WriteColor(i->color_);
BillboardSet.cpp:377:        attrBuffer_.WriteFloat(i->rotation_);
BillboardSet.cpp:378:        attrBuffer_.WriteBool(i->enabled_);
BillboardSet.cpp:387:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
BillboardSet.cpp:400:        worldBox.Merge(BoundingBox(center - edge, center + edge));
BillboardSet.cpp:406:    worldBox.Merge(node_->GetWorldPosition());
BillboardSet.cpp:415:    if (vertexBuffer_->GetVertexCount() != numBillboards * 4)
BillboardSet.cpp:416:        vertexBuffer_->SetSize(numBillboards * 4, MASK_POSITION | MASK_COLOR | MASK_TEXCOORD1 | MASK_TEXCOORD2, true);
BillboardSet.cpp:417:    if (indexBuffer_->GetIndexCount() != numBillboards * 6)
BillboardSet.cpp:418:        indexBuffer_->SetSize(numBillboards * 6, false);
BillboardSet.cpp:428:    unsigned short* dest = (unsigned short*)indexBuffer_->Lock(0, numBillboards * 6, true);
BillboardSet.cpp:433:    while (numBillboards--)
BillboardSet.cpp:442:    indexBuffer_->Unlock();
BillboardSet.cpp:443:    indexBuffer_->ClearDataLost();
BillboardSet.cpp:464:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
BillboardSet.cpp:486:                billboard.sortDistance_ = frame.camera_->GetDistanceSquared(billboardTransform * billboards_[i].position_);
BillboardSet.cpp:490:    batches_[0].geometry_->SetDrawRange(TRIANGLE_LIST, 0, enabledBillboards * 6, false);
BillboardSet.cpp:500:        Vector3 worldPos = node_->GetWorldPosition();
BillboardSet.cpp:502:        previousOffset_ = (worldPos - frame.camera_->GetNode()->GetWorldPosition());
BillboardSet.cpp:505:    float* dest = (float*)vertexBuffer_->Lock(0, enabledBillboards * 4, true);
BillboardSet.cpp:519:        rotationMatrix[1][0] = -rotationMatrix[0][1];
BillboardSet.cpp:525:        dest[6] = -size.x_ * rotationMatrix[0][0] + size.y_ * rotationMatrix[0][1];
BillboardSet.cpp:526:        dest[7] = -size.x_ * rotationMatrix[1][0] + size.y_ * rotationMatrix[1][1];
BillboardSet.cpp:537:        dest[22] = size.x_ * rotationMatrix[0][0] - size.y_ * rotationMatrix[0][1];
BillboardSet.cpp:538:        dest[23] = size.x_ * rotationMatrix[1][0] - size.y_ * rotationMatrix[1][1];
BillboardSet.cpp:543:        dest[30] = -size.x_ * rotationMatrix[0][0] - size.y_ * rotationMatrix[0][1];
BillboardSet.cpp:544:        dest[31] = -size.x_ * rotationMatrix[1][0] - size.y_ * rotationMatrix[1][1];
BillboardSet.cpp:549:    vertexBuffer_->Unlock();
BillboardSet.cpp:550:    vertexBuffer_->ClearDataLost();
Camera.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Camera.cpp:46:    0.0f, -1.0f, 0.0f, 0.0f,
Camera.cpp:84:    context->RegisterFactory<Camera>(SCENE_CATEGORY);
Camera.cpp:108:    debug->AddFrustum(GetFrustum(), Color::WHITE, depthTest);
Camera.cpp:316:        ret.origin_ = node_ ? node_->GetWorldPosition() : Vector3::ZERO;
Camera.cpp:317:        ret.direction_ = node_ ? node_->GetWorldDirection() : Vector3::FORWARD;
Camera.cpp:323:    // The parameters range from 0.0 to 1.0. Expand to normalized device coordinates (-1.0 to 1.0) & flip Y axis
Camera.cpp:324:    x = 2.0f * x - 1.0f;
Camera.cpp:325:    y = 1.0f - 2.0f * y;
Camera.cpp:330:    ret.direction_ = ((viewProjInverse * far) - ret.origin_).Normalized();
Camera.cpp:347:        ret.x_ = (-eyeSpacePos.x_ > 0.0f) ? -1.0f : 1.0f;
Camera.cpp:348:        ret.y_ = (-eyeSpacePos.y_ > 0.0f) ? -1.0f : 1.0f;
Camera.cpp:352:    ret.y_ = 1.0f - ((ret.y_ / 2.0f) + 0.5f);
Camera.cpp:410:            q = (farClip_ + nearClip) / (farClip_ - nearClip);
Camera.cpp:411:            r = -2.0f * farClip_ * nearClip / (farClip_ - nearClip);
Camera.cpp:415:            q = farClip_ / (farClip_ - nearClip);
Camera.cpp:416:            r = -q * nearClip;
Camera.cpp:437:            r = -1.0f;
Camera.cpp:482:        near.y_ = -near.y_;
Camera.cpp:483:        far.y_ = -far.y_;
Camera.cpp:499:        const Vector3& cameraPos = node_ ? node_->GetWorldPosition() : Vector3::ZERO;
Camera.cpp:500:        return (worldPos - cameraPos).Length();
Camera.cpp:510:        const Vector3& cameraPos = node_ ? node_->GetWorldPosition() : Vector3::ZERO;
Camera.cpp:511:        return (worldPos - cameraPos).LengthSquared();
Camera.cpp:540:        return node_->GetWorldRotation();
Camera.cpp:545:            euler.y_ = node_->GetWorldRotation().EulerAngles().y_;
Camera.cpp:552:            lookAt.FromLookRotation(position - node_->GetWorldPosition());
Camera.cpp:558:            // Make the Y-only lookat happen on an XZ plane to make sure there are no unwanted transitions
Camera.cpp:560:            Vector3 lookAtVec(position - node_->GetWorldPosition());
Camera.cpp:575:    Matrix3x4 worldTransform = node_ ? Matrix3x4(node_->GetWorldPosition(), node_->GetWorldRotation(), 1.0f) : Matrix3x4::IDENTITY;
Camera.cpp:635:        node->AddListener(this);
Camera.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Camera.h:67:    /// Set orthographic mode view non-uniform size. Disables the auto aspect ratio -mode.
Camera.h:69:    /// Set aspect ratio manually. Disables the auto aspect ratio -mode.
Camera.h:124:    /// Return API-specific projection matrix.
Camera.h:126:    /// Return either API-specific or API-independent (D3D convention) projection matrix.
Camera.h:140:    /// Return ray corresponding to normalized screen coordinates (0.0 - 1.0).
Camera.h:142:    // Convert a world space point to normalized screen coordinates (0.0 - 1.0).
Camera.h:144:    // Convert normalized screen coordinates (0.0 - 1.0) and depth to a world space point.
ConstantBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
CustomGeometry.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
CustomGeometry.cpp:54:    vertexBuffer_->SetShadowed(true);
CustomGeometry.cpp:64:    context->RegisterFactory<CustomGeometry>(GEOMETRY_CATEGORY);
CustomGeometry.cpp:91:        Matrix3x4 inverse(node_->GetWorldTransform().Inverse());
CustomGeometry.cpp:94:        Vector3 normal = -query.ray_.direction_;
CustomGeometry.cpp:106:                    float geometryDistance = geometry->GetHitDistance(localRay, &geometryNormal);
CustomGeometry.cpp:110:                        normal = (node_->GetWorldTransform() * Vector4(geometryNormal, 0.0f)).Normalized();
CustomGeometry.cpp:148:        if (mat && !mat->GetOcclusion())
CustomGeometry.cpp:151:        triangles += geometry->GetVertexCount() / 3;
CustomGeometry.cpp:171:            if (!material->GetOcclusion())
CustomGeometry.cpp:173:            buffer->SetCullMode(material->GetCullMode());
CustomGeometry.cpp:176:            buffer->SetCullMode(CULL_CCW);
CustomGeometry.cpp:184:        geometry->GetRawData(vertexData, vertexSize, indexData, indexSize, elementMask);
CustomGeometry.cpp:190:        success = buffer->Draw(node_->GetWorldTransform(), vertexData, vertexSize, geometry->GetVertexStart(), geometry->GetVertexCount());
CustomGeometry.cpp:334:    if (vertexBuffer_->GetVertexCount() != totalVertices || vertexBuffer_->GetElementMask() != elementMask_ ||
CustomGeometry.cpp:335:        vertexBuffer_->IsDynamic() != dynamic_)
CustomGeometry.cpp:336:        vertexBuffer_->SetSize(totalVertices, elementMask_, dynamic_);
CustomGeometry.cpp:340:        unsigned char* dest = (unsigned char*)vertexBuffer_->Lock(0, totalVertices, true);
CustomGeometry.cpp:378:                geometries_[i]->SetVertexBuffer(0, vertexBuffer_, elementMask_);
CustomGeometry.cpp:379:                geometries_[i]->SetDrawRange(primitiveTypes_[i], 0, 0, vertexStart, vertexCount);
CustomGeometry.cpp:383:            vertexBuffer_->Unlock();
CustomGeometry.cpp:392:            geometries_[i]->SetVertexBuffer(0, vertexBuffer_, elementMask_);
CustomGeometry.cpp:393:            geometries_[i]->SetDrawRange(primitiveTypes_[i], 0, 0, 0, 0);
CustomGeometry.cpp:397:    vertexBuffer_->ClearDataLost();
CustomGeometry.cpp:475:        SetMaterial(i, cache->GetResource<Material>(value.names_[i]));
CustomGeometry.cpp:520:    worldBoundingBox_ = boundingBox_.Transformed(node_->GetWorldTransform());
CustomGeometry.h:2:// Copyright (c) 2008-2015 the Urho3D project.
CustomGeometry.h:119:    /// Recalculate the world-space bounding box.
DebugRenderer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
DebugRenderer.cpp:63:    context->RegisterFactory<DebugRenderer>(SUBSYSTEM_CATEGORY);
DebugRenderer.cpp:71:    view_ = camera->GetView();
DebugRenderer.cpp:72:    projection_ = camera->GetProjection();
DebugRenderer.cpp:73:    frustum_ = camera->GetFrustum();
DebugRenderer.cpp:113:    Vector3 start = node->GetWorldPosition();
DebugRenderer.cpp:114:    Quaternion rotation = node->GetWorldRotation();
DebugRenderer.cpp:258:    AddLine(position - offsetXVec, position + heightVec - offsetXVec, color, depthTest);
DebugRenderer.cpp:260:    AddLine(position - offsetZVec, position + heightVec - offsetZVec, color, depthTest);
DebugRenderer.cpp:281:        Vector3 start = boneNode->GetWorldPosition();
DebugRenderer.cpp:285:        Node* parentNode = boneNode->GetParent();
DebugRenderer.cpp:289:            end = parentNode->GetWorldPosition();
DebugRenderer.cpp:303:    // 16-bit indices
DebugRenderer.cpp:349:    assert(graphics && graphics->IsInitialized() && !graphics->IsDeviceLost());
DebugRenderer.cpp:353:    ShaderVariation* vs = graphics->GetShader(VS, "Basic", "VERTEXCOLOR");
DebugRenderer.cpp:354:    ShaderVariation* ps = graphics->GetShader(PS, "Basic", "VERTEXCOLOR");
DebugRenderer.cpp:358:    if (vertexBuffer_->GetVertexCount() < numVertices || vertexBuffer_->GetVertexCount() > numVertices * 2)
DebugRenderer.cpp:359:        vertexBuffer_->SetSize(numVertices, MASK_POSITION | MASK_COLOR, true);
DebugRenderer.cpp:361:    float* dest = (float*)vertexBuffer_->Lock(0, numVertices, true);
DebugRenderer.cpp:421:    vertexBuffer_->Unlock();
DebugRenderer.cpp:423:    graphics->SetBlendMode(BLEND_REPLACE);
DebugRenderer.cpp:424:    graphics->SetColorWrite(true);
DebugRenderer.cpp:425:    graphics->SetCullMode(CULL_NONE);
DebugRenderer.cpp:426:    graphics->SetDepthWrite(true);
DebugRenderer.cpp:427:    graphics->SetScissorTest(false);
DebugRenderer.cpp:428:    graphics->SetStencilTest(false);
DebugRenderer.cpp:429:    graphics->SetShaders(vs, ps);
DebugRenderer.cpp:430:    graphics->SetShaderParameter(VSP_MODEL, Matrix3x4::IDENTITY);
DebugRenderer.cpp:431:    graphics->SetShaderParameter(VSP_VIEWPROJ, projection_ * view_);
DebugRenderer.cpp:432:    graphics->SetShaderParameter(PSP_MATDIFFCOLOR, Color(1.0f, 1.0f, 1.0f, 1.0f));
DebugRenderer.cpp:433:    graphics->SetVertexBuffer(vertexBuffer_);
DebugRenderer.cpp:440:        graphics->SetDepthTest(CMP_LESSEQUAL);
DebugRenderer.cpp:441:        graphics->Draw(LINE_LIST, start, count);
DebugRenderer.cpp:447:        graphics->SetDepthTest(CMP_ALWAYS);
DebugRenderer.cpp:448:        graphics->Draw(LINE_LIST, start, count);
DebugRenderer.cpp:452:    graphics->SetBlendMode(BLEND_ALPHA);
DebugRenderer.cpp:457:        graphics->SetDepthTest(CMP_LESSEQUAL);
DebugRenderer.cpp:458:        graphics->Draw(TRIANGLE_LIST, start, count);
DebugRenderer.cpp:464:        graphics->SetDepthTest(CMP_ALWAYS);
DebugRenderer.cpp:465:        graphics->Draw(TRIANGLE_LIST, start, count);
DebugRenderer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11ConstantBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11ConstantBuffer.cpp:52:        ((ID3D11Buffer*)object_)->Release();
Direct3D11\D3D11ConstantBuffer.cpp:66:        LOGERROR("Can not create zero-sized constant buffer");
Direct3D11\D3D11ConstantBuffer.cpp:89:        graphics_->GetImpl()->GetDevice()->CreateBuffer(&bufferDesc, 0, (ID3D11Buffer**)&object_);
Direct3D11\D3D11ConstantBuffer.cpp:118:    while (rows--)
Direct3D11\D3D11ConstantBuffer.cpp:133:        graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Buffer*)object_, 0, 0, shadowData_.Get(), 0, 0);
Direct3D11\D3D11GPUObject.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11GPUObject.h:44:    /// Clear the data lost flag. No-op on D3D11.
DecalSet.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
DecalSet.cpp:62:    float t = d0 / (d0 - d1);
DecalSet.cpp:64:    ret.position_ = v0.position_ + t * (v1.position_ - v0.position_);
DecalSet.cpp:65:    ret.normal_ = v0.normal_ + t * (v1.normal_ - v0.normal_);
DecalSet.cpp:83:                ret.blendWeights_[i] = v0.blendWeights_[i] + t * (v1.blendWeights_[i] - v0.blendWeights_[i]);
DecalSet.cpp:167:    geometry_->SetIndexBuffer(indexBuffer_);
DecalSet.cpp:180:    context->RegisterFactory<DecalSet>(GEOMETRY_CATEGORY);
DecalSet.cpp:213:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
DecalSet.cpp:214:    distance_ = frame.camera_->GetDistance(worldBoundingBox.Center());
DecalSet.cpp:217:    lodDistance_ = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
DecalSet.cpp:229:    if (bufferDirty_ || vertexBuffer_->IsDataLost() || indexBuffer_->IsDataLost())
DecalSet.cpp:238:    if (bufferDirty_ || bufferSizeDirty_ || vertexBuffer_->IsDataLost() || indexBuffer_->IsDataLost())
DecalSet.cpp:296:    if (!target || !target->GetNode())
DecalSet.cpp:312:    Vector3 adjustedWorldPosition = worldPosition - 0.5f * depth * (worldRotation * Vector3::FORWARD);
DecalSet.cpp:314:    Matrix3x4 targetTransform = target->GetNode()->GetWorldTransform().Inverse();
DecalSet.cpp:320:        Skeleton& skeleton = animatedModel->GetSkeleton();
DecalSet.cpp:328:            if (!bone->node_ || !bone->collisionMask_)
DecalSet.cpp:332:            Sphere decalSphere(bone->node_->GetWorldTransform().Inverse() * worldPosition, 0.5f * size /
DecalSet.cpp:333:                bone->node_->GetWorldScale().Length());
DecalSet.cpp:335:            if (bone->collisionMask_ & BONECOLLISION_BOX)
DecalSet.cpp:337:                float size = bone->boundingBox_.HalfSize().Length();
DecalSet.cpp:338:                if (bone->boundingBox_.IsInside(decalSphere) && size > bestSize)
DecalSet.cpp:344:            else if (bone->collisionMask_ & BONECOLLISION_SPHERE)
DecalSet.cpp:346:                Sphere boneSphere(Vector3::ZERO, bone->radius_);
DecalSet.cpp:347:                float size = bone->radius_;
DecalSet.cpp:357:            targetTransform = (bestBone->node_->GetWorldTransform() * bestBone->offsetMatrix_).Inverse();
DecalSet.cpp:374:    unsigned numBatches = target->GetBatches().Size();
DecalSet.cpp:409:            newDecal.AddVertex(face[j - 1]);
DecalSet.cpp:446:    Matrix3x4 decalTransform = node_->GetWorldTransform().Inverse() * target->GetNode()->GetWorldTransform();
DecalSet.cpp:462:    // If new decal is time limited, subscribe to scene post-update
DecalSet.cpp:472:    while (num-- && decals_.Size())
DecalSet.cpp:489:        if (i->node_)
DecalSet.cpp:490:            i->node_->RemoveListener(this);
DecalSet.cpp:506:    SetMaterial(cache->GetResource<Material>(value.name_));
DecalSet.cpp:521:    while (numDecals--)
DecalSet.cpp:533:            i->position_ = buffer.ReadVector3();
DecalSet.cpp:534:            i->normal_ = buffer.ReadVector3();
DecalSet.cpp:535:            i->texCoord_ = buffer.ReadVector2();
DecalSet.cpp:536:            i->tangent_ = buffer.ReadVector4();
DecalSet.cpp:540:                    i->blendWeights_[j] = buffer.ReadFloat();
DecalSet.cpp:542:                    i->blendIndices_[j] = buffer.ReadUByte();
DecalSet.cpp:597:        ret.WriteFloat(i->timer_);
DecalSet.cpp:598:        ret.WriteFloat(i->timeToLive_);
DecalSet.cpp:599:        ret.WriteVLE(i->vertices_.Size());
DecalSet.cpp:600:        ret.WriteVLE(i->indices_.Size());
DecalSet.cpp:602:        for (PODVector<DecalVertex>::ConstIterator j = i->vertices_.Begin(); j != i->vertices_.End(); ++j)
DecalSet.cpp:604:            ret.WriteVector3(j->position_);
DecalSet.cpp:605:            ret.WriteVector3(j->normal_);
DecalSet.cpp:606:            ret.WriteVector2(j->texCoord_);
DecalSet.cpp:607:            ret.WriteVector4(j->tangent_);
DecalSet.cpp:611:                    ret.WriteFloat(j->blendWeights_[k]);
DecalSet.cpp:613:                    ret.WriteUByte(j->blendIndices_[k]);
DecalSet.cpp:617:        for (PODVector<unsigned short>::ConstIterator j = i->indices_.Begin(); j != i->indices_.End(); ++j)
DecalSet.cpp:627:            ret.WriteString(i->name_);
DecalSet.cpp:628:            ret.WriteUByte(i->collisionMask_);
DecalSet.cpp:629:            if (i->collisionMask_ & BONECOLLISION_SPHERE)
DecalSet.cpp:630:                ret.WriteFloat(i->radius_);
DecalSet.cpp:631:            if (i->collisionMask_ & BONECOLLISION_BOX)
DecalSet.cpp:632:                ret.WriteBoundingBox(i->boundingBox_);
DecalSet.cpp:633:            ret.Write(i->offsetMatrix_.Data(), sizeof(Matrix3x4));
DecalSet.cpp:658:        worldBoundingBox_ = boundingBox_.Transformed(node_->GetWorldTransform());
DecalSet.cpp:667:            Node* boneNode = i->node_;
DecalSet.cpp:673:            if (i->collisionMask_ & BONECOLLISION_BOX)
DecalSet.cpp:674:                worldBox.Merge(i->boundingBox_.Transformed(boneNode->GetWorldTransform()));
DecalSet.cpp:675:            else if (i->collisionMask_ & BONECOLLISION_SPHERE)
DecalSet.cpp:676:                worldBox.Merge(Sphere(boneNode->GetWorldPosition(), i->radius_ * 0.5f));
DecalSet.cpp:687:    Geometry* geometry = target->GetLodGeometry(batchIndex, 0);
DecalSet.cpp:688:    if (!geometry || geometry->GetPrimitiveType() != TRIANGLE_LIST)
DecalSet.cpp:700:    IndexBuffer* ib = geometry->GetIndexBuffer();
DecalSet.cpp:703:        indexData = ib->GetShadowData();
DecalSet.cpp:704:        indexStride = ib->GetIndexSize();
DecalSet.cpp:708:    for (unsigned i = 0; i < geometry->GetNumVertexBuffers(); ++i)
DecalSet.cpp:710:        VertexBuffer* vb = geometry->GetVertexBuffer(i);
DecalSet.cpp:714:        unsigned elementMask = geometry->GetVertexElementMask(i);
DecalSet.cpp:715:        unsigned char* data = vb->GetShadowData();
DecalSet.cpp:722:            positionStride = vb->GetVertexSize();
DecalSet.cpp:726:            normalData = data + vb->GetElementOffset(ELEMENT_NORMAL);
DecalSet.cpp:727:            normalStride = vb->GetVertexSize();
DecalSet.cpp:731:            skinningData = data + vb->GetElementOffset(ELEMENT_BLENDWEIGHTS);
DecalSet.cpp:732:            skinningStride = vb->GetVertexSize();
DecalSet.cpp:741:        geometry->GetRawData(positionData, positionStride, indexData, indexStride, elementMask);
DecalSet.cpp:744:            LOGWARNING("Can not add decal, target drawable has no CPU-side geometry data");
DecalSet.cpp:751:        unsigned indexStart = geometry->GetIndexStart();
DecalSet.cpp:752:        unsigned indexCount = geometry->GetIndexCount();
DecalSet.cpp:754:        // 16-bit indices
DecalSet.cpp:768:        // 32-bit indices
DecalSet.cpp:783:        // Non-indexed geometry
DecalSet.cpp:784:        unsigned indices = geometry->GetVertexStart();
DecalSet.cpp:785:        unsigned indicesEnd = indices + geometry->GetVertexCount();
DecalSet.cpp:812:        Vector3 dist1 = v1 - v0;
DecalSet.cpp:813:        Vector3 dist2 = v2 - v0;
DecalSet.cpp:830:    for (unsigned i = PLANE_FAR; i < NUM_FRUSTUM_PLANES; --i)
DecalSet.cpp:877:    // Check whether target is using global or per-geometry skinning
DecalSet.cpp:878:    const Vector<PODVector<Matrix3x4> >& geometrySkinMatrices = animatedModel->GetGeometrySkinMatrices();
DecalSet.cpp:879:    const Vector<PODVector<unsigned> >& geometryBoneMappings = animatedModel->GetGeometryBoneMappings();
DecalSet.cpp:887:                bone = animatedModel->GetSkeleton().GetBone(blendIndices[i]);
DecalSet.cpp:889:                bone = animatedModel->GetSkeleton().GetBone(geometryBoneMappings[batchIndex][blendIndices[i]]);
DecalSet.cpp:902:                if (bones_[index].node_ == bone->node_)
DecalSet.cpp:906:                    if (bones_[index].offsetMatrix_.Equals(bone->offsetMatrix_))
DecalSet.cpp:931:                    bone->node_->AddListener(this);
DecalSet.cpp:953:        Vector3 projected = viewProj * i->position_;
DecalSet.cpp:954:        i->texCoord_ = Vector2(
DecalSet.cpp:965:        i->position_ = transform * i->position_;
DecalSet.cpp:966:        i->normal_ = (transform * i->normal_).Normalized();
DecalSet.cpp:972:    numVertices_ -= i->vertices_.Size();
DecalSet.cpp:973:    numIndices_ -= i->indices_.Size();
DecalSet.cpp:992:        boundingBox_.Merge(i->boundingBox_);
DecalSet.cpp:999:    vertexBuffer_->SetSize(maxVertices_, skinned_ ? SKINNED_ELEMENT_MASK : STATIC_ELEMENT_MASK);
DecalSet.cpp:1000:    indexBuffer_->SetSize(maxIndices_, false);
DecalSet.cpp:1001:    geometry_->SetVertexBuffer(0, vertexBuffer_);
DecalSet.cpp:1009:    geometry_->SetDrawRange(TRIANGLE_LIST, 0, numIndices_, 0, numVertices_);
DecalSet.cpp:1011:    float* vertices = (float*)vertexBuffer_->Lock(0, numVertices_);
DecalSet.cpp:1012:    unsigned short* indices = (unsigned short*)indexBuffer_->Lock(0, numIndices_);
DecalSet.cpp:1020:            for (unsigned j = 0; j < i->vertices_.Size(); ++j)
DecalSet.cpp:1022:                const DecalVertex& vertex = i->vertices_[j];
DecalSet.cpp:1045:            for (unsigned j = 0; j < i->indices_.Size(); ++j)
DecalSet.cpp:1046:                *indices++ = i->indices_[j] + indexStart;
DecalSet.cpp:1048:            indexStart += i->vertices_.Size();
DecalSet.cpp:1052:    vertexBuffer_->Unlock();
DecalSet.cpp:1053:    vertexBuffer_->ClearDataLost();
DecalSet.cpp:1054:    indexBuffer_->Unlock();
DecalSet.cpp:1055:    indexBuffer_->ClearDataLost();
DecalSet.cpp:1062:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
DecalSet.cpp:1068:            skinMatrices_[i] = bone.node_->GetWorldTransform() * bone.offsetMatrix_;
DecalSet.cpp:1087:        batches_[0].worldTransform_ = &node_->GetWorldTransform();
DecalSet.cpp:1102:        Node* boneNode = node_->GetChild(i->name_, true);
DecalSet.cpp:1104:            boneNode->AddListener(this);
DecalSet.cpp:1105:        i->node_ = boneNode;
DecalSet.cpp:1123:            if (i->timeToLive_ > 0.0f)
DecalSet.cpp:1154:        i->timer_ += timeStep;
DecalSet.cpp:1157:        if (i->timeToLive_ > 0.0f && i->timer_ > i->timeToLive_)
Direct3D11\D3D11ConstantBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11ConstantBuffer.h:47:    /// Set size and create GPU-side buffer. Return true on success.
Direct3D11\D3D11GPUObject.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11GPUObject.cpp:37:        graphics->AddGPUObject(this);
Direct3D11\D3D11GPUObject.cpp:43:        graphics_->RemoveGPUObject(this);
DecalSet.h:2:// Copyright (c) 2008-2015 the Urho3D project.
DecalSet.h:89:    /// Calculate local-space bounding box.
DecalSet.h:96:    /// Local-space bounding box.
DecalSet.h:123:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
DecalSet.h:130:    /// Set material. The material should use a small negative depth bias to avoid Z-fighting.
DecalSet.h:166:    /// Recalculate the world-space bounding box.
DecalSet.h:186:    /// Recalculate the local-space bounding box.
DecalSet.h:198:    /// Subscribe/unsubscribe from scene post-update as necessary.
DecalSet.h:200:    /// Handle scene post-update event.
Direct3D11\D3D11GraphicsImpl.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11Graphics.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11Graphics.h:60:/// CPU-side scratch buffer for vertex data updates.
Direct3D11\D3D11Graphics.h:108:    /// Set allowed screen orientations as a space-separated list of "LandscapeLeft", "LandscapeRight", "Portrait" and "PortraitUpsideDown". Affects currently only iOS platform.
Direct3D11\D3D11Graphics.h:124:    /// Draw non-indexed geometry.
Direct3D11\D3D11Graphics.h:182:    /// Reset all rendertargets, depth-stencil surface and viewport.
Direct3D11\D3D11Graphics.h:186:    /// Reset depth-stencil surface.
Direct3D11\D3D11Graphics.h:192:    /// Set depth-stencil surface.
Direct3D11\D3D11Graphics.h:194:    /// Set depth-stencil surface.
Direct3D11\D3D11Graphics.h:229:    /// Return graphics implementation, which holds the actual API-specific resources.
Direct3D11\D3D11Graphics.h:231:    /// Return OS-specific external window handle. Null if not in use.
Direct3D11\D3D11Graphics.h:271:    /// Return 24-bit shadow map depth texture format, or 0 if not supported.
Direct3D11\D3D11Graphics.h:275:    /// Return whether light pre-pass rendering is supported.
Direct3D11\D3D11Graphics.h:317:    /// Return current depth-stencil surface.
Direct3D11\D3D11Graphics.h:376:    /// Reserve a CPU-side scratch buffer.
Direct3D11\D3D11Graphics.h:378:    /// Free a CPU-side scratch buffer.
Direct3D11\D3D11Graphics.h:387:    /// Return the API-specific alpha texture format.
Direct3D11\D3D11Graphics.h:389:    /// Return the API-specific luminance texture format.
Direct3D11\D3D11Graphics.h:391:    /// Return the API-specific luminance alpha texture format.
Direct3D11\D3D11Graphics.h:393:    /// Return the API-specific RGB texture format.
Direct3D11\D3D11Graphics.h:395:    /// Return the API-specific RGBA texture format.
Direct3D11\D3D11Graphics.h:397:    /// Return the API-specific RGBA 16-bit texture format.
Direct3D11\D3D11Graphics.h:399:    /// Return the API-specific RGBA 16-bit float texture format.
Direct3D11\D3D11Graphics.h:401:    /// Return the API-specific RGBA 32-bit float texture format.
Direct3D11\D3D11Graphics.h:403:    /// Return the API-specific RG 16-bit texture format.
Direct3D11\D3D11Graphics.h:405:    /// Return the API-specific RG 16-bit float texture format.
Direct3D11\D3D11Graphics.h:407:    /// Return the API-specific RG 32-bit float texture format.
Direct3D11\D3D11Graphics.h:409:    /// Return the API-specific single channel 16-bit float texture format.
Direct3D11\D3D11Graphics.h:411:    /// Return the API-specific single channel 32-bit float texture format.
Direct3D11\D3D11Graphics.h:413:    /// Return the API-specific linear depth texture format.
Direct3D11\D3D11Graphics.h:415:    /// Return the API-specific hardware depth-stencil texture format.
Direct3D11\D3D11Graphics.h:417:    /// Return the API-specific readable hardware depth format, or 0 if not supported.
Direct3D11\D3D11Graphics.h:419:    /// Return the API-specific texture format from a textual description, for example "rgb".
Direct3D11\D3D11Graphics.h:478:    /// Light pre-pass rendering support flag.
Direct3D11\D3D11Graphics.h:504:    /// Shadow map 24-bit depth texture format.
Direct3D11\D3D11Graphics.h:526:    /// Depth-stencil surface in use.
Direct3D11\D3D11Graphics.h:566:    /// Current custom clip plane in post-projection space.
Direct3D11\D3D11Graphics.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11Graphics.cpp:194:        primitiveCount = elementCount - 2;
Direct3D11\D3D11Graphics.cpp:199:        primitiveCount = elementCount - 1;
Direct3D11\D3D11Graphics.cpp:258:    // Initialize SDL now. Graphics should be the first SDL-using subsystem to be created
Direct3D11\D3D11Graphics.cpp:272:            (*i)->Release();
Direct3D11\D3D11Graphics.cpp:279:    for (HashMap<unsigned, ID3D11BlendState*>::Iterator i = impl_->blendStates_.Begin(); i != impl_->blendStates_.End(); ++i)
Direct3D11\D3D11Graphics.cpp:281:        if (i->second_)
Direct3D11\D3D11Graphics.cpp:282:            i->second_->Release();
Direct3D11\D3D11Graphics.cpp:284:    impl_->blendStates_.Clear();
Direct3D11\D3D11Graphics.cpp:286:    for (HashMap<unsigned, ID3D11DepthStencilState*>::Iterator i = impl_->depthStates_.Begin(); i != impl_->depthStates_.End(); ++i)
Direct3D11\D3D11Graphics.cpp:288:        if (i->second_)
Direct3D11\D3D11Graphics.cpp:289:            i->second_->Release();
Direct3D11\D3D11Graphics.cpp:291:    impl_->depthStates_.Clear();
Direct3D11\D3D11Graphics.cpp:293:    for (HashMap<unsigned, ID3D11RasterizerState*>::Iterator i = impl_->rasterizerStates_.Begin(); i != impl_->rasterizerStates_.End(); ++i)
Direct3D11\D3D11Graphics.cpp:295:        if (i->second_)
Direct3D11\D3D11Graphics.cpp:296:            i->second_->Release();
Direct3D11\D3D11Graphics.cpp:298:    impl_->rasterizerStates_.Clear();
Direct3D11\D3D11Graphics.cpp:300:    if (impl_->defaultRenderTargetView_)
Direct3D11\D3D11Graphics.cpp:302:        impl_->defaultRenderTargetView_->Release();
Direct3D11\D3D11Graphics.cpp:303:        impl_->defaultRenderTargetView_ = 0;
Direct3D11\D3D11Graphics.cpp:305:    if (impl_->defaultDepthStencilView_)
Direct3D11\D3D11Graphics.cpp:307:        impl_->defaultDepthStencilView_->Release();
Direct3D11\D3D11Graphics.cpp:308:        impl_->defaultDepthStencilView_ = 0;
Direct3D11\D3D11Graphics.cpp:310:    if (impl_->defaultDepthTexture_)
Direct3D11\D3D11Graphics.cpp:312:        impl_->defaultDepthTexture_->Release();
Direct3D11\D3D11Graphics.cpp:313:        impl_->defaultDepthTexture_ = 0;
Direct3D11\D3D11Graphics.cpp:315:    if (impl_->swapChain_)
Direct3D11\D3D11Graphics.cpp:317:        impl_->swapChain_->Release();
Direct3D11\D3D11Graphics.cpp:318:        impl_->swapChain_ = 0;
Direct3D11\D3D11Graphics.cpp:320:    if (impl_->deviceContext_)
Direct3D11\D3D11Graphics.cpp:322:        impl_->deviceContext_->Release();
Direct3D11\D3D11Graphics.cpp:323:        impl_->deviceContext_ = 0;
Direct3D11\D3D11Graphics.cpp:325:    if (impl_->device_)
Direct3D11\D3D11Graphics.cpp:327:        impl_->device_->Release();
Direct3D11\D3D11Graphics.cpp:328:        impl_->device_ = 0;
Direct3D11\D3D11Graphics.cpp:330:    if (impl_->window_)
Direct3D11\D3D11Graphics.cpp:333:        SDL_DestroyWindow(impl_->window_);
Direct3D11\D3D11Graphics.cpp:334:        impl_->window_ = 0;
Direct3D11\D3D11Graphics.cpp:340:    // Shut down SDL now. Graphics should be the last SDL-using subsystem to be destroyed
Direct3D11\D3D11Graphics.cpp:346:    if (!impl_->window_)
Direct3D11\D3D11Graphics.cpp:355:    if (impl_->window_)
Direct3D11\D3D11Graphics.cpp:356:        SDL_SetWindowTitle(impl_->window_, windowTitle_.CString());
Direct3D11\D3D11Graphics.cpp:362:    if (impl_->window_)
Direct3D11\D3D11Graphics.cpp:368:    if (impl_->window_)
Direct3D11\D3D11Graphics.cpp:369:        SDL_SetWindowPosition(impl_->window_, position.x_, position.y_);
Direct3D11\D3D11Graphics.cpp:421:    if (!impl_->window_)
Direct3D11\D3D11Graphics.cpp:440:                unsigned error = Abs(resolutions[i].x_ - width) + Abs(resolutions[i].y_ - height);
Direct3D11\D3D11Graphics.cpp:458:        SDL_GetWindowSize(impl_->window_, &width, &height);
Direct3D11\D3D11Graphics.cpp:461:    if (!impl_->device_ || multiSample_ != multiSample)
Direct3D11\D3D11Graphics.cpp:473:    impl_->swapChain_->Present(0, 0);
Direct3D11\D3D11Graphics.cpp:511:        if (impl_->swapChain_)
Direct3D11\D3D11Graphics.cpp:524:    if (impl_->device_)
Direct3D11\D3D11Graphics.cpp:527:        impl_->device_->QueryInterface(IID_IDXGIDevice1, (void **)&dxgiDevice);
Direct3D11\D3D11Graphics.cpp:530:            dxgiDevice->SetMaximumFrameLatency(enable ? 1 : 3);
Direct3D11\D3D11Graphics.cpp:531:            dxgiDevice->Release();
Direct3D11\D3D11Graphics.cpp:549:    if (impl_->window_)
Direct3D11\D3D11Graphics.cpp:552:        SDL_DestroyWindow(impl_->window_);
Direct3D11\D3D11Graphics.cpp:553:        impl_->window_ = 0;
Direct3D11\D3D11Graphics.cpp:561:    if (!impl_->device_)
Direct3D11\D3D11Graphics.cpp:577:    impl_->device_->CreateTexture2D(&textureDesc, 0, &stagingTexture);
Direct3D11\D3D11Graphics.cpp:585:    impl_->defaultRenderTargetView_->GetResource(&source);
Direct3D11\D3D11Graphics.cpp:594:        impl_->device_->CreateTexture2D(&textureDesc, 0, &resolveTexture);
Direct3D11\D3D11Graphics.cpp:598:            stagingTexture->Release();
Direct3D11\D3D11Graphics.cpp:602:        impl_->deviceContext_->ResolveSubresource(resolveTexture, 0, source, 0, DXGI_FORMAT_R8G8B8A8_UNORM);
Direct3D11\D3D11Graphics.cpp:603:        impl_->deviceContext_->CopyResource(stagingTexture, resolveTexture);
Direct3D11\D3D11Graphics.cpp:604:        resolveTexture->Release();
Direct3D11\D3D11Graphics.cpp:607:        impl_->deviceContext_->CopyResource(stagingTexture, source);
Direct3D11\D3D11Graphics.cpp:609:    source->Release();
Direct3D11\D3D11Graphics.cpp:613:    impl_->deviceContext_->Map(stagingTexture, 0, D3D11_MAP_READ, 0, &mappedData);
Direct3D11\D3D11Graphics.cpp:630:        impl_->deviceContext_->Unmap(stagingTexture, 0);
Direct3D11\D3D11Graphics.cpp:631:        stagingTexture->Release();
Direct3D11\D3D11Graphics.cpp:637:        stagingTexture->Release();
Direct3D11\D3D11Graphics.cpp:652:        SDL_GetWindowSize(impl_->window_, &width, &height);
Direct3D11\D3D11Graphics.cpp:660:        if (fullscreen_ && (SDL_GetWindowFlags(impl_->window_) & SDL_WINDOW_MINIMIZED))
Direct3D11\D3D11Graphics.cpp:689:        impl_->swapChain_->Present(vsync_ ? 1 : 0, 0);
Direct3D11\D3D11Graphics.cpp:706:        if ((flags & CLEAR_COLOR) && impl_->renderTargetViews_[0])
Direct3D11\D3D11Graphics.cpp:707:            impl_->deviceContext_->ClearRenderTargetView(impl_->renderTargetViews_[0], color.Data());
Direct3D11\D3D11Graphics.cpp:709:        if ((flags & (CLEAR_DEPTH | CLEAR_STENCIL)) && impl_->depthStencilView_)
Direct3D11\D3D11Graphics.cpp:716:            impl_->deviceContext_->ClearDepthStencilView(impl_->depthStencilView_, depthClearFlags, depth, stencil);
Direct3D11\D3D11Graphics.cpp:725:        Geometry* geometry = renderer->GetQuadGeometry();
Direct3D11\D3D11Graphics.cpp:743:        geometry->Draw(this);
Direct3D11\D3D11Graphics.cpp:754:    if (!destination || !destination->GetRenderSurface())
Direct3D11\D3D11Graphics.cpp:774:    destRect.right = destination->GetWidth();
Direct3D11\D3D11Graphics.cpp:775:    destRect.bottom = destination->GetHeight();
Direct3D11\D3D11Graphics.cpp:782:        source = (ID3D11Resource*)renderTargets_[0]->GetParentTexture()->GetGPUObject();
Direct3D11\D3D11Graphics.cpp:785:        impl_->defaultRenderTargetView_->GetResource(&source);
Direct3D11\D3D11Graphics.cpp:791:        impl_->deviceContext_->CopyResource((ID3D11Resource*)destination->GetGPUObject(), source);
Direct3D11\D3D11Graphics.cpp:794:        impl_->deviceContext_->ResolveSubresource((ID3D11Resource*)destination->GetGPUObject(), 0, source, 0, (DXGI_FORMAT)
Direct3D11\D3D11Graphics.cpp:795:            destination->GetFormat());
Direct3D11\D3D11Graphics.cpp:799:        source->Release();
Direct3D11\D3D11Graphics.cpp:817:        impl_->deviceContext_->IASetPrimitiveTopology(d3dPrimitiveType);
Direct3D11\D3D11Graphics.cpp:820:    impl_->deviceContext_->Draw(vertexCount, vertexStart);
Direct3D11\D3D11Graphics.cpp:839:        impl_->deviceContext_->IASetPrimitiveTopology(d3dPrimitiveType);
Direct3D11\D3D11Graphics.cpp:842:    impl_->deviceContext_->DrawIndexed(indexCount, indexStart, 0);
Direct3D11\D3D11Graphics.cpp:862:        impl_->deviceContext_->IASetPrimitiveTopology(d3dPrimitiveType);
Direct3D11\D3D11Graphics.cpp:865:    impl_->deviceContext_->DrawIndexedInstanced(indexCount, instanceCount, indexStart, 0, 0);
Direct3D11\D3D11Graphics.cpp:873:    // Note: this is not multi-instance safe
Direct3D11\D3D11Graphics.cpp:903:            unsigned elementMask = buffer->GetElementMask() & elementMasks[i];
Direct3D11\D3D11Graphics.cpp:904:            unsigned offset = (elementMask & MASK_INSTANCEMATRIX1) ? instanceOffset * buffer->GetVertexSize() : 0;
Direct3D11\D3D11Graphics.cpp:906:            if (buffer != vertexBuffers_[i] || elementMask != elementMasks_[i] || offset != impl_->vertexOffsets_[i])
Direct3D11\D3D11Graphics.cpp:910:                impl_->vertexBuffers_[i] = (ID3D11Buffer*)buffer->GetGPUObject();
Direct3D11\D3D11Graphics.cpp:911:                impl_->vertexSizes_[i] = buffer->GetVertexSize();
Direct3D11\D3D11Graphics.cpp:912:                impl_->vertexOffsets_[i] = offset;
Direct3D11\D3D11Graphics.cpp:920:            impl_->vertexBuffers_[i] = 0;
Direct3D11\D3D11Graphics.cpp:921:            impl_->vertexSizes_[i] = 0;
Direct3D11\D3D11Graphics.cpp:922:            impl_->vertexOffsets_[i] = 0;
Direct3D11\D3D11Graphics.cpp:957:            impl_->deviceContext_->IASetIndexBuffer((ID3D11Buffer*)buffer->GetGPUObject(), buffer->GetIndexSize() ==
Direct3D11\D3D11Graphics.cpp:961:            impl_->deviceContext_->IASetIndexBuffer(0, DXGI_FORMAT_UNKNOWN, 0);
Direct3D11\D3D11Graphics.cpp:974:            vs = vs->GetOwner()->GetVariation(VS, vs->GetDefines() + " CLIPPLANE");
Direct3D11\D3D11Graphics.cpp:976:            ps = ps->GetOwner()->GetVariation(PS, ps->GetDefines() + " CLIPPLANE");
Direct3D11\D3D11Graphics.cpp:985:        if (vs && !vs->GetGPUObject())
Direct3D11\D3D11Graphics.cpp:987:            if (vs->GetCompilerOutput().Empty())
Direct3D11\D3D11Graphics.cpp:991:                bool success = vs->Create();
Direct3D11\D3D11Graphics.cpp:994:                    LOGERROR("Failed to compile vertex shader " + vs->GetFullName() + ":\n" + vs->GetCompilerOutput());
Direct3D11\D3D11Graphics.cpp:1002:        impl_->deviceContext_->VSSetShader((ID3D11VertexShader*)(vs ? vs->GetGPUObject() : 0), 0, 0);
Direct3D11\D3D11Graphics.cpp:1009:        if (ps && !ps->GetGPUObject())
Direct3D11\D3D11Graphics.cpp:1011:            if (ps->GetCompilerOutput().Empty())
Direct3D11\D3D11Graphics.cpp:1015:                bool success = ps->Create();
Direct3D11\D3D11Graphics.cpp:1018:                    LOGERROR("Failed to compile pixel shader " + ps->GetFullName() + ":\n" + ps->GetCompilerOutput());
Direct3D11\D3D11Graphics.cpp:1026:        impl_->deviceContext_->PSSetShader((ID3D11PixelShader*)(ps ? ps->GetGPUObject() : 0), 0, 0);
Direct3D11\D3D11Graphics.cpp:1036:            shaderProgram_ = i->second_.Get();
Direct3D11\D3D11Graphics.cpp:1048:            ID3D11Buffer* vsBuffer = shaderProgram_->vsConstantBuffers_[i] ? (ID3D11Buffer*)shaderProgram_->vsConstantBuffers_[i]->
Direct3D11\D3D11Graphics.cpp:1050:            if (vsBuffer != impl_->constantBuffers_[VS][i])
Direct3D11\D3D11Graphics.cpp:1052:                impl_->constantBuffers_[VS][i] = vsBuffer;
Direct3D11\D3D11Graphics.cpp:1057:            ID3D11Buffer* psBuffer = shaderProgram_->psConstantBuffers_[i] ? (ID3D11Buffer*)shaderProgram_->psConstantBuffers_[i]->
Direct3D11\D3D11Graphics.cpp:1059:            if (psBuffer != impl_->constantBuffers_[PS][i])
Direct3D11\D3D11Graphics.cpp:1061:                impl_->constantBuffers_[PS][i] = psBuffer;
Direct3D11\D3D11Graphics.cpp:1068:            impl_->deviceContext_->VSSetConstantBuffers(0, MAX_SHADER_PARAMETER_GROUPS, &impl_->constantBuffers_[VS][0]);
Direct3D11\D3D11Graphics.cpp:1070:            impl_->deviceContext_->PSSetConstantBuffers(0, MAX_SHADER_PARAMETER_GROUPS, &impl_->constantBuffers_[PS][0]);
Direct3D11\D3D11Graphics.cpp:1077:        shaderPrecache_->StoreShaders(vertexShader_, pixelShader_);
Direct3D11\D3D11Graphics.cpp:1087:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D11\D3D11Graphics.cpp:1090:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Direct3D11\D3D11Graphics.cpp:1091:    if (!buffer->IsDirty())
Direct3D11\D3D11Graphics.cpp:1093:    buffer->SetParameter(i->second_.offset_, count * sizeof(float), data);
Direct3D11\D3D11Graphics.cpp:1099:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D11\D3D11Graphics.cpp:1102:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Direct3D11\D3D11Graphics.cpp:1103:    if (!buffer->IsDirty())
Direct3D11\D3D11Graphics.cpp:1105:    buffer->SetParameter(i->second_.offset_, sizeof(float), &value);
Direct3D11\D3D11Graphics.cpp:1111:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D11\D3D11Graphics.cpp:1114:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Direct3D11\D3D11Graphics.cpp:1115:    if (!buffer->IsDirty())
Direct3D11\D3D11Graphics.cpp:1117:    buffer->SetParameter(i->second_.offset_, sizeof(bool), &value);
Direct3D11\D3D11Graphics.cpp:1123:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D11\D3D11Graphics.cpp:1126:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Direct3D11\D3D11Graphics.cpp:1127:    if (!buffer->IsDirty())
Direct3D11\D3D11Graphics.cpp:1129:    buffer->SetParameter(i->second_.offset_, sizeof(Color), &color);
Direct3D11\D3D11Graphics.cpp:1135:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D11\D3D11Graphics.cpp:1138:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Direct3D11\D3D11Graphics.cpp:1139:    if (!buffer->IsDirty())
Direct3D11\D3D11Graphics.cpp:1141:    buffer->SetParameter(i->second_.offset_, sizeof(Vector2), &vector);
Direct3D11\D3D11Graphics.cpp:1147:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D11\D3D11Graphics.cpp:1150:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Direct3D11\D3D11Graphics.cpp:1151:    if (!buffer->IsDirty())
Direct3D11\D3D11Graphics.cpp:1153:    buffer->SetVector3ArrayParameter(i->second_.offset_, 3, &matrix);
Direct3D11\D3D11Graphics.cpp:1159:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D11\D3D11Graphics.cpp:1162:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Direct3D11\D3D11Graphics.cpp:1163:    if (!buffer->IsDirty())
Direct3D11\D3D11Graphics.cpp:1165:    buffer->SetParameter(i->second_.offset_, sizeof(Vector3), &vector);
Direct3D11\D3D11Graphics.cpp:1171:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D11\D3D11Graphics.cpp:1174:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Direct3D11\D3D11Graphics.cpp:1175:    if (!buffer->IsDirty())
Direct3D11\D3D11Graphics.cpp:1177:    buffer->SetParameter(i->second_.offset_, sizeof(Matrix4), &matrix);
Direct3D11\D3D11Graphics.cpp:1183:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D11\D3D11Graphics.cpp:1186:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Direct3D11\D3D11Graphics.cpp:1187:    if (!buffer->IsDirty())
Direct3D11\D3D11Graphics.cpp:1189:    buffer->SetParameter(i->second_.offset_, sizeof(Vector4), &vector);
Direct3D11\D3D11Graphics.cpp:1195:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D11\D3D11Graphics.cpp:1198:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Direct3D11\D3D11Graphics.cpp:1199:    if (!buffer->IsDirty())
Direct3D11\D3D11Graphics.cpp:1201:    buffer->SetParameter(i->second_.offset_, sizeof(Matrix3x4), &matrix);
Direct3D11\D3D11Graphics.cpp:1263:    return shaderProgram_ && shaderProgram_->parameters_.Find(param) != shaderProgram_->parameters_.End();
Direct3D11\D3D11Graphics.cpp:1268:    return pixelShader_ && pixelShader_->HasTextureUnit(unit);
Direct3D11\D3D11Graphics.cpp:1296:        if (renderTargets_[0] && renderTargets_[0]->GetParentTexture() == texture)
Direct3D11\D3D11Graphics.cpp:1297:            texture = texture->GetBackupTexture();
Direct3D11\D3D11Graphics.cpp:1300:    if (texture && texture->GetParametersDirty())
Direct3D11\D3D11Graphics.cpp:1302:        texture->UpdateParameters();
Direct3D11\D3D11Graphics.cpp:1319:        impl_->shaderResourceViews_[index] = texture ? (ID3D11ShaderResourceView*)texture->GetShaderResourceView() : 0;
Direct3D11\D3D11Graphics.cpp:1320:        impl_->samplers_[index] = texture ? (ID3D11SamplerState*)texture->GetSampler() : 0;
Direct3D11\D3D11Graphics.cpp:1351:            texture->SetParametersDirty();
Direct3D11\D3D11Graphics.cpp:1386:            Texture* parentTexture = renderTarget->GetParentTexture();
Direct3D11\D3D11Graphics.cpp:1391:                    SetTexture(i, textures_[i]->GetBackupTexture());
Direct3D11\D3D11Graphics.cpp:1401:        renderTarget = texture->GetRenderSurface();
Direct3D11\D3D11Graphics.cpp:1419:        depthStencil = texture->GetRenderSurface();
Direct3D11\D3D11Graphics.cpp:1444:    d3dViewport.Width = (float)(rectCopy.right_ - rectCopy.left_);
Direct3D11\D3D11Graphics.cpp:1445:    d3dViewport.Height = (float)(rectCopy.bottom_ - rectCopy.top_);
Direct3D11\D3D11Graphics.cpp:1449:    impl_->deviceContext_->RSSetViewports(1, &d3dViewport);
Direct3D11\D3D11Graphics.cpp:1453:    // Disable scissor test, needs to be re-enabled by the user
Direct3D11\D3D11Graphics.cpp:1536:        intRect.left_ = Clamp((int)((rect.min_.x_ + 1.0f) * 0.5f * viewSize.x_) + viewPos.x_, 0, rtSize.x_ - 1);
Direct3D11\D3D11Graphics.cpp:1537:        intRect.top_ = Clamp((int)((-rect.max_.y_ + 1.0f) * 0.5f * viewSize.y_) + viewPos.y_, 0, rtSize.y_ - 1);
Direct3D11\D3D11Graphics.cpp:1539:        intRect.bottom_ = Clamp((int)((-rect.min_.y_ + 1.0f) * 0.5f * viewSize.y_) + viewPos.y_ + expand, 0, rtSize.y_);
Direct3D11\D3D11Graphics.cpp:1572:        intRect.left_ = Clamp(rect.left_ + viewPos.x_, 0, rtSize.x_ - 1);
Direct3D11\D3D11Graphics.cpp:1573:        intRect.top_ = Clamp(rect.top_ + viewPos.y_, 0, rtSize.y_ - 1);
Direct3D11\D3D11Graphics.cpp:1679:    return impl_->window_ != 0 && impl_->GetDevice() != 0;
Direct3D11\D3D11Graphics.cpp:1684:    if (impl_->window_)
Direct3D11\D3D11Graphics.cpp:1724:    if (impl_->device_)
Direct3D11\D3D11Graphics.cpp:1729:            impl_->device_->CheckMultisampleQualityLevels(sRGB_ ? DXGI_FORMAT_R8G8B8A8_UNORM_SRGB : DXGI_FORMAT_R8G8B8A8_UNORM,
Direct3D11\D3D11Graphics.cpp:1779:        if (lastShaderName_ == name && !cache->Exists(fullShaderName))
Direct3D11\D3D11Graphics.cpp:1782:        lastShader_ = cache->GetResource<Shader>(fullShaderName);
Direct3D11\D3D11Graphics.cpp:1786:    return lastShader_ ? lastShader_->GetVariation(type, defines) : (ShaderVariation*)0;
Direct3D11\D3D11Graphics.cpp:1798:        return i->second_;
Direct3D11\D3D11Graphics.cpp:1807:        if (i->second_ == unit)
Direct3D11\D3D11Graphics.cpp:1808:            return i->first_;
Direct3D11\D3D11Graphics.cpp:1829:        width = renderTargets_[0]->GetWidth();
Direct3D11\D3D11Graphics.cpp:1830:        height = renderTargets_[0]->GetHeight();
Direct3D11\D3D11Graphics.cpp:1832:    else if (depthStencil_) // Depth-only rendering
Direct3D11\D3D11Graphics.cpp:1834:        width = depthStencil_->GetWidth();
Direct3D11\D3D11Graphics.cpp:1835:        height = depthStencil_->GetHeight();
Direct3D11\D3D11Graphics.cpp:1848:    if (!impl_->device_ || !impl_->window_)
Direct3D11\D3D11Graphics.cpp:1853:    SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Direct3D11\D3D11Graphics.cpp:1877:    if (!impl_->device_ || !impl_->window_ || fullscreen_)
Direct3D11\D3D11Graphics.cpp:1882:    SDL_GetWindowPosition(impl_->window_, &newX, &newY);
Direct3D11\D3D11Graphics.cpp:1901:    if (!impl_->window_)
Direct3D11\D3D11Graphics.cpp:1904:    SDL_MaximizeWindow(impl_->window_);
Direct3D11\D3D11Graphics.cpp:1909:    if (!impl_->window_)
Direct3D11\D3D11Graphics.cpp:1912:    SDL_MinimizeWindow(impl_->window_);
Direct3D11\D3D11Graphics.cpp:1940:        if (!i->reserved_ && i->size_ >= size)
Direct3D11\D3D11Graphics.cpp:1942:            i->reserved_ = true;
Direct3D11\D3D11Graphics.cpp:1943:            return i->data_.Get();
Direct3D11\D3D11Graphics.cpp:1950:        if (!i->reserved_)
Direct3D11\D3D11Graphics.cpp:1952:            i->data_ = new unsigned char[size];
Direct3D11\D3D11Graphics.cpp:1953:            i->size_ = size;
Direct3D11\D3D11Graphics.cpp:1954:            i->reserved_ = true;
Direct3D11\D3D11Graphics.cpp:1958:            return i->data_.Get();
Direct3D11\D3D11Graphics.cpp:1980:        if (i->reserved_ && i->data_.Get() == buffer)
Direct3D11\D3D11Graphics.cpp:1982:            i->reserved_ = false;
Direct3D11\D3D11Graphics.cpp:1994:        if (!i->reserved_ && i->size_ > maxScratchBufferRequest_ * 2)
Direct3D11\D3D11Graphics.cpp:1996:            i->data_ = maxScratchBufferRequest_ > 0 ? new unsigned char[maxScratchBufferRequest_] : 0;
Direct3D11\D3D11Graphics.cpp:1997:            i->size_ = maxScratchBufferRequest_;
Direct3D11\D3D11Graphics.cpp:2010:        if (i->first_.first_ == variation || i->first_.second_ == variation)
Direct3D11\D3D11Graphics.cpp:2026:        return i->second_.Get();
Direct3D11\D3D11Graphics.cpp:2030:        newConstantBuffer->SetSize(size);
Direct3D11\D3D11Graphics.cpp:2168:        impl_->window_ = SDL_CreateWindow(windowTitle_.CString(), position_.x_, position_.y_, width, height, flags);
Direct3D11\D3D11Graphics.cpp:2171:        impl_->window_ = SDL_CreateWindowFrom(externalWindow_, 0);
Direct3D11\D3D11Graphics.cpp:2173:    if (!impl_->window_)
Direct3D11\D3D11Graphics.cpp:2179:    SDL_GetWindowPosition(impl_->window_, &position_.x_, &position_.y_);
Direct3D11\D3D11Graphics.cpp:2190:        SDL_Surface* surface = windowIcon_->GetSDLSurface();
Direct3D11\D3D11Graphics.cpp:2193:            SDL_SetWindowIcon(impl_->window_, surface);
Direct3D11\D3D11Graphics.cpp:2205:            SDL_MaximizeWindow(impl_->window_);
Direct3D11\D3D11Graphics.cpp:2206:            SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Direct3D11\D3D11Graphics.cpp:2209:            SDL_SetWindowSize(impl_->window_, newWidth, newHeight);
Direct3D11\D3D11Graphics.cpp:2211:        SDL_SetWindowFullscreen(impl_->window_, newFullscreen ? SDL_TRUE : SDL_FALSE);
Direct3D11\D3D11Graphics.cpp:2212:        SDL_SetWindowBordered(impl_->window_, newBorderless ? SDL_FALSE : SDL_TRUE);
Direct3D11\D3D11Graphics.cpp:2217:        SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Direct3D11\D3D11Graphics.cpp:2225:    if (!impl_->device_)
Direct3D11\D3D11Graphics.cpp:2235:            &impl_->device_,
Direct3D11\D3D11Graphics.cpp:2237:            &impl_->deviceContext_
Direct3D11\D3D11Graphics.cpp:2240:        if (!impl_->device_ || !impl_->deviceContext_)
Direct3D11\D3D11Graphics.cpp:2257:    if (impl_->swapChain_)
Direct3D11\D3D11Graphics.cpp:2259:        impl_->swapChain_->Release();
Direct3D11\D3D11Graphics.cpp:2260:        impl_->swapChain_ = 0;
Direct3D11\D3D11Graphics.cpp:2270:    swapChainDesc.OutputWindow = GetWindowHandle(impl_->window_);
Direct3D11\D3D11Graphics.cpp:2277:    impl_->device_->QueryInterface(IID_IDXGIDevice, (void **)&dxgiDevice);
Direct3D11\D3D11Graphics.cpp:2279:    dxgiDevice->GetParent(IID_IDXGIAdapter, (void **)&dxgiAdapter);
Direct3D11\D3D11Graphics.cpp:2281:    dxgiAdapter->GetParent(IID_IDXGIFactory, (void **)&dxgiFactory);
Direct3D11\D3D11Graphics.cpp:2282:    dxgiFactory->CreateSwapChain(impl_->device_, &swapChainDesc, &impl_->swapChain_);
Direct3D11\D3D11Graphics.cpp:2283:    // After creating the swap chain, disable automatic Alt-Enter fullscreen/windowed switching
Direct3D11\D3D11Graphics.cpp:2285:    dxgiFactory->MakeWindowAssociation(GetWindowHandle(impl_->window_), DXGI_MWA_NO_ALT_ENTER);
Direct3D11\D3D11Graphics.cpp:2287:    dxgiFactory->Release();
Direct3D11\D3D11Graphics.cpp:2288:    dxgiAdapter->Release();
Direct3D11\D3D11Graphics.cpp:2289:    dxgiDevice->Release();
Direct3D11\D3D11Graphics.cpp:2291:    if (impl_->swapChain_)
Direct3D11\D3D11Graphics.cpp:2308:    impl_->deviceContext_->OMSetRenderTargets(1, &nullView, 0);
Direct3D11\D3D11Graphics.cpp:2309:    if (impl_->defaultRenderTargetView_)
Direct3D11\D3D11Graphics.cpp:2311:        impl_->defaultRenderTargetView_->Release();
Direct3D11\D3D11Graphics.cpp:2312:        impl_->defaultRenderTargetView_ = 0;
Direct3D11\D3D11Graphics.cpp:2314:    if (impl_->defaultDepthStencilView_)
Direct3D11\D3D11Graphics.cpp:2316:        impl_->defaultDepthStencilView_->Release();
Direct3D11\D3D11Graphics.cpp:2317:        impl_->defaultDepthStencilView_ = 0;
Direct3D11\D3D11Graphics.cpp:2319:    if (impl_->defaultDepthTexture_)
Direct3D11\D3D11Graphics.cpp:2321:        impl_->defaultDepthTexture_->Release();
Direct3D11\D3D11Graphics.cpp:2322:        impl_->defaultDepthTexture_ = 0;
Direct3D11\D3D11Graphics.cpp:2325:    impl_->depthStencilView_ = 0;
Direct3D11\D3D11Graphics.cpp:2327:        impl_->renderTargetViews_[i] = 0;
Direct3D11\D3D11Graphics.cpp:2330:    impl_->swapChain_->ResizeBuffers(1, width, height, DXGI_FORMAT_UNKNOWN, DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH);
Direct3D11\D3D11Graphics.cpp:2334:    impl_->swapChain_->GetBuffer(0, IID_ID3D11Texture2D, (void**)&backbufferTexture);
Direct3D11\D3D11Graphics.cpp:2337:        impl_->device_->CreateRenderTargetView(backbufferTexture, 0, &impl_->defaultRenderTargetView_);
Direct3D11\D3D11Graphics.cpp:2338:        backbufferTexture->Release();
Direct3D11\D3D11Graphics.cpp:2346:    // Create default depth-stencil texture and view
Direct3D11\D3D11Graphics.cpp:2360:    impl_->device_->CreateTexture2D(&depthDesc, 0, &impl_->defaultDepthTexture_);
Direct3D11\D3D11Graphics.cpp:2361:    if (impl_->defaultDepthTexture_)
Direct3D11\D3D11Graphics.cpp:2362:        impl_->device_->CreateDepthStencilView(impl_->defaultDepthTexture_, 0, &impl_->defaultDepthStencilView_);
Direct3D11\D3D11Graphics.cpp:2365:        LOGERROR("Failed to create backbuffer depth-stencil texture");
Direct3D11\D3D11Graphics.cpp:2396:        impl_->vertexBuffers_[i] = 0;
Direct3D11\D3D11Graphics.cpp:2397:        impl_->vertexSizes_[i] = 0;
Direct3D11\D3D11Graphics.cpp:2398:        impl_->vertexOffsets_[i] = 0;
Direct3D11\D3D11Graphics.cpp:2404:        impl_->shaderResourceViews_[i] = 0;
Direct3D11\D3D11Graphics.cpp:2405:        impl_->samplers_[i] = 0;
Direct3D11\D3D11Graphics.cpp:2411:        impl_->renderTargetViews_[i] = 0;
Direct3D11\D3D11Graphics.cpp:2416:        impl_->constantBuffers_[VS][i] = 0;
Direct3D11\D3D11Graphics.cpp:2417:        impl_->constantBuffers_[PS][i] = 0;
Direct3D11\D3D11Graphics.cpp:2421:    impl_->depthStencilView_ = 0;
Direct3D11\D3D11Graphics.cpp:2470:        impl_->depthStencilView_ = depthStencil_ ? (ID3D11DepthStencilView*)depthStencil_->GetRenderTargetView() : impl_->defaultDepthStencilView_;
Direct3D11\D3D11Graphics.cpp:2473:            impl_->renderTargetViews_[i] = renderTargets_[i] ? (ID3D11RenderTargetView*)renderTargets_[i]->GetRenderTargetView() : 0;
Direct3D11\D3D11Graphics.cpp:2474:        // If rendertarget 0 is null and not doing depth-only rendering, render to the backbuffer
Direct3D11\D3D11Graphics.cpp:2477:        if (!renderTargets_[0] && (!depthStencil_ || (depthStencil_ && depthStencil_->GetWidth() == width_ && depthStencil_->GetHeight() == height_)))
Direct3D11\D3D11Graphics.cpp:2478:            impl_->renderTargetViews_[0] = impl_->defaultRenderTargetView_;
Direct3D11\D3D11Graphics.cpp:2480:        impl_->deviceContext_->OMSetRenderTargets(MAX_RENDERTARGETS, &impl_->renderTargetViews_[0], impl_->depthStencilView_);
Direct3D11\D3D11Graphics.cpp:2487:        impl_->deviceContext_->VSSetShaderResources(firstDirtyTexture_, lastDirtyTexture_ - firstDirtyTexture_ + 1,
Direct3D11\D3D11Graphics.cpp:2488:            &impl_->shaderResourceViews_[firstDirtyTexture_]);
Direct3D11\D3D11Graphics.cpp:2489:        impl_->deviceContext_->VSSetSamplers(firstDirtyTexture_, lastDirtyTexture_ - firstDirtyTexture_ + 1,
Direct3D11\D3D11Graphics.cpp:2490:            &impl_->samplers_[firstDirtyTexture_]);
Direct3D11\D3D11Graphics.cpp:2491:        impl_->deviceContext_->PSSetShaderResources(firstDirtyTexture_, lastDirtyTexture_ - firstDirtyTexture_ + 1,
Direct3D11\D3D11Graphics.cpp:2492:            &impl_->shaderResourceViews_[firstDirtyTexture_]);
Direct3D11\D3D11Graphics.cpp:2493:        impl_->deviceContext_->PSSetSamplers(firstDirtyTexture_, lastDirtyTexture_ - firstDirtyTexture_ + 1,
Direct3D11\D3D11Graphics.cpp:2494:            &impl_->samplers_[firstDirtyTexture_]);
Direct3D11\D3D11Graphics.cpp:2500:    if (vertexDeclarationDirty_ && vertexShader_ && vertexShader_->GetByteCode().Size())
Direct3D11\D3D11Graphics.cpp:2504:            impl_->deviceContext_->IASetVertexBuffers(firstDirtyVB_, lastDirtyVB_ - firstDirtyVB_ + 1, &impl_->vertexBuffers_
Direct3D11\D3D11Graphics.cpp:2505:                [firstDirtyVB_], &impl_->vertexSizes_[firstDirtyVB_], &impl_->vertexOffsets_[firstDirtyVB_]);
Direct3D11\D3D11Graphics.cpp:2517:            newVertexDeclarationHash |= (unsigned long long)vertexShader_->GetElementMask() << 51;
Direct3D11\D3D11Graphics.cpp:2528:                impl_->deviceContext_->IASetInputLayout((ID3D11InputLayout*)i->second_->GetInputLayout());
Direct3D11\D3D11Graphics.cpp:2541:            HashMap<unsigned, ID3D11BlendState*>::Iterator i = impl_->blendStates_.Find(newBlendStateHash);
Direct3D11\D3D11Graphics.cpp:2542:            if (i == impl_->blendStates_.End())
Direct3D11\D3D11Graphics.cpp:2560:                impl_->device_->CreateBlendState(&stateDesc, &newBlendState);
Direct3D11\D3D11Graphics.cpp:2564:                i = impl_->blendStates_.Insert(MakePair(newBlendStateHash, newBlendState));
Direct3D11\D3D11Graphics.cpp:2567:            impl_->deviceContext_->OMSetBlendState(i->second_, 0, M_MAX_UNSIGNED);
Direct3D11\D3D11Graphics.cpp:2581:            HashMap<unsigned, ID3D11DepthStencilState*>::Iterator i = impl_->depthStates_.Find(newDepthStateHash);
Direct3D11\D3D11Graphics.cpp:2582:            if (i == impl_->depthStates_.End())
Direct3D11\D3D11Graphics.cpp:2604:                impl_->device_->CreateDepthStencilState(&stateDesc, &newDepthState);
Direct3D11\D3D11Graphics.cpp:2608:                i = impl_->depthStates_.Insert(MakePair(newDepthStateHash, newDepthState));
Direct3D11\D3D11Graphics.cpp:2611:            impl_->deviceContext_->OMSetDepthStencilState(i->second_, stencilRef_);
Direct3D11\D3D11Graphics.cpp:2622:        if (depthStencil_ && depthStencil_->GetParentTexture()->GetFormat() == DXGI_FORMAT_R16_TYPELESS)
Direct3D11\D3D11Graphics.cpp:2630:            HashMap<unsigned, ID3D11RasterizerState*>::Iterator i = impl_->rasterizerStates_.Find(newRasterizerStateHash);
Direct3D11\D3D11Graphics.cpp:2631:            if (i == impl_->rasterizerStates_.End())
Direct3D11\D3D11Graphics.cpp:2649:                impl_->device_->CreateRasterizerState(&stateDesc, &newRasterizerState);
Direct3D11\D3D11Graphics.cpp:2653:                i = impl_->rasterizerStates_.Insert(MakePair(newRasterizerStateHash, newRasterizerState));
Direct3D11\D3D11Graphics.cpp:2656:            impl_->deviceContext_->RSSetState(i->second_);
Direct3D11\D3D11Graphics.cpp:2670:        impl_->deviceContext_->RSSetScissorRects(1, &d3dRect);
Direct3D11\D3D11Graphics.cpp:2675:        dirtyConstantBuffers_[i]->Apply();
Direct3D11\D3D11GraphicsImpl.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11GraphicsImpl.h:35:/// %Graphics implementation. Holds API-specific objects.
Direct3D11\D3D11GraphicsImpl.h:64:    /// Default depth-stencil texture.
Direct3D11\D3D11GraphicsImpl.h:66:    /// Default depth-stencil view.
Direct3D11\D3D11GraphicsImpl.h:70:    /// Current depth-stencil view.
Direct3D11\D3D11IndexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11IndexBuffer.h:55:    /// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
Direct3D11\D3D11IndexBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11IndexBuffer.cpp:65:        if (graphics_->GetIndexBuffer() == this)
Direct3D11\D3D11IndexBuffer.cpp:66:            graphics_->SetIndexBuffer(0);
Direct3D11\D3D11IndexBuffer.cpp:68:        ((ID3D11Buffer*)object_)->Release();
Direct3D11\D3D11IndexBuffer.cpp:146:            graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Buffer*)object_, 0, &destBox, data, 0, 0);
Direct3D11\D3D11IndexBuffer.cpp:205:            graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Buffer*)object_, 0, &destBox, data, 0, 0);
Direct3D11\D3D11IndexBuffer.cpp:249:        lockScratchData_ = graphics_->ReserveScratchBuffer(count * indexSize_);
Direct3D11\D3D11IndexBuffer.cpp:272:            graphics_->FreeScratchBuffer(lockScratchData_);
Direct3D11\D3D11IndexBuffer.cpp:321:    vertexCount = maxVertex - minVertex + 1;
Direct3D11\D3D11IndexBuffer.cpp:341:        graphics_->GetImpl()->GetDevice()->CreateBuffer(&bufferDesc, 0, (ID3D11Buffer**)&object_);
Direct3D11\D3D11IndexBuffer.cpp:370:        graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Buffer*)object_, 0, discard ? D3D11_MAP_WRITE_DISCARD :
Direct3D11\D3D11IndexBuffer.cpp:386:        graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Buffer*)object_, 0);
Direct3D11\D3D11Texture.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11Texture.cpp:98:        mipsToSkip_[i] = MAX_TEXTURE_QUALITY_LEVELS - 1 - i;
Direct3D11\D3D11Texture.cpp:140:        enable &= graphics_->GetSRGBSupport();
Direct3D11\D3D11Texture.cpp:160:            if (mipsToSkip_[i] > mipsToSkip_[i - 1])
Direct3D11\D3D11Texture.cpp:161:                mipsToSkip_[i] = mipsToSkip_[i - 1];
Direct3D11\D3D11Texture.cpp:256:    XMLElement rootElem = file->GetRoot();
Direct3D11\D3D11Texture.cpp:272:                TextureCoordinate coordIndex = (TextureCoordinate)(coord[0] - 'u');
Direct3D11\D3D11Texture.cpp:322:        ((ID3D11SamplerState*)sampler_)->Release();
Direct3D11\D3D11Texture.cpp:328:    unsigned filterModeIndex = filterMode_ != FILTER_DEFAULT ? filterMode_ : graphics_->GetDefaultTextureFilterMode();
Direct3D11\D3D11Texture.cpp:335:    samplerDesc.MaxAnisotropy = graphics_->GetTextureAnisotropy();
Direct3D11\D3D11Texture.cpp:337:    samplerDesc.MinLOD = -M_INFINITY;
Direct3D11\D3D11Texture.cpp:341:    graphics_->GetImpl()->GetDevice()->CreateSamplerState(&samplerDesc, (ID3D11SamplerState**)&sampler_);
Direct3D11\D3D11Texture.cpp:424:    unsigned textureBudget = cache->GetMemoryBudget(type);
Direct3D11\D3D11Texture.cpp:425:    unsigned textureUse = cache->GetMemoryUse(type);
Direct3D11\D3D11Texture.cpp:432:        cache->ReleaseResources(Material::GetTypeStatic());
Direct3D11\D3D11RenderSurface.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11RenderSurface.h:33:/// %Color or depth-stencil surface that can be rendered into.
Direct3D11\D3D11RenderSurface.h:53:    /// Set linked depth-stencil surface.
Direct3D11\D3D11RenderSurface.h:62:    /// Return Direct3D rendertarget or depth-stencil view.
Direct3D11\D3D11RenderSurface.h:78:    /// Return linked depth-stencil surface.
Direct3D11\D3D11RenderSurface.h:87:    /// Direct3D rendertarget or depth-stencil view.
Direct3D11\D3D11ShaderProgram.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11ShaderProgram.h:41:        const unsigned* vsBufferSizes = vertexShader->GetConstantBufferSizes();
Direct3D11\D3D11ShaderProgram.h:45:                vsConstantBuffers_[i] = graphics->GetOrCreateConstantBuffer(VS, i, vsBufferSizes[i]);
Direct3D11\D3D11ShaderProgram.h:48:        const unsigned* psBufferSizes = pixelShader->GetConstantBufferSizes();
Direct3D11\D3D11ShaderProgram.h:52:                psConstantBuffers_[i] = graphics->GetOrCreateConstantBuffer(PS, i, psBufferSizes[i]);
Direct3D11\D3D11ShaderProgram.h:56:        const HashMap<StringHash, ShaderParameter>& vsParams = vertexShader->GetParameters();
Direct3D11\D3D11ShaderProgram.h:59:            parameters_[i->first_] = i->second_;
Direct3D11\D3D11ShaderProgram.h:60:            parameters_[i->first_].bufferPtr_ = vsConstantBuffers_[i->second_.buffer_].Get();
Direct3D11\D3D11ShaderProgram.h:63:        const HashMap<StringHash, ShaderParameter>& psParams = pixelShader->GetParameters();
Direct3D11\D3D11ShaderProgram.h:66:            parameters_[i->first_] = i->second_;
Direct3D11\D3D11ShaderProgram.h:67:            parameters_[i->first_].bufferPtr_ = psConstantBuffers_[i->second_.buffer_].Get();
Direct3D11\D3D11ShaderVariation.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11ShaderVariation.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11ShaderVariation.cpp:42:    GPUObject(owner->GetSubsystem<Graphics>()),
Direct3D11\D3D11ShaderVariation.cpp:71:    // Check for up-to-date bytecode on disk
Direct3D11\D3D11ShaderVariation.cpp:73:    SplitPath(owner_->GetName(), path, name, extension);
Direct3D11\D3D11ShaderVariation.cpp:84:        if (owner_->GetTimeStamp())
Direct3D11\D3D11ShaderVariation.cpp:89:    ID3D11Device* device = graphics_->GetImpl()->GetDevice();
Direct3D11\D3D11ShaderVariation.cpp:93:            device->CreateVertexShader(&byteCode_[0], byteCode_.Size(), 0, (ID3D11VertexShader**)&object_);
Direct3D11\D3D11ShaderVariation.cpp:100:            device->CreatePixelShader(&byteCode_[0], byteCode_.Size(), 0, (ID3D11PixelShader**)&object_);
Direct3D11\D3D11ShaderVariation.cpp:115:        graphics_->CleanUpShaderPrograms(this);
Direct3D11\D3D11ShaderVariation.cpp:119:            if (graphics_->GetVertexShader() == this)
Direct3D11\D3D11ShaderVariation.cpp:120:                graphics_->SetShaders(0, 0);
Direct3D11\D3D11ShaderVariation.cpp:122:            ((ID3D11VertexShader*)object_)->Release();
Direct3D11\D3D11ShaderVariation.cpp:126:            if (graphics_->GetPixelShader() == this)
Direct3D11\D3D11ShaderVariation.cpp:127:                graphics_->SetShaders(0, 0);
Direct3D11\D3D11ShaderVariation.cpp:129:            ((ID3D11PixelShader*)object_)->Release();
Direct3D11\D3D11ShaderVariation.cpp:163:    ResourceCache* cache = owner_->GetSubsystem<ResourceCache>();
Direct3D11\D3D11ShaderVariation.cpp:164:    if (!cache->Exists(binaryShaderName))
Direct3D11\D3D11ShaderVariation.cpp:167:    FileSystem* fileSystem = owner_->GetSubsystem<FileSystem>();
Direct3D11\D3D11ShaderVariation.cpp:168:    unsigned sourceTimeStamp = owner_->GetTimeStamp();
Direct3D11\D3D11ShaderVariation.cpp:171:    if (sourceTimeStamp && fileSystem->GetLastModifiedTime(cache->GetResourceFileName(binaryShaderName)) <
Direct3D11\D3D11ShaderVariation.cpp:175:    SharedPtr<File> file = cache->GetFile(binaryShaderName);
Direct3D11\D3D11ShaderVariation.cpp:176:    if (!file || file->ReadFileID() != "USHD")
Direct3D11\D3D11ShaderVariation.cpp:183:    unsigned short shaderType = file->ReadUShort();
Direct3D11\D3D11ShaderVariation.cpp:184:    unsigned short shaderModel = file->ReadUShort();
Direct3D11\D3D11ShaderVariation.cpp:185:    elementMask_ = file->ReadUInt();
Direct3D11\D3D11ShaderVariation.cpp:187:    unsigned numParameters = file->ReadUInt();
Direct3D11\D3D11ShaderVariation.cpp:190:        String name = file->ReadString();
Direct3D11\D3D11ShaderVariation.cpp:191:        unsigned buffer = file->ReadUByte();
Direct3D11\D3D11ShaderVariation.cpp:192:        unsigned offset = file->ReadUInt();
Direct3D11\D3D11ShaderVariation.cpp:193:        unsigned size = file->ReadUInt();
Direct3D11\D3D11ShaderVariation.cpp:199:    unsigned numTextureUnits = file->ReadUInt();
Direct3D11\D3D11ShaderVariation.cpp:202:        String unitName = file->ReadString();
Direct3D11\D3D11ShaderVariation.cpp:203:        unsigned reg = file->ReadUByte();
Direct3D11\D3D11ShaderVariation.cpp:209:    unsigned byteCodeSize = file->ReadUInt();
Direct3D11\D3D11ShaderVariation.cpp:213:        file->Read(&byteCode_[0], byteCodeSize);
Direct3D11\D3D11ShaderVariation.cpp:232:    const String& sourceCode = owner_->GetSourceCode(type_);
Direct3D11\D3D11ShaderVariation.cpp:296:    if (FAILED(D3DCompile(sourceCode.CString(), sourceCode.Length(), owner_->GetName().CString(), &macros.Front(), 0,
Direct3D11\D3D11ShaderVariation.cpp:298:        compilerOutput_ = String((const char*)errorMsgs->GetBufferPointer(), errorMsgs->GetBufferSize());
Direct3D11\D3D11ShaderVariation.cpp:306:        unsigned char* bufData = (unsigned char*)shaderCode->GetBufferPointer();
Direct3D11\D3D11ShaderVariation.cpp:307:        unsigned bufSize = shaderCode->GetBufferSize();
Direct3D11\D3D11ShaderVariation.cpp:316:        byteCode_.Resize(strippedCode->GetBufferSize());
Direct3D11\D3D11ShaderVariation.cpp:317:        memcpy(&byteCode_[0], strippedCode->GetBufferPointer(), byteCode_.Size());
Direct3D11\D3D11ShaderVariation.cpp:318:        strippedCode->Release();
Direct3D11\D3D11ShaderVariation.cpp:322:        shaderCode->Release();
Direct3D11\D3D11ShaderVariation.cpp:324:        errorMsgs->Release();
Direct3D11\D3D11ShaderVariation.cpp:341:    reflection->GetDesc(&shaderDesc);
Direct3D11\D3D11ShaderVariation.cpp:348:            reflection->GetInputParameterDesc((unsigned)i, &paramDesc);
Direct3D11\D3D11ShaderVariation.cpp:366:        reflection->GetResourceBindingDesc(i, &resourceDesc);
Direct3D11\D3D11ShaderVariation.cpp:376:        ID3D11ShaderReflectionConstantBuffer* cb = reflection->GetConstantBufferByIndex(i);
Direct3D11\D3D11ShaderVariation.cpp:378:        cb->GetDesc(&cbDesc);
Direct3D11\D3D11ShaderVariation.cpp:383:            ID3D11ShaderReflectionVariable* var = cb->GetVariableByIndex(j);
Direct3D11\D3D11ShaderVariation.cpp:385:            var->GetDesc(&varDesc);
Direct3D11\D3D11ShaderVariation.cpp:395:    reflection->Release();
Direct3D11\D3D11ShaderVariation.cpp:400:    ResourceCache* cache = owner_->GetSubsystem<ResourceCache>();
Direct3D11\D3D11ShaderVariation.cpp:401:    FileSystem* fileSystem = owner_->GetSubsystem<FileSystem>();
Direct3D11\D3D11ShaderVariation.cpp:403:    String path = GetPath(cache->GetResourceFileName(owner_->GetName())) + "Cache/";
Direct3D11\D3D11ShaderVariation.cpp:405:    if (!fileSystem->DirExists(path))
Direct3D11\D3D11ShaderVariation.cpp:406:        fileSystem->CreateDir(path);
Direct3D11\D3D11ShaderVariation.cpp:408:    SharedPtr<File> file(new File(owner_->GetContext(), fullName, FILE_WRITE));
Direct3D11\D3D11ShaderVariation.cpp:409:    if (!file->IsOpen())
Direct3D11\D3D11ShaderVariation.cpp:412:    file->WriteFileID("USHD");
Direct3D11\D3D11ShaderVariation.cpp:413:    file->WriteShort((unsigned short)type_);
Direct3D11\D3D11ShaderVariation.cpp:414:    file->WriteShort(4);
Direct3D11\D3D11ShaderVariation.cpp:415:    file->WriteUInt(elementMask_);
Direct3D11\D3D11ShaderVariation.cpp:417:    file->WriteUInt(parameters_.Size());
Direct3D11\D3D11ShaderVariation.cpp:420:        file->WriteString(i->second_.name_);
Direct3D11\D3D11ShaderVariation.cpp:421:        file->WriteUByte((unsigned char)i->second_.buffer_);
Direct3D11\D3D11ShaderVariation.cpp:422:        file->WriteUInt(i->second_.offset_);
Direct3D11\D3D11ShaderVariation.cpp:423:        file->WriteUInt(i->second_.size_);
Direct3D11\D3D11ShaderVariation.cpp:432:    file->WriteUInt(usedTextureUnits);
Direct3D11\D3D11ShaderVariation.cpp:437:            file->WriteString(graphics_->GetTextureUnitName((TextureUnit)i));
Direct3D11\D3D11ShaderVariation.cpp:438:            file->WriteUByte(i);
Direct3D11\D3D11ShaderVariation.cpp:442:    file->WriteUInt(byteCode_.Size());
Direct3D11\D3D11ShaderVariation.cpp:444:        file->Write(&byteCode_[0], byteCode_.Size());
Direct3D11\D3D11ShaderVariation.cpp:454:        if (i->second_.buffer_ < MAX_SHADER_PARAMETER_GROUPS)
Direct3D11\D3D11ShaderVariation.cpp:456:            unsigned oldSize = constantBufferSizes_[i->second_.buffer_];
Direct3D11\D3D11ShaderVariation.cpp:457:            unsigned paramEnd = i->second_.offset_ + i->second_.size_;
Direct3D11\D3D11ShaderVariation.cpp:459:                constantBufferSizes_[i->second_.buffer_] = paramEnd;
Direct3D11\D3D11RenderSurface.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11RenderSurface.cpp:86:        // Verify that there is at least 1 non-null viewport, as otherwise Renderer will not accept the surface and the update flag
Direct3D11\D3D11RenderSurface.cpp:99:            Renderer* renderer = parentTexture_->GetSubsystem<Renderer>();
Direct3D11\D3D11RenderSurface.cpp:101:                renderer->QueueRenderSurface(this);
Direct3D11\D3D11RenderSurface.cpp:110:    Graphics* graphics = parentTexture_->GetGraphics();
Direct3D11\D3D11RenderSurface.cpp:118:            if (graphics->GetRenderTarget(i) == this)
Direct3D11\D3D11RenderSurface.cpp:119:                graphics->ResetRenderTarget(i);
Direct3D11\D3D11RenderSurface.cpp:122:        if (graphics->GetDepthStencil() == this)
Direct3D11\D3D11RenderSurface.cpp:123:            graphics->ResetDepthStencil();
Direct3D11\D3D11RenderSurface.cpp:125:        ((ID3D11View*)renderTargetView_)->Release();
Direct3D11\D3D11RenderSurface.cpp:132:    return parentTexture_->GetWidth();
Direct3D11\D3D11RenderSurface.cpp:137:    return parentTexture_->GetHeight();
Direct3D11\D3D11RenderSurface.cpp:142:    return parentTexture_->GetUsage();
Direct3D11\D3D11Texture.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11Texture.h:127:    /// Return the depth-stencil view format corresponding to a texture format. Handles conversion of typeless depth texture formats.
Direct3D11\D3D11Texture2D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11Texture2D.h:59:    /// Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.
Direct3D11\D3D11Texture2D.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11Texture2D.cpp:52:    context->RegisterFactory<Texture2D>();
Direct3D11\D3D11Texture2D.cpp:63:    if (!loadImage_->Load(source))
Direct3D11\D3D11Texture2D.cpp:71:        loadImage_->PrecalculateLevels();
Direct3D11\D3D11Texture2D.cpp:76:    loadParameters_ = cache->GetTempResource<XMLFile>(xmlName, false);
Direct3D11\D3D11Texture2D.cpp:108:            if (graphics_->GetTexture(i) == this)
Direct3D11\D3D11Texture2D.cpp:109:                graphics_->SetTexture(i, 0);
Direct3D11\D3D11Texture2D.cpp:113:            renderSurface_->Release();
Direct3D11\D3D11Texture2D.cpp:115:        ((ID3D11Resource*)object_)->Release();
Direct3D11\D3D11Texture2D.cpp:120:            ((ID3D11ShaderResourceView*)shaderResourceView_)->Release();
Direct3D11\D3D11Texture2D.cpp:126:            ((ID3D11SamplerState*)sampler_)->Release();
Direct3D11\D3D11Texture2D.cpp:133:            renderSurface_->Release();
Direct3D11\D3D11Texture2D.cpp:222:        graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)object_, subResource, D3D11_MAP_WRITE_DISCARD, 0,
Direct3D11\D3D11Texture2D.cpp:228:            graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)object_, subResource);
Direct3D11\D3D11Texture2D.cpp:246:        graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Resource*)object_, subResource, &destBox, data,
Direct3D11\D3D11Texture2D.cpp:266:        quality = renderer->GetTextureQuality();
Direct3D11\D3D11Texture2D.cpp:268:    if (!image->IsCompressed())
Direct3D11\D3D11Texture2D.cpp:271:        unsigned components = image->GetComponents();
Direct3D11\D3D11Texture2D.cpp:274:            image = image->ConvertToRGBA();
Direct3D11\D3D11Texture2D.cpp:277:            components = image->GetComponents();
Direct3D11\D3D11Texture2D.cpp:280:        unsigned char* levelData = image->GetData();
Direct3D11\D3D11Texture2D.cpp:281:        int levelWidth = image->GetWidth();
Direct3D11\D3D11Texture2D.cpp:282:        int levelHeight = image->GetHeight();
Direct3D11\D3D11Texture2D.cpp:288:            image = image->GetNextLevel();
Direct3D11\D3D11Texture2D.cpp:289:            levelData = image->GetData();
Direct3D11\D3D11Texture2D.cpp:290:            levelWidth = image->GetWidth();
Direct3D11\D3D11Texture2D.cpp:291:            levelHeight = image->GetHeight();
Direct3D11\D3D11Texture2D.cpp:315:            if (i < levels_ - 1)
Direct3D11\D3D11Texture2D.cpp:317:                image = image->GetNextLevel();
Direct3D11\D3D11Texture2D.cpp:318:                levelData = image->GetData();
Direct3D11\D3D11Texture2D.cpp:319:                levelWidth = image->GetWidth();
Direct3D11\D3D11Texture2D.cpp:320:                levelHeight = image->GetHeight();
Direct3D11\D3D11Texture2D.cpp:326:        int width = image->GetWidth();
Direct3D11\D3D11Texture2D.cpp:327:        int height = image->GetHeight();
Direct3D11\D3D11Texture2D.cpp:328:        unsigned levels = image->GetNumCompressedLevels();
Direct3D11\D3D11Texture2D.cpp:329:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Direct3D11\D3D11Texture2D.cpp:340:            mipsToSkip = levels - 1;
Direct3D11\D3D11Texture2D.cpp:342:            --mipsToSkip;
Direct3D11\D3D11Texture2D.cpp:346:        SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Direct3D11\D3D11Texture2D.cpp:349:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Direct3D11\D3D11Texture2D.cpp:351:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Direct3D11\D3D11Texture2D.cpp:408:    graphics_->GetImpl()->GetDevice()->CreateTexture2D(&textureDesc, 0, &stagingTexture);
Direct3D11\D3D11Texture2D.cpp:423:    graphics_->GetImpl()->GetDeviceContext()->CopySubresourceRegion(stagingTexture, 0, 0, 0, 0, (ID3D11Resource*)object_,
Direct3D11\D3D11Texture2D.cpp:431:    graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)stagingTexture, 0, D3D11_MAP_READ, 0, &mappedData);
Direct3D11\D3D11Texture2D.cpp:436:        graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)stagingTexture, 0);
Direct3D11\D3D11Texture2D.cpp:437:        stagingTexture->Release();
Direct3D11\D3D11Texture2D.cpp:443:        stagingTexture->Release();
Direct3D11\D3D11Texture2D.cpp:474:    graphics_->GetImpl()->GetDevice()->CreateTexture2D(&textureDesc, 0, (ID3D11Texture2D**)&object_);
Direct3D11\D3D11Texture2D.cpp:487:    graphics_->GetImpl()->GetDevice()->CreateShaderResourceView((ID3D11Resource*)object_, &resourceViewDesc,
Direct3D11\D3D11Texture2D.cpp:504:        graphics_->GetImpl()->GetDevice()->CreateRenderTargetView((ID3D11Resource*)object_, &renderTargetViewDesc,
Direct3D11\D3D11Texture2D.cpp:505:            (ID3D11RenderTargetView**)&renderSurface_->renderTargetView_);
Direct3D11\D3D11Texture2D.cpp:507:        if (!renderSurface_->renderTargetView_)
Direct3D11\D3D11Texture2D.cpp:522:        graphics_->GetImpl()->GetDevice()->CreateDepthStencilView((ID3D11Resource*)object_, &depthStencilViewDesc,
Direct3D11\D3D11Texture2D.cpp:523:            (ID3D11DepthStencilView**)&renderSurface_->renderTargetView_);
Direct3D11\D3D11Texture2D.cpp:525:        if (!renderSurface_->renderTargetView_)
Direct3D11\D3D11Texture2D.cpp:527:            LOGERROR("Failed to create depth-stencil view for texture");
Direct3D11\D3D11Texture2D.cpp:537:    if (renderSurface_ && renderSurface_->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Direct3D11\D3D11Texture2D.cpp:538:        renderSurface_->QueueUpdate();
Direct3D11\D3D11Texture3D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11Texture3D.h:58:    /// Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.
Direct3D11\D3D11Texture3D.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11Texture3D.cpp:52:    context->RegisterFactory<Texture3D>();
Direct3D11\D3D11Texture3D.cpp:66:    cache->ResetDependencies(this);
Direct3D11\D3D11Texture3D.cpp:69:    if (!loadParameters_->Load(source))
Direct3D11\D3D11Texture3D.cpp:75:    XMLElement textureElem = loadParameters_->GetRoot();
Direct3D11\D3D11Texture3D.cpp:89:        loadImage_ = cache->GetTempResource<Image>(name);
Direct3D11\D3D11Texture3D.cpp:92:            loadImage_->PrecalculateLevels();
Direct3D11\D3D11Texture3D.cpp:93:        cache->StoreResourceDependency(this, name);
Direct3D11\D3D11Texture3D.cpp:106:        SharedPtr<File> file = GetSubsystem<ResourceCache>()->GetFile(name);
Direct3D11\D3D11Texture3D.cpp:108:        if (!loadImage_->LoadColorLUT(*(file.Get())))
Direct3D11\D3D11Texture3D.cpp:116:            loadImage_->PrecalculateLevels();
Direct3D11\D3D11Texture3D.cpp:117:        cache->StoreResourceDependency(this, name);
Direct3D11\D3D11Texture3D.cpp:152:            if (graphics_->GetTexture(i) == this)
Direct3D11\D3D11Texture3D.cpp:153:                graphics_->SetTexture(i, 0);
Direct3D11\D3D11Texture3D.cpp:157:            renderSurface_->Release();
Direct3D11\D3D11Texture3D.cpp:159:        ((ID3D11Resource*)object_)->Release();
Direct3D11\D3D11Texture3D.cpp:164:            ((ID3D11ShaderResourceView*)shaderResourceView_)->Release();
Direct3D11\D3D11Texture3D.cpp:170:            ((ID3D11SamplerState*)sampler_)->Release();
Direct3D11\D3D11Texture3D.cpp:177:            renderSurface_->Release();
Direct3D11\D3D11Texture3D.cpp:269:        graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)object_, subResource, D3D11_MAP_WRITE_DISCARD, 0,
Direct3D11\D3D11Texture3D.cpp:282:            graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)object_, subResource);
Direct3D11\D3D11Texture3D.cpp:303:        graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Resource*)object_, subResource, &destBox, data,
Direct3D11\D3D11Texture3D.cpp:323:        quality = renderer->GetTextureQuality();
Direct3D11\D3D11Texture3D.cpp:325:    if (!image->IsCompressed())
Direct3D11\D3D11Texture3D.cpp:328:        unsigned components = image->GetComponents();
Direct3D11\D3D11Texture3D.cpp:331:            image = image->ConvertToRGBA();
Direct3D11\D3D11Texture3D.cpp:334:            components = image->GetComponents();
Direct3D11\D3D11Texture3D.cpp:337:        unsigned char* levelData = image->GetData();
Direct3D11\D3D11Texture3D.cpp:338:        int levelWidth = image->GetWidth();
Direct3D11\D3D11Texture3D.cpp:339:        int levelHeight = image->GetHeight();
Direct3D11\D3D11Texture3D.cpp:340:        int levelDepth = image->GetDepth();
Direct3D11\D3D11Texture3D.cpp:346:            image = image->GetNextLevel();
Direct3D11\D3D11Texture3D.cpp:347:            levelData = image->GetData();
Direct3D11\D3D11Texture3D.cpp:348:            levelWidth = image->GetWidth();
Direct3D11\D3D11Texture3D.cpp:349:            levelHeight = image->GetHeight();
Direct3D11\D3D11Texture3D.cpp:350:            levelDepth = image->GetDepth();
Direct3D11\D3D11Texture3D.cpp:374:            if (i < levels_ - 1)
Direct3D11\D3D11Texture3D.cpp:376:                image = image->GetNextLevel();
Direct3D11\D3D11Texture3D.cpp:377:                levelData = image->GetData();
Direct3D11\D3D11Texture3D.cpp:378:                levelWidth = image->GetWidth();
Direct3D11\D3D11Texture3D.cpp:379:                levelHeight = image->GetHeight();
Direct3D11\D3D11Texture3D.cpp:380:                levelDepth = image->GetDepth();
Direct3D11\D3D11Texture3D.cpp:386:        int width = image->GetWidth();
Direct3D11\D3D11Texture3D.cpp:387:        int height = image->GetHeight();
Direct3D11\D3D11Texture3D.cpp:388:        int depth = image->GetDepth();
Direct3D11\D3D11Texture3D.cpp:389:        unsigned levels = image->GetNumCompressedLevels();
Direct3D11\D3D11Texture3D.cpp:390:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Direct3D11\D3D11Texture3D.cpp:401:            mipsToSkip = levels - 1;
Direct3D11\D3D11Texture3D.cpp:403:            --mipsToSkip;
Direct3D11\D3D11Texture3D.cpp:408:        SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Direct3D11\D3D11Texture3D.cpp:411:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Direct3D11\D3D11Texture3D.cpp:413:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Direct3D11\D3D11Texture3D.cpp:469:    graphics_->GetImpl()->GetDevice()->CreateTexture3D(&textureDesc, 0, &stagingTexture);
Direct3D11\D3D11Texture3D.cpp:484:    graphics_->GetImpl()->GetDeviceContext()->CopySubresourceRegion(stagingTexture, 0, 0, 0, 0, (ID3D11Resource*)object_,
Direct3D11\D3D11Texture3D.cpp:492:    graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)stagingTexture, 0, D3D11_MAP_READ, 0, &mappedData);
Direct3D11\D3D11Texture3D.cpp:503:        graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)stagingTexture, 0);
Direct3D11\D3D11Texture3D.cpp:504:        stagingTexture->Release();
Direct3D11\D3D11Texture3D.cpp:510:        stagingTexture->Release();
Direct3D11\D3D11Texture3D.cpp:535:    graphics_->GetImpl()->GetDevice()->CreateTexture3D(&textureDesc, 0, (ID3D11Texture3D**)&object_);
Direct3D11\D3D11Texture3D.cpp:548:    graphics_->GetImpl()->GetDevice()->CreateShaderResourceView((ID3D11Resource*)object_, &resourceViewDesc,
Direct3D11\D3D11Texture3D.cpp:561:    if (renderSurface_ && renderSurface_->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Direct3D11\D3D11Texture3D.cpp:562:        renderSurface_->QueueUpdate();
Direct3D11\D3D11TextureCube.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11TextureCube.h:61:    /// Set data of one face from an image. Return true if successful. Optionally make a single channel image alpha-only.
Direct3D11\D3D11TextureCube.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11TextureCube.cpp:55:    return SharedPtr<Image>(src->GetSubimage(IntRect(tileX * tileWidth, tileY * tileHeight, (tileX + 1) * tileWidth, (tileY + 1) * tileHeight)));
Direct3D11\D3D11TextureCube.cpp:60:    lockedLevel_(-1)
Direct3D11\D3D11TextureCube.cpp:78:    context->RegisterFactory<TextureCube>();
Direct3D11\D3D11TextureCube.cpp:89:    cache->ResetDependencies(this);
Direct3D11\D3D11TextureCube.cpp:95:    if (!loadParameters_->Load(source))
Direct3D11\D3D11TextureCube.cpp:103:    XMLElement textureElem = loadParameters_->GetRoot();
Direct3D11\D3D11TextureCube.cpp:114:        SharedPtr<Image> image = cache->GetTempResource<Image>(name);
Direct3D11\D3D11TextureCube.cpp:124:            faceWidth = image->GetWidth() / MAX_CUBEMAP_FACES;
Direct3D11\D3D11TextureCube.cpp:125:            faceHeight = image->GetHeight();
Direct3D11\D3D11TextureCube.cpp:135:            faceWidth = image->GetWidth() / MAX_CUBEMAP_FACES;
Direct3D11\D3D11TextureCube.cpp:136:            faceHeight = image->GetHeight();
Direct3D11\D3D11TextureCube.cpp:142:            faceWidth = image->GetWidth() / 4;
Direct3D11\D3D11TextureCube.cpp:143:            faceHeight = image->GetHeight() / 3;
Direct3D11\D3D11TextureCube.cpp:153:            faceWidth = image->GetWidth() / 3;
Direct3D11\D3D11TextureCube.cpp:154:            faceHeight = image->GetHeight() / 4;
Direct3D11\D3D11TextureCube.cpp:163:                loadImages_[FACE_NEGATIVE_Z]->FlipVertical();
Direct3D11\D3D11TextureCube.cpp:164:                loadImages_[FACE_NEGATIVE_Z]->FlipHorizontal();
Direct3D11\D3D11TextureCube.cpp:169:            faceWidth = image->GetWidth() / 3;
Direct3D11\D3D11TextureCube.cpp:170:            faceHeight = image->GetHeight() / 2;
Direct3D11\D3D11TextureCube.cpp:192:            loadImages_.Push(cache->GetTempResource<Image>(name));
Direct3D11\D3D11TextureCube.cpp:193:            cache->StoreResourceDependency(this, name);
Direct3D11\D3D11TextureCube.cpp:205:                loadImages_[i]->PrecalculateLevels();
Direct3D11\D3D11TextureCube.cpp:241:            if (graphics_->GetTexture(i) == this)
Direct3D11\D3D11TextureCube.cpp:242:                graphics_->SetTexture(i, 0);
Direct3D11\D3D11TextureCube.cpp:248:                renderSurfaces_[i]->Release();
Direct3D11\D3D11TextureCube.cpp:251:        ((ID3D11Resource*)object_)->Release();
Direct3D11\D3D11TextureCube.cpp:256:            ((ID3D11ShaderResourceView*)shaderResourceView_)->Release();
Direct3D11\D3D11TextureCube.cpp:262:            ((ID3D11SamplerState*)sampler_)->Release();
Direct3D11\D3D11TextureCube.cpp:277:        LOGERROR("Depth-stencil usage not supported for cube maps");
Direct3D11\D3D11TextureCube.cpp:368:        graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)object_, subResource, D3D11_MAP_WRITE_DISCARD, 0,
Direct3D11\D3D11TextureCube.cpp:374:            graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)object_, subResource);
Direct3D11\D3D11TextureCube.cpp:392:        graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Resource*)object_, subResource, &destBox, data,
Direct3D11\D3D11TextureCube.cpp:402:    if (!image->Load(source))
Direct3D11\D3D11TextureCube.cpp:421:        quality = renderer->GetTextureQuality();
Direct3D11\D3D11TextureCube.cpp:423:    if (!image->IsCompressed())
Direct3D11\D3D11TextureCube.cpp:426:        unsigned components = image->GetComponents();
Direct3D11\D3D11TextureCube.cpp:429:            image = image->ConvertToRGBA();
Direct3D11\D3D11TextureCube.cpp:432:            components = image->GetComponents();
Direct3D11\D3D11TextureCube.cpp:435:        unsigned char* levelData = image->GetData();
Direct3D11\D3D11TextureCube.cpp:436:        int levelWidth = image->GetWidth();
Direct3D11\D3D11TextureCube.cpp:437:        int levelHeight = image->GetHeight();
Direct3D11\D3D11TextureCube.cpp:449:            image = image->GetNextLevel();
Direct3D11\D3D11TextureCube.cpp:450:            levelData = image->GetData();
Direct3D11\D3D11TextureCube.cpp:451:            levelWidth = image->GetWidth();
Direct3D11\D3D11TextureCube.cpp:452:            levelHeight = image->GetHeight();
Direct3D11\D3D11TextureCube.cpp:493:            if (i < levels_ - 1)
Direct3D11\D3D11TextureCube.cpp:495:                image = image->GetNextLevel();
Direct3D11\D3D11TextureCube.cpp:496:                levelData = image->GetData();
Direct3D11\D3D11TextureCube.cpp:497:                levelWidth = image->GetWidth();
Direct3D11\D3D11TextureCube.cpp:498:                levelHeight = image->GetHeight();
Direct3D11\D3D11TextureCube.cpp:504:        int width = image->GetWidth();
Direct3D11\D3D11TextureCube.cpp:505:        int height = image->GetHeight();
Direct3D11\D3D11TextureCube.cpp:506:        unsigned levels = image->GetNumCompressedLevels();
Direct3D11\D3D11TextureCube.cpp:507:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Direct3D11\D3D11TextureCube.cpp:524:            mipsToSkip = levels - 1;
Direct3D11\D3D11TextureCube.cpp:526:            --mipsToSkip;
Direct3D11\D3D11TextureCube.cpp:533:            SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Direct3D11\D3D11TextureCube.cpp:550:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Direct3D11\D3D11TextureCube.cpp:552:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Direct3D11\D3D11TextureCube.cpp:614:    graphics_->GetImpl()->GetDevice()->CreateTexture2D(&textureDesc, 0, &stagingTexture);
Direct3D11\D3D11TextureCube.cpp:629:    graphics_->GetImpl()->GetDeviceContext()->CopySubresourceRegion(stagingTexture, 0, 0, 0, 0, (ID3D11Resource*)object_,
Direct3D11\D3D11TextureCube.cpp:637:    graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)stagingTexture, 0, D3D11_MAP_READ, 0, &mappedData);
Direct3D11\D3D11TextureCube.cpp:642:        graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)stagingTexture, 0);
Direct3D11\D3D11TextureCube.cpp:643:        stagingTexture->Release();
Direct3D11\D3D11TextureCube.cpp:649:        stagingTexture->Release();
Direct3D11\D3D11TextureCube.cpp:681:    graphics_->GetImpl()->GetDevice()->CreateTexture2D(&textureDesc, 0, (ID3D11Texture2D**)&object_);
Direct3D11\D3D11TextureCube.cpp:694:    graphics_->GetImpl()->GetDevice()->CreateShaderResourceView((ID3D11Resource*)object_, &resourceViewDesc,
Direct3D11\D3D11TextureCube.cpp:716:            graphics_->GetImpl()->GetDevice()->CreateRenderTargetView((ID3D11Resource*)object_, &renderTargetViewDesc,
Direct3D11\D3D11TextureCube.cpp:717:                (ID3D11RenderTargetView**)&renderSurfaces_[i]->renderTargetView_);
Direct3D11\D3D11TextureCube.cpp:719:            if (!renderSurfaces_[i]->renderTargetView_)
Direct3D11\D3D11TextureCube.cpp:734:        if (renderSurfaces_[i] && renderSurfaces_[i]->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Direct3D11\D3D11TextureCube.cpp:735:            renderSurfaces_[i]->QueueUpdate();
Direct3D11\D3D11VertexBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11VertexBuffer.cpp:136:            if (graphics_->GetVertexBuffer(i) == this)
Direct3D11\D3D11VertexBuffer.cpp:137:                graphics_->SetVertexBuffer(0);
Direct3D11\D3D11VertexBuffer.cpp:140:        ((ID3D11Buffer*)object_)->Release();
Direct3D11\D3D11VertexBuffer.cpp:220:            graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Buffer*)object_, 0, &destBox, data, 0, 0);
Direct3D11\D3D11VertexBuffer.cpp:279:            graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Buffer*)object_, 0, &destBox, data, 0, 0);
Direct3D11\D3D11VertexBuffer.cpp:323:        lockScratchData_ = graphics_->ReserveScratchBuffer(count * vertexSize_);
Direct3D11\D3D11VertexBuffer.cpp:346:            graphics_->FreeScratchBuffer(lockScratchData_);
Direct3D11\D3D11VertexBuffer.cpp:429:        graphics_->GetImpl()->GetDevice()->CreateBuffer(&bufferDesc, 0, (ID3D11Buffer**)&object_);
Direct3D11\D3D11VertexBuffer.cpp:458:        graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Buffer*)object_, 0, discard ? D3D11_MAP_WRITE_DISCARD :
Direct3D11\D3D11VertexBuffer.cpp:474:        graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Buffer*)object_, 0);
Direct3D11\D3D11VertexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11VertexBuffer.h:54:    /// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
Direct3D11\D3D11VertexDeclaration.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D11\D3D11VertexDeclaration.cpp:55:                    newDesc.AlignedByteOffset = vertexBuffers[i]->GetElementOffset((VertexElement)j);
Direct3D11\D3D11VertexDeclaration.cpp:70:    const PODVector<unsigned char>& byteCode = vertexShader->GetByteCode();
Direct3D11\D3D11VertexDeclaration.cpp:72:    graphics->GetImpl()->GetDevice()->CreateInputLayout(&elementDescs[0], (unsigned)elementDescs.Size(), &byteCode[0],
Direct3D11\D3D11VertexDeclaration.cpp:78:            vertexShader->GetFullName().CString(), vertexShader->GetElementMask() & ~vbElementMask);
Direct3D11\D3D11VertexDeclaration.cpp:85:        ((ID3D11InputLayout*)inputLayout_)->Release();
Direct3D11\D3D11VertexDeclaration.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9GPUObject.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9GPUObject.cpp:39:        graphics->AddGPUObject(this);
Direct3D9\D3D9GPUObject.cpp:45:        graphics_->RemoveGPUObject(this);
Direct3D9\D3D9GPUObject.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9Graphics.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9Graphics.h:60:/// CPU-side scratch buffer for vertex data updates.
Direct3D9\D3D9Graphics.h:106:    /// Set allowed screen orientations as a space-separated list of "LandscapeLeft", "LandscapeRight", "Portrait" and "PortraitUpsideDown". Affects currently only iOS platform.
Direct3D9\D3D9Graphics.h:122:    /// Draw non-indexed geometry.
Direct3D9\D3D9Graphics.h:178:    /// Reset all rendertargets, depth-stencil surface and viewport.
Direct3D9\D3D9Graphics.h:182:    /// Reset depth-stencil surface.
Direct3D9\D3D9Graphics.h:188:    /// Set depth-stencil surface.
Direct3D9\D3D9Graphics.h:190:    /// Set depth-stencil surface.
Direct3D9\D3D9Graphics.h:225:    /// Return graphics implementation, which holds the actual API-specific resources.
Direct3D9\D3D9Graphics.h:227:    /// Return OS-specific external window handle. Null if not in use.
Direct3D9\D3D9Graphics.h:267:    /// Return 24-bit shadow map depth texture format, or 0 if not supported.
Direct3D9\D3D9Graphics.h:271:    /// Return whether light pre-pass rendering is supported.
Direct3D9\D3D9Graphics.h:313:    /// Return current depth-stencil surface.
Direct3D9\D3D9Graphics.h:372:    /// Reserve a CPU-side scratch buffer.
Direct3D9\D3D9Graphics.h:374:    /// Free a CPU-side scratch buffer.
Direct3D9\D3D9Graphics.h:381:    /// Return the API-specific alpha texture format.
Direct3D9\D3D9Graphics.h:383:    /// Return the API-specific luminance texture format.
Direct3D9\D3D9Graphics.h:385:    /// Return the API-specific luminance alpha texture format.
Direct3D9\D3D9Graphics.h:387:    /// Return the API-specific RGB texture format.
Direct3D9\D3D9Graphics.h:389:    /// Return the API-specific RGBA texture format.
Direct3D9\D3D9Graphics.h:391:    /// Return the API-specific RGBA 16-bit texture format.
Direct3D9\D3D9Graphics.h:393:    /// Return the API-specific RGBA 16-bit float texture format.
Direct3D9\D3D9Graphics.h:395:    /// Return the API-specific RGBA 32-bit float texture format.
Direct3D9\D3D9Graphics.h:397:    /// Return the API-specific RG 16-bit texture format.
Direct3D9\D3D9Graphics.h:399:    /// Return the API-specific RG 16-bit float texture format.
Direct3D9\D3D9Graphics.h:401:    /// Return the API-specific RG 32-bit float texture format.
Direct3D9\D3D9Graphics.h:403:    /// Return the API-specific single channel 16-bit float texture format.
Direct3D9\D3D9Graphics.h:405:    /// Return the API-specific single channel 32-bit float texture format.
Direct3D9\D3D9Graphics.h:407:    /// Return the API-specific linear depth texture format.
Direct3D9\D3D9Graphics.h:409:    /// Return the API-specific hardware depth-stencil texture format.
Direct3D9\D3D9Graphics.h:411:    /// Return the API-specific readable hardware depth format, or 0 if not supported.
Direct3D9\D3D9Graphics.h:413:    /// Return the API-specific texture format from a textual description, for example "rgb".
Direct3D9\D3D9Graphics.h:484:    /// Light pre-pass rendering support flag.
Direct3D9\D3D9Graphics.h:512:    /// Shadow map 24-bit depth texture format.
Direct3D9\D3D9Graphics.h:534:    /// Depth-stencil surface in use.
Direct3D9\D3D9GraphicsImpl.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9GraphicsImpl.h:33:/// %Graphics implementation. Holds API-specific objects.
Direct3D9\D3D9GraphicsImpl.h:62:    /// Default depth-stencil surface.
Direct3D9\D3D9GraphicsImpl.h:94:    /// Depth-stencil surface in use.
Direct3D9\D3D9GraphicsImpl.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9GraphicsImpl.cpp:50:    if (SUCCEEDED(interface_->CheckDeviceFormat(
Direct3D9\D3D9IndexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9IndexBuffer.h:59:    /// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
Direct3D9\D3D9RenderSurface.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9RenderSurface.cpp:86:        // Verify that there is at least 1 non-null viewport, as otherwise Renderer will not accept the surface and the update flag
Direct3D9\D3D9RenderSurface.cpp:99:            Renderer* renderer = parentTexture_->GetSubsystem<Renderer>();
Direct3D9\D3D9RenderSurface.cpp:101:                renderer->QueueRenderSurface(this);
Direct3D9\D3D9RenderSurface.cpp:110:    Graphics* graphics = parentTexture_->GetGraphics();
Direct3D9\D3D9RenderSurface.cpp:118:            if (graphics->GetRenderTarget(i) == this)
Direct3D9\D3D9RenderSurface.cpp:119:                graphics->ResetRenderTarget(i);
Direct3D9\D3D9RenderSurface.cpp:122:        if (graphics->GetDepthStencil() == this)
Direct3D9\D3D9RenderSurface.cpp:123:            graphics->ResetDepthStencil();
Direct3D9\D3D9RenderSurface.cpp:125:        ((IDirect3DSurface9*)surface_)->Release();
Direct3D9\D3D9RenderSurface.cpp:132:    return parentTexture_->GetWidth();
Direct3D9\D3D9RenderSurface.cpp:137:    return parentTexture_->GetHeight();
Direct3D9\D3D9RenderSurface.cpp:142:    return parentTexture_->GetUsage();
Direct3D9\D3D9IndexBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9IndexBuffer.cpp:85:        if (graphics_->GetIndexBuffer() == this)
Direct3D9\D3D9IndexBuffer.cpp:86:            graphics_->SetIndexBuffer(0);
Direct3D9\D3D9IndexBuffer.cpp:88:        ((IDirect3DIndexBuffer9*)object_)->Release();
Direct3D9\D3D9IndexBuffer.cpp:155:        if (graphics_->IsDeviceLost())
Direct3D9\D3D9IndexBuffer.cpp:207:        if (graphics_->IsDeviceLost())
Direct3D9\D3D9IndexBuffer.cpp:254:    if (object_ && !shadowData_ && !graphics_->IsDeviceLost())
Direct3D9\D3D9IndexBuffer.cpp:264:        lockScratchData_ = graphics_->ReserveScratchBuffer(count * indexSize_);
Direct3D9\D3D9IndexBuffer.cpp:287:            graphics_->FreeScratchBuffer(lockScratchData_);
Direct3D9\D3D9IndexBuffer.cpp:341:    vertexCount = maxVertex - minVertex + 1;
Direct3D9\D3D9IndexBuffer.cpp:354:        if (graphics_->IsDeviceLost())
Direct3D9\D3D9IndexBuffer.cpp:360:        IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Direct3D9\D3D9IndexBuffer.cpp:361:        if (!device || FAILED(device->CreateIndexBuffer(
Direct3D9\D3D9IndexBuffer.cpp:396:        if (FAILED(((IDirect3DIndexBuffer9*)object_)->Lock(start * indexSize_, count * indexSize_, &hwData, flags)))
Direct3D9\D3D9IndexBuffer.cpp:409:        ((IDirect3DIndexBuffer9*)object_)->Unlock();
Direct3D9\D3D9Graphics.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9Graphics.cpp:220:        primitiveCount = elementCount - 2;
Direct3D9\D3D9Graphics.cpp:225:        primitiveCount = elementCount - 1;
Direct3D9\D3D9Graphics.cpp:230:        primitiveCount = elementCount - 2;
Direct3D9\D3D9Graphics.cpp:284:    // Initialize SDL now. Graphics should be the first SDL-using subsystem to be created
Direct3D9\D3D9Graphics.cpp:298:            (*i)->Release();
Direct3D9\D3D9Graphics.cpp:304:    if (impl_->defaultColorSurface_)
Direct3D9\D3D9Graphics.cpp:306:        impl_->defaultColorSurface_->Release();
Direct3D9\D3D9Graphics.cpp:307:        impl_->defaultColorSurface_ = 0;
Direct3D9\D3D9Graphics.cpp:309:    if (impl_->defaultDepthStencilSurface_)
Direct3D9\D3D9Graphics.cpp:311:        impl_->defaultDepthStencilSurface_->Release();
Direct3D9\D3D9Graphics.cpp:312:        impl_->defaultDepthStencilSurface_ = 0;
Direct3D9\D3D9Graphics.cpp:314:    if (impl_->frameQuery_)
Direct3D9\D3D9Graphics.cpp:316:        impl_->frameQuery_->Release();
Direct3D9\D3D9Graphics.cpp:317:        impl_->frameQuery_ = 0;
Direct3D9\D3D9Graphics.cpp:319:    if (impl_->device_)
Direct3D9\D3D9Graphics.cpp:321:        impl_->device_->Release();
Direct3D9\D3D9Graphics.cpp:322:        impl_->device_ = 0;
Direct3D9\D3D9Graphics.cpp:324:    if (impl_->interface_)
Direct3D9\D3D9Graphics.cpp:326:        impl_->interface_->Release();
Direct3D9\D3D9Graphics.cpp:327:        impl_->interface_ = 0;
Direct3D9\D3D9Graphics.cpp:329:    if (impl_->window_)
Direct3D9\D3D9Graphics.cpp:332:        SDL_DestroyWindow(impl_->window_);
Direct3D9\D3D9Graphics.cpp:333:        impl_->window_ = 0;
Direct3D9\D3D9Graphics.cpp:339:    // Shut down SDL now. Graphics should be the last SDL-using subsystem to be destroyed
Direct3D9\D3D9Graphics.cpp:345:    if (!impl_->window_)
Direct3D9\D3D9Graphics.cpp:354:    if (impl_->window_)
Direct3D9\D3D9Graphics.cpp:355:        SDL_SetWindowTitle(impl_->window_, windowTitle_.CString());
Direct3D9\D3D9Graphics.cpp:361:    if (impl_->window_)
Direct3D9\D3D9Graphics.cpp:367:    if (impl_->window_)
Direct3D9\D3D9Graphics.cpp:368:        SDL_SetWindowPosition(impl_->window_, position.x_, position.y_);
Direct3D9\D3D9Graphics.cpp:422:    if (!impl_->window_)
Direct3D9\D3D9Graphics.cpp:428:    if (!impl_->interface_)
Direct3D9\D3D9Graphics.cpp:452:                unsigned error = Abs(resolutions[i].x_ - width) + Abs(resolutions[i].y_ - height);
Direct3D9\D3D9Graphics.cpp:465:    // Fall back to non-multisampled if unsupported multisampling mode
Direct3D9\D3D9Graphics.cpp:468:        if (FAILED(impl_->interface_->CheckDeviceMultiSampleType(impl_->adapter_, impl_->deviceType_, fullscreenFormat, FALSE,
Direct3D9\D3D9Graphics.cpp:478:        SDL_GetWindowSize(impl_->window_, &width, &height);
Direct3D9\D3D9Graphics.cpp:483:        impl_->presentParams_.BackBufferFormat = fullscreenFormat;
Direct3D9\D3D9Graphics.cpp:484:        impl_->presentParams_.Windowed         = false;
Direct3D9\D3D9Graphics.cpp:488:        impl_->presentParams_.BackBufferFormat = D3DFMT_UNKNOWN;
Direct3D9\D3D9Graphics.cpp:489:        impl_->presentParams_.Windowed         = true;
Direct3D9\D3D9Graphics.cpp:492:    impl_->presentParams_.BackBufferWidth            = width;
Direct3D9\D3D9Graphics.cpp:493:    impl_->presentParams_.BackBufferHeight           = height;
Direct3D9\D3D9Graphics.cpp:494:    impl_->presentParams_.BackBufferCount            = tripleBuffer ? 2 : 1;
Direct3D9\D3D9Graphics.cpp:495:    impl_->presentParams_.MultiSampleType            = multiSample > 1 ? (D3DMULTISAMPLE_TYPE)multiSample : D3DMULTISAMPLE_NONE;
Direct3D9\D3D9Graphics.cpp:496:    impl_->presentParams_.MultiSampleQuality         = 0;
Direct3D9\D3D9Graphics.cpp:497:    impl_->presentParams_.SwapEffect                 = D3DSWAPEFFECT_DISCARD;
Direct3D9\D3D9Graphics.cpp:498:    impl_->presentParams_.hDeviceWindow              = GetWindowHandle(impl_->window_);
Direct3D9\D3D9Graphics.cpp:499:    impl_->presentParams_.EnableAutoDepthStencil     = TRUE;
Direct3D9\D3D9Graphics.cpp:500:    impl_->presentParams_.AutoDepthStencilFormat     = D3DFMT_D24S8;
Direct3D9\D3D9Graphics.cpp:501:    impl_->presentParams_.Flags                      = D3DPRESENT_LINEAR_CONTENT;
Direct3D9\D3D9Graphics.cpp:502:    impl_->presentParams_.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
Direct3D9\D3D9Graphics.cpp:505:        impl_->presentParams_.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
Direct3D9\D3D9Graphics.cpp:507:        impl_->presentParams_.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
Direct3D9\D3D9Graphics.cpp:517:    if (!impl_->device_)
Direct3D9\D3D9Graphics.cpp:523:        for (unsigned i=0; i < impl_->interface_->GetAdapterCount(); ++i)
Direct3D9\D3D9Graphics.cpp:526:            impl_->interface_->GetAdapterIdentifier(i, 0, &identifier);
Direct3D9\D3D9Graphics.cpp:535:        impl_->interface_->GetAdapterIdentifier(adapter, 0, &impl_->adapterIdentifier_);
Direct3D9\D3D9Graphics.cpp:543:    impl_->device_->BeginScene();
Direct3D9\D3D9Graphics.cpp:545:    impl_->device_->EndScene();
Direct3D9\D3D9Graphics.cpp:546:    impl_->device_->Present(0, 0, 0, 0);
Direct3D9\D3D9Graphics.cpp:601:    if (impl_->window_)
Direct3D9\D3D9Graphics.cpp:604:        SDL_DestroyWindow(impl_->window_);
Direct3D9\D3D9Graphics.cpp:605:        impl_->window_ = 0;
Direct3D9\D3D9Graphics.cpp:613:    if (!impl_->device_)
Direct3D9\D3D9Graphics.cpp:617:    impl_->defaultColorSurface_->GetDesc(&surfaceDesc);
Direct3D9\D3D9Graphics.cpp:625:    if (impl_->presentParams_.MultiSampleType)
Direct3D9\D3D9Graphics.cpp:639:    impl_->device_->CreateOffscreenPlainSurface(surfaceWidth, surfaceHeight, surfaceDesc.Format, D3DPOOL_SYSTEMMEM, &surface, 0);
Direct3D9\D3D9Graphics.cpp:647:        impl_->device_->GetRenderTargetData(impl_->defaultColorSurface_, surface);
Direct3D9\D3D9Graphics.cpp:649:        impl_->device_->GetFrontBufferData(0, surface);
Direct3D9\D3D9Graphics.cpp:662:        HWND hwnd = GetWindowHandle(impl_->window_);
Direct3D9\D3D9Graphics.cpp:669:    surface->LockRect(&lockedRect, &sourceRect, D3DLOCK_NOSYSLOCK | D3DLOCK_READONLY);
Direct3D9\D3D9Graphics.cpp:673:        surface->Release();
Direct3D9\D3D9Graphics.cpp:719:    surface->UnlockRect();
Direct3D9\D3D9Graphics.cpp:720:    surface->Release();
Direct3D9\D3D9Graphics.cpp:735:        SDL_GetWindowSize(impl_->window_, &width, &height);
Direct3D9\D3D9Graphics.cpp:743:        if (fullscreen_ && (SDL_GetWindowFlags(impl_->window_) & SDL_WINDOW_MINIMIZED))
Direct3D9\D3D9Graphics.cpp:748:    HRESULT hr = impl_->device_->TestCooperativeLevel();
Direct3D9\D3D9Graphics.cpp:769:    impl_->device_->BeginScene();
Direct3D9\D3D9Graphics.cpp:796:        impl_->device_->EndScene();
Direct3D9\D3D9Graphics.cpp:797:        impl_->device_->Present(0, 0, 0, 0);
Direct3D9\D3D9Graphics.cpp:802:    if (impl_->frameQuery_)
Direct3D9\D3D9Graphics.cpp:808:            while (impl_->frameQuery_->GetData(0, 0, D3DGETDATA_FLUSH) == S_FALSE)
Direct3D9\D3D9Graphics.cpp:817:            impl_->frameQuery_->Issue(D3DISSUE_END);
Direct3D9\D3D9Graphics.cpp:836:    impl_->device_->Clear(0, 0, d3dFlags, GetD3DColor(color), depth, stencil);
Direct3D9\D3D9Graphics.cpp:841:    if (!destination || !destination->GetRenderSurface())
Direct3D9\D3D9Graphics.cpp:861:    destRect.right = destination->GetWidth();
Direct3D9\D3D9Graphics.cpp:862:    destRect.bottom = destination->GetHeight();
Direct3D9\D3D9Graphics.cpp:864:    return SUCCEEDED(impl_->device_->StretchRect(impl_->defaultColorSurface_, &rect,
Direct3D9\D3D9Graphics.cpp:865:        (IDirect3DSurface9*)destination->GetRenderSurface()->GetSurface(), &destRect, D3DTEXF_NONE));
Direct3D9\D3D9Graphics.cpp:879:    impl_->device_->DrawPrimitive(d3dPrimitiveType, vertexStart, primitiveCount);
Direct3D9\D3D9Graphics.cpp:896:    impl_->device_->DrawIndexedPrimitive(d3dPrimitiveType, 0, minVertex, vertexCount, indexStart, primitiveCount);
Direct3D9\D3D9Graphics.cpp:913:            if (buffer->GetElementMask() & MASK_INSTANCEMATRIX1)
Direct3D9\D3D9Graphics.cpp:924:    impl_->device_->DrawIndexedPrimitive(d3dPrimitiveType, 0, minVertex, vertexCount, indexStart, primitiveCount);
Direct3D9\D3D9Graphics.cpp:932:    // Note: this is not multi-instance safe
Direct3D9\D3D9Graphics.cpp:961:        hash |= buffers[i]->GetBufferHash(i, elementMasks[i]);
Direct3D9\D3D9Graphics.cpp:970:            if (!newDeclaration->GetDeclaration())
Direct3D9\D3D9Graphics.cpp:982:            impl_->device_->SetVertexDeclaration(declaration->GetDeclaration());
Direct3D9\D3D9Graphics.cpp:995:            if (buffer && buffer->GetElementMask() & MASK_INSTANCEMATRIX1)
Direct3D9\D3D9Graphics.cpp:996:                offset = instanceOffset * buffer->GetVertexSize();
Direct3D9\D3D9Graphics.cpp:1002:                impl_->device_->SetStreamSource(i, (IDirect3DVertexBuffer9*)buffer->GetGPUObject(), offset, buffer->GetVertexSize());
Direct3D9\D3D9Graphics.cpp:1004:                impl_->device_->SetStreamSource(i, 0, 0, 0);
Direct3D9\D3D9Graphics.cpp:1025:            impl_->device_->SetIndices((IDirect3DIndexBuffer9*)buffer->GetGPUObject());
Direct3D9\D3D9Graphics.cpp:1027:            impl_->device_->SetIndices(0);
Direct3D9\D3D9Graphics.cpp:1043:        if (vs && !vs->GetGPUObject())
Direct3D9\D3D9Graphics.cpp:1045:            if (vs->GetCompilerOutput().Empty())
Direct3D9\D3D9Graphics.cpp:1049:                bool success = vs->Create();
Direct3D9\D3D9Graphics.cpp:1052:                    LOGERROR("Failed to compile vertex shader " + vs->GetFullName() + ":\n" + vs->GetCompilerOutput());
Direct3D9\D3D9Graphics.cpp:1060:        if (vs && vs->GetShaderType() == VS)
Direct3D9\D3D9Graphics.cpp:1061:            impl_->device_->SetVertexShader((IDirect3DVertexShader9*)vs->GetGPUObject());
Direct3D9\D3D9Graphics.cpp:1064:            impl_->device_->SetVertexShader(0);
Direct3D9\D3D9Graphics.cpp:1073:        if (ps && !ps->GetGPUObject())
Direct3D9\D3D9Graphics.cpp:1075:            if (ps->GetCompilerOutput().Empty())
Direct3D9\D3D9Graphics.cpp:1079:                bool success = ps->Create();
Direct3D9\D3D9Graphics.cpp:1082:                    LOGERROR("Failed to compile pixel shader " + ps->GetFullName() + ":\n" + ps->GetCompilerOutput());
Direct3D9\D3D9Graphics.cpp:1090:        if (ps && ps->GetShaderType() == PS)
Direct3D9\D3D9Graphics.cpp:1091:            impl_->device_->SetPixelShader((IDirect3DPixelShader9*)ps->GetGPUObject());
Direct3D9\D3D9Graphics.cpp:1094:            impl_->device_->SetPixelShader(0);
Direct3D9\D3D9Graphics.cpp:1107:            shaderProgram_ = i->second_.Get();
Direct3D9\D3D9Graphics.cpp:1119:        shaderPrecache_->StoreShaders(vertexShader_, pixelShader_);
Direct3D9\D3D9Graphics.cpp:1125:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D9\D3D9Graphics.cpp:1128:    if (i->second_.type_ == VS)
Direct3D9\D3D9Graphics.cpp:1129:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, data, count / 4);
Direct3D9\D3D9Graphics.cpp:1131:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, data, count / 4);
Direct3D9\D3D9Graphics.cpp:1137:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D9\D3D9Graphics.cpp:1143:    if (i->second_.type_ == VS)
Direct3D9\D3D9Graphics.cpp:1144:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, &data.x_, 1);
Direct3D9\D3D9Graphics.cpp:1146:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, &data.x_, 1);
Direct3D9\D3D9Graphics.cpp:1153:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D9\D3D9Graphics.cpp:1158:    if (i->second_.type_ == VS)
Direct3D9\D3D9Graphics.cpp:1159:        impl_->device_->SetVertexShaderConstantB(i->second_.register_, &data, 1);
Direct3D9\D3D9Graphics.cpp:1161:        impl_->device_->SetPixelShaderConstantB(i->second_.register_, &data, 1);
Direct3D9\D3D9Graphics.cpp:1167:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D9\D3D9Graphics.cpp:1170:    if (i->second_.type_ == VS)
Direct3D9\D3D9Graphics.cpp:1171:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, color.Data(), 1);
Direct3D9\D3D9Graphics.cpp:1173:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, color.Data(), 1);
Direct3D9\D3D9Graphics.cpp:1179:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D9\D3D9Graphics.cpp:1186:    if (i->second_.type_ == VS)
Direct3D9\D3D9Graphics.cpp:1187:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, &data.x_, 1);
Direct3D9\D3D9Graphics.cpp:1189:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, &data.x_, 1);
Direct3D9\D3D9Graphics.cpp:1195:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D9\D3D9Graphics.cpp:1209:    if (i->second_.type_ == VS)
Direct3D9\D3D9Graphics.cpp:1210:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, &data.m00_, 3);
Direct3D9\D3D9Graphics.cpp:1212:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, &data.m00_, 3);
Direct3D9\D3D9Graphics.cpp:1218:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D9\D3D9Graphics.cpp:1226:    if (i->second_.type_ == VS)
Direct3D9\D3D9Graphics.cpp:1227:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, &data.x_, 1);
Direct3D9\D3D9Graphics.cpp:1229:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, &data.x_, 1);
Direct3D9\D3D9Graphics.cpp:1235:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D9\D3D9Graphics.cpp:1238:    if (i->second_.type_ == VS)
Direct3D9\D3D9Graphics.cpp:1239:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, matrix.Data(), 4);
Direct3D9\D3D9Graphics.cpp:1241:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, matrix.Data(), 4);
Direct3D9\D3D9Graphics.cpp:1247:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D9\D3D9Graphics.cpp:1250:    if (i->second_.type_ == VS)
Direct3D9\D3D9Graphics.cpp:1251:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, vector.Data(), 1);
Direct3D9\D3D9Graphics.cpp:1253:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, vector.Data(), 1);
Direct3D9\D3D9Graphics.cpp:1259:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Direct3D9\D3D9Graphics.cpp:1262:    if (i->second_.type_ == VS)
Direct3D9\D3D9Graphics.cpp:1263:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, matrix.Data(), 3);
Direct3D9\D3D9Graphics.cpp:1265:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, matrix.Data(), 3);
Direct3D9\D3D9Graphics.cpp:1327:    return shaderProgram_ && shaderProgram_->parameters_.Find(param) != shaderProgram_->parameters_.End();
Direct3D9\D3D9Graphics.cpp:1332:    return pixelShader_ && pixelShader_->HasTextureUnit(unit);
Direct3D9\D3D9Graphics.cpp:1360:        if (renderTargets_[0] && renderTargets_[0]->GetParentTexture() == texture)
Direct3D9\D3D9Graphics.cpp:1361:            texture = texture->GetBackupTexture();
Direct3D9\D3D9Graphics.cpp:1367:            impl_->device_->SetTexture(index, (IDirect3DBaseTexture9*)texture->GetGPUObject());
Direct3D9\D3D9Graphics.cpp:1369:            impl_->device_->SetTexture(index, 0);
Direct3D9\D3D9Graphics.cpp:1376:        TextureFilterMode filterMode = texture->GetFilterMode();
Direct3D9\D3D9Graphics.cpp:1382:        if (minMag != impl_->minMagFilters_[index])
Direct3D9\D3D9Graphics.cpp:1384:            impl_->device_->SetSamplerState(index, D3DSAMP_MAGFILTER, minMag);
Direct3D9\D3D9Graphics.cpp:1385:            impl_->device_->SetSamplerState(index, D3DSAMP_MINFILTER, minMag);
Direct3D9\D3D9Graphics.cpp:1386:            impl_->minMagFilters_[index] = minMag;
Direct3D9\D3D9Graphics.cpp:1389:        if (mip != impl_->mipFilters_[index])
Direct3D9\D3D9Graphics.cpp:1391:            impl_->device_->SetSamplerState(index, D3DSAMP_MIPFILTER, mip);
Direct3D9\D3D9Graphics.cpp:1392:            impl_->mipFilters_[index] = mip;
Direct3D9\D3D9Graphics.cpp:1395:        u = d3dAddressMode[texture->GetAddressMode(COORD_U)];
Direct3D9\D3D9Graphics.cpp:1396:        if (u != impl_->uAddressModes_[index])
Direct3D9\D3D9Graphics.cpp:1398:            impl_->device_->SetSamplerState(index, D3DSAMP_ADDRESSU, u);
Direct3D9\D3D9Graphics.cpp:1399:            impl_->uAddressModes_[index] = u;
Direct3D9\D3D9Graphics.cpp:1401:        v = d3dAddressMode[texture->GetAddressMode(COORD_V)];
Direct3D9\D3D9Graphics.cpp:1402:        if (v != impl_->vAddressModes_[index])
Direct3D9\D3D9Graphics.cpp:1404:            impl_->device_->SetSamplerState(index, D3DSAMP_ADDRESSV, v);
Direct3D9\D3D9Graphics.cpp:1405:            impl_->vAddressModes_[index] = v;
Direct3D9\D3D9Graphics.cpp:1407:        if (texture->GetType() == TextureCube::GetTypeStatic())
Direct3D9\D3D9Graphics.cpp:1409:            D3DTEXTUREADDRESS w = d3dAddressMode[texture->GetAddressMode(COORD_W)];
Direct3D9\D3D9Graphics.cpp:1410:            if (w != impl_->wAddressModes_[index])
Direct3D9\D3D9Graphics.cpp:1412:                impl_->device_->SetSamplerState(index, D3DSAMP_ADDRESSW, w);
Direct3D9\D3D9Graphics.cpp:1413:                impl_->wAddressModes_[index] = w;
Direct3D9\D3D9Graphics.cpp:1418:            const Color& borderColor = texture->GetBorderColor();
Direct3D9\D3D9Graphics.cpp:1419:            if (borderColor != impl_->borderColors_[index])
Direct3D9\D3D9Graphics.cpp:1421:                impl_->device_->SetSamplerState(index, D3DSAMP_BORDERCOLOR, GetD3DColor(borderColor));
Direct3D9\D3D9Graphics.cpp:1422:                impl_->borderColors_[index] = borderColor;
Direct3D9\D3D9Graphics.cpp:1427:            bool sRGB = texture->GetSRGB();
Direct3D9\D3D9Graphics.cpp:1428:            if (sRGB != impl_->sRGBModes_[index])
Direct3D9\D3D9Graphics.cpp:1430:                impl_->device_->SetSamplerState(index, D3DSAMP_SRGBTEXTURE, sRGB ? TRUE : FALSE);
Direct3D9\D3D9Graphics.cpp:1431:                impl_->sRGBModes_[index] = sRGB;
Direct3D9\D3D9Graphics.cpp:1469:        if (renderTarget->GetUsage() != TEXTURE_RENDERTARGET)
Direct3D9\D3D9Graphics.cpp:1471:        newColorSurface = (IDirect3DSurface9*)renderTarget->GetSurface();
Direct3D9\D3D9Graphics.cpp:1476:            newColorSurface = impl_->defaultColorSurface_;
Direct3D9\D3D9Graphics.cpp:1481:    if (newColorSurface != impl_->colorSurfaces_[index])
Direct3D9\D3D9Graphics.cpp:1483:        impl_->device_->SetRenderTarget(index, newColorSurface);
Direct3D9\D3D9Graphics.cpp:1484:        impl_->colorSurfaces_[index] = newColorSurface;
Direct3D9\D3D9Graphics.cpp:1496:        Texture* parentTexture = renderTarget->GetParentTexture();
Direct3D9\D3D9Graphics.cpp:1501:                SetTexture(i, textures_[i]->GetBackupTexture());
Direct3D9\D3D9Graphics.cpp:1508:        bool sRGBWrite = renderTarget ? renderTarget->GetParentTexture()->GetSRGB() : sRGB_;
Direct3D9\D3D9Graphics.cpp:1509:        if (sRGBWrite != impl_->sRGBWrite_)
Direct3D9\D3D9Graphics.cpp:1511:            impl_->device_->SetRenderState(D3DRS_SRGBWRITEENABLE, sRGBWrite ? TRUE : FALSE);
Direct3D9\D3D9Graphics.cpp:1512:            impl_->sRGBWrite_ = sRGBWrite;
Direct3D9\D3D9Graphics.cpp:1521:        renderTarget = texture->GetRenderSurface();
Direct3D9\D3D9Graphics.cpp:1529:    if (depthStencil && depthStencil->GetUsage() == TEXTURE_DEPTHSTENCIL)
Direct3D9\D3D9Graphics.cpp:1531:        newDepthStencilSurface = (IDirect3DSurface9*)depthStencil->GetSurface();
Direct3D9\D3D9Graphics.cpp:1536:        newDepthStencilSurface = impl_->defaultDepthStencilSurface_;
Direct3D9\D3D9Graphics.cpp:1539:    if (newDepthStencilSurface != impl_->depthStencilSurface_)
Direct3D9\D3D9Graphics.cpp:1541:        impl_->device_->SetDepthStencilSurface(newDepthStencilSurface);
Direct3D9\D3D9Graphics.cpp:1542:        impl_->depthStencilSurface_ = newDepthStencilSurface;
Direct3D9\D3D9Graphics.cpp:1550:        depthStencil = texture->GetRenderSurface();
Direct3D9\D3D9Graphics.cpp:1578:    impl_->device_->SetViewport(&vp);
Direct3D9\D3D9Graphics.cpp:1581:    // Disable scissor test, needs to be re-enabled by the user
Direct3D9\D3D9Graphics.cpp:1593:            impl_->device_->SetSamplerState(i, D3DSAMP_MAXANISOTROPY, level);
Direct3D9\D3D9Graphics.cpp:1603:        if (d3dBlendEnable[mode] != impl_->blendEnable_)
Direct3D9\D3D9Graphics.cpp:1605:            impl_->device_->SetRenderState(D3DRS_ALPHABLENDENABLE, d3dBlendEnable[mode]);
Direct3D9\D3D9Graphics.cpp:1606:            impl_->blendEnable_ = d3dBlendEnable[mode];
Direct3D9\D3D9Graphics.cpp:1609:        if (impl_->blendEnable_)
Direct3D9\D3D9Graphics.cpp:1611:            if (d3dSrcBlend[mode] != impl_->srcBlend_)
Direct3D9\D3D9Graphics.cpp:1613:                impl_->device_->SetRenderState(D3DRS_SRCBLEND, d3dSrcBlend[mode]);
Direct3D9\D3D9Graphics.cpp:1614:                impl_->srcBlend_ = d3dSrcBlend[mode];
Direct3D9\D3D9Graphics.cpp:1616:            if (d3dDestBlend[mode] != impl_->destBlend_)
Direct3D9\D3D9Graphics.cpp:1618:                impl_->device_->SetRenderState(D3DRS_DESTBLEND, d3dDestBlend[mode]);
Direct3D9\D3D9Graphics.cpp:1619:                impl_->destBlend_ = d3dDestBlend[mode];
Direct3D9\D3D9Graphics.cpp:1621:            if (d3dBlendOp[mode] != impl_->blendOp_)
Direct3D9\D3D9Graphics.cpp:1623:                impl_->device_->SetRenderState(D3DRS_BLENDOP, d3dBlendOp[mode]);
Direct3D9\D3D9Graphics.cpp:1624:                impl_->blendOp_ = d3dBlendOp[mode];
Direct3D9\D3D9Graphics.cpp:1636:        impl_->device_->SetRenderState(D3DRS_COLORWRITEENABLE, enable ? D3DCOLORWRITEENABLE_RED |
Direct3D9\D3D9Graphics.cpp:1646:        impl_->device_->SetRenderState(D3DRS_CULLMODE, d3dCullMode[mode]);
Direct3D9\D3D9Graphics.cpp:1655:        impl_->device_->SetRenderState(D3DRS_DEPTHBIAS, *((DWORD*)&constantBias));
Direct3D9\D3D9Graphics.cpp:1660:        impl_->device_->SetRenderState(D3DRS_SLOPESCALEDEPTHBIAS, *((DWORD*)&slopeScaledBias));
Direct3D9\D3D9Graphics.cpp:1669:        impl_->device_->SetRenderState(D3DRS_ZFUNC, d3dCmpFunc[mode]);
Direct3D9\D3D9Graphics.cpp:1678:        impl_->device_->SetRenderState(D3DRS_ZWRITEENABLE, enable ? TRUE : FALSE);
Direct3D9\D3D9Graphics.cpp:1687:        impl_->device_->SetRenderState(D3DRS_FILLMODE, d3dFillMode[mode]);
Direct3D9\D3D9Graphics.cpp:1707:        intRect.left_ = Clamp((int)((rect.min_.x_ + 1.0f) * 0.5f * viewSize.x_) + viewPos.x_, 0, rtSize.x_ - 1);
Direct3D9\D3D9Graphics.cpp:1708:        intRect.top_ = Clamp((int)((-rect.max_.y_ + 1.0f) * 0.5f * viewSize.y_) + viewPos.y_, 0, rtSize.y_ - 1);
Direct3D9\D3D9Graphics.cpp:1710:        intRect.bottom_ = Clamp((int)((-rect.min_.y_ + 1.0f) * 0.5f * viewSize.y_) + viewPos.y_ + expand, 0, rtSize.y_);
Direct3D9\D3D9Graphics.cpp:1728:            impl_->device_->SetScissorRect(&d3dRect);
Direct3D9\D3D9Graphics.cpp:1737:        impl_->device_->SetRenderState(D3DRS_SCISSORTESTENABLE, enable ? TRUE : FALSE);
Direct3D9\D3D9Graphics.cpp:1751:        intRect.left_ = Clamp(rect.left_ + viewPos.x_, 0, rtSize.x_ - 1);
Direct3D9\D3D9Graphics.cpp:1752:        intRect.top_ = Clamp(rect.top_ + viewPos.y_, 0, rtSize.y_ - 1);
Direct3D9\D3D9Graphics.cpp:1772:            impl_->device_->SetScissorRect(&d3dRect);
Direct3D9\D3D9Graphics.cpp:1781:        impl_->device_->SetRenderState(D3DRS_SCISSORTESTENABLE, enable ? TRUE : FALSE);
Direct3D9\D3D9Graphics.cpp:1790:        impl_->device_->SetRenderState(D3DRS_STENCILENABLE, enable ? TRUE : FALSE);
Direct3D9\D3D9Graphics.cpp:1798:            impl_->device_->SetRenderState(D3DRS_STENCILFUNC, d3dCmpFunc[mode]);
Direct3D9\D3D9Graphics.cpp:1803:            impl_->device_->SetRenderState(D3DRS_STENCILPASS, d3dStencilOp[pass]);
Direct3D9\D3D9Graphics.cpp:1808:            impl_->device_->SetRenderState(D3DRS_STENCILFAIL, d3dStencilOp[fail]);
Direct3D9\D3D9Graphics.cpp:1813:            impl_->device_->SetRenderState(D3DRS_STENCILZFAIL, d3dStencilOp[zFail]);
Direct3D9\D3D9Graphics.cpp:1818:            impl_->device_->SetRenderState(D3DRS_STENCILREF, stencilRef);
Direct3D9\D3D9Graphics.cpp:1823:            impl_->device_->SetRenderState(D3DRS_STENCILMASK, compareMask);
Direct3D9\D3D9Graphics.cpp:1828:            impl_->device_->SetRenderState(D3DRS_STENCILWRITEMASK, writeMask);
Direct3D9\D3D9Graphics.cpp:1838:        impl_->device_->SetRenderState(D3DRS_CLIPPLANEENABLE, enable ? 1 : 0);
Direct3D9\D3D9Graphics.cpp:1845:        impl_->device_->SetClipPlane(0, clipPlane.Transformed(viewProj).ToVector4().Data());
Direct3D9\D3D9Graphics.cpp:1868:    return impl_->window_ != 0 && impl_->GetDevice() != 0;
Direct3D9\D3D9Graphics.cpp:1873:    if (impl_->window_)
Direct3D9\D3D9Graphics.cpp:1914:    if (!impl_->interface_)
Direct3D9\D3D9Graphics.cpp:1923:        if (SUCCEEDED(impl_->interface_->CheckDeviceMultiSampleType(impl_->adapter_, impl_->deviceType_, fullscreenFormat, FALSE,
Direct3D9\D3D9Graphics.cpp:1971:        if (lastShaderName_ == name && !cache->Exists(fullShaderName))
Direct3D9\D3D9Graphics.cpp:1974:        lastShader_ = cache->GetResource<Shader>(fullShaderName);
Direct3D9\D3D9Graphics.cpp:1978:    return lastShader_ ? lastShader_->GetVariation(type, defines) : (ShaderVariation*)0;
Direct3D9\D3D9Graphics.cpp:1990:        return i->second_;
Direct3D9\D3D9Graphics.cpp:1999:        if (i->second_ == unit)
Direct3D9\D3D9Graphics.cpp:2000:            return i->first_;
Direct3D9\D3D9Graphics.cpp:2021:        width = renderTargets_[0]->GetWidth();
Direct3D9\D3D9Graphics.cpp:2022:        height = renderTargets_[0]->GetHeight();
Direct3D9\D3D9Graphics.cpp:2035:    if (!impl_->device_ || !impl_->window_)
Direct3D9\D3D9Graphics.cpp:2040:    SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Direct3D9\D3D9Graphics.cpp:2047:    impl_->presentParams_.BackBufferWidth            = width_;
Direct3D9\D3D9Graphics.cpp:2048:    impl_->presentParams_.BackBufferHeight           = height_;
Direct3D9\D3D9Graphics.cpp:2069:    if (!impl_->device_ || !impl_->window_ || fullscreen_)
Direct3D9\D3D9Graphics.cpp:2074:    SDL_GetWindowPosition(impl_->window_, &newX, &newY);
Direct3D9\D3D9Graphics.cpp:2093:    if (!impl_->window_)
Direct3D9\D3D9Graphics.cpp:2096:    SDL_MaximizeWindow(impl_->window_);
Direct3D9\D3D9Graphics.cpp:2101:    if (!impl_->window_)
Direct3D9\D3D9Graphics.cpp:2104:    SDL_MinimizeWindow(impl_->window_);
Direct3D9\D3D9Graphics.cpp:2132:        if (!i->reserved_ && i->size_ >= size)
Direct3D9\D3D9Graphics.cpp:2134:            i->reserved_ = true;
Direct3D9\D3D9Graphics.cpp:2135:            return i->data_.Get();
Direct3D9\D3D9Graphics.cpp:2142:        if (!i->reserved_)
Direct3D9\D3D9Graphics.cpp:2144:            i->data_ = new unsigned char[size];
Direct3D9\D3D9Graphics.cpp:2145:            i->size_ = size;
Direct3D9\D3D9Graphics.cpp:2146:            i->reserved_ = true;
Direct3D9\D3D9Graphics.cpp:2150:            return i->data_.Get();
Direct3D9\D3D9Graphics.cpp:2172:        if (i->reserved_ && i->data_.Get() == buffer)
Direct3D9\D3D9Graphics.cpp:2174:            i->reserved_ = false;
Direct3D9\D3D9Graphics.cpp:2186:        if (!i->reserved_ && i->size_ > maxScratchBufferRequest_ * 2)
Direct3D9\D3D9Graphics.cpp:2188:            i->data_ = maxScratchBufferRequest_ > 0 ? new unsigned char[maxScratchBufferRequest_] : 0;
Direct3D9\D3D9Graphics.cpp:2189:            i->size_ = maxScratchBufferRequest_;
Direct3D9\D3D9Graphics.cpp:2202:        if (i->first_.first_ == variation || i->first_.second_ == variation)
Direct3D9\D3D9Graphics.cpp:2336:        impl_->device_->SetStreamSourceFreq(index, frequency);
Direct3D9\D3D9Graphics.cpp:2347:            impl_->device_->SetStreamSourceFreq(i, 1);
Direct3D9\D3D9Graphics.cpp:2363:        impl_->window_ = SDL_CreateWindow(windowTitle_.CString(), position_.x_, position_.y_, width, height, flags);
Direct3D9\D3D9Graphics.cpp:2366:        impl_->window_ = SDL_CreateWindowFrom(externalWindow_, 0);
Direct3D9\D3D9Graphics.cpp:2368:    if (!impl_->window_)
Direct3D9\D3D9Graphics.cpp:2374:    SDL_GetWindowPosition(impl_->window_, &position_.x_, &position_.y_);
Direct3D9\D3D9Graphics.cpp:2385:        SDL_Surface* surface = windowIcon_->GetSDLSurface();
Direct3D9\D3D9Graphics.cpp:2388:            SDL_SetWindowIcon(impl_->window_, surface);
Direct3D9\D3D9Graphics.cpp:2400:            SDL_MaximizeWindow(impl_->window_);
Direct3D9\D3D9Graphics.cpp:2401:            SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Direct3D9\D3D9Graphics.cpp:2404:            SDL_SetWindowSize(impl_->window_, newWidth, newHeight);
Direct3D9\D3D9Graphics.cpp:2406:        SDL_SetWindowFullscreen(impl_->window_, newFullscreen ? SDL_TRUE : SDL_FALSE);
Direct3D9\D3D9Graphics.cpp:2407:        SDL_SetWindowBordered(impl_->window_, newBorderless ? SDL_FALSE : SDL_TRUE);
Direct3D9\D3D9Graphics.cpp:2412:        SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Direct3D9\D3D9Graphics.cpp:2419:    impl_->interface_ = Direct3DCreate9(D3D_SDK_VERSION);
Direct3D9\D3D9Graphics.cpp:2420:    if (!impl_->interface_)
Direct3D9\D3D9Graphics.cpp:2426:    if (FAILED(impl_->interface_->GetDeviceCaps(impl_->adapter_, impl_->deviceType_, &impl_->deviceCaps_)))
Direct3D9\D3D9Graphics.cpp:2432:    if (FAILED(impl_->interface_->GetAdapterIdentifier(impl_->adapter_, 0, &impl_->adapterIdentifier_)))
Direct3D9\D3D9Graphics.cpp:2438:    if (impl_->deviceCaps_.PixelShaderVersion < D3DPS_VERSION(3, 0))
Direct3D9\D3D9Graphics.cpp:2454:    if (impl_->deviceCaps_.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT)
Direct3D9\D3D9Graphics.cpp:2457:        if (impl_->deviceCaps_.DevCaps & D3DDEVCAPS_PUREDEVICE)
Direct3D9\D3D9Graphics.cpp:2463:    if (FAILED(impl_->interface_->CreateDevice(
Direct3D9\D3D9Graphics.cpp:2466:        GetWindowHandle(impl_->window_),
Direct3D9\D3D9Graphics.cpp:2468:        &impl_->presentParams_,
Direct3D9\D3D9Graphics.cpp:2469:        &impl_->device_)))
Direct3D9\D3D9Graphics.cpp:2475:    impl_->adapter_ = adapter;
Direct3D9\D3D9Graphics.cpp:2476:    impl_->deviceType_ = (D3DDEVTYPE)deviceType;
Direct3D9\D3D9Graphics.cpp:2495:    if (impl_->CheckFormatSupport((D3DFORMAT)shadowMapFormat_, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE))
Direct3D9\D3D9Graphics.cpp:2501:        if (!impl_->CheckFormatSupport((D3DFORMAT)hiresShadowMapFormat_, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE))
Direct3D9\D3D9Graphics.cpp:2508:        if (impl_->CheckFormatSupport((D3DFORMAT)shadowMapFormat_, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE))
Direct3D9\D3D9Graphics.cpp:2512:            if (!impl_->CheckFormatSupport((D3DFORMAT)hiresShadowMapFormat_, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE))
Direct3D9\D3D9Graphics.cpp:2526:        if (impl_->adapterIdentifier_.VendorId == 0x8086 && impl_->adapterIdentifier_.DeviceId == 0x2a42 &&
Direct3D9\D3D9Graphics.cpp:2527:            impl_->adapterIdentifier_.DriverVersion.QuadPart <= 0x0007000f000a05d0ULL)
Direct3D9\D3D9Graphics.cpp:2533:    if (impl_->CheckFormatSupport(intZFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE))
Direct3D9\D3D9Graphics.cpp:2539:    if (impl_->CheckFormatSupport(nullFormat, D3DUSAGE_RENDERTARGET, D3DRTYPE_TEXTURE))
Direct3D9\D3D9Graphics.cpp:2541:    else if (impl_->CheckFormatSupport(D3DFMT_R16F, D3DUSAGE_RENDERTARGET, D3DRTYPE_TEXTURE))
Direct3D9\D3D9Graphics.cpp:2543:    else if (impl_->CheckFormatSupport(D3DFMT_R5G6B5, D3DUSAGE_RENDERTARGET, D3DRTYPE_TEXTURE))
Direct3D9\D3D9Graphics.cpp:2545:    else if (impl_->CheckFormatSupport(D3DFMT_A4R4G4B4, D3DUSAGE_RENDERTARGET, D3DRTYPE_TEXTURE))
Direct3D9\D3D9Graphics.cpp:2549:    if (impl_->deviceCaps_.NumSimultaneousRTs >= 2 && impl_->CheckFormatSupport(D3DFMT_R32F, D3DUSAGE_RENDERTARGET,
Direct3D9\D3D9Graphics.cpp:2553:        if (impl_->deviceCaps_.NumSimultaneousRTs >= 4)
Direct3D9\D3D9Graphics.cpp:2558:    if (impl_->deviceCaps_.DevCaps2 & D3DDEVCAPS2_STREAMOFFSET)
Direct3D9\D3D9Graphics.cpp:2563:    sRGBSupport_ = impl_->CheckFormatSupport(D3DFMT_X8R8G8B8, D3DUSAGE_QUERY_SRGBREAD, D3DRTYPE_TEXTURE);
Direct3D9\D3D9Graphics.cpp:2564:    sRGBWriteSupport_ = impl_->CheckFormatSupport(D3DFMT_X8R8G8B8, D3DUSAGE_QUERY_SRGBWRITE, D3DRTYPE_TEXTURE);
Direct3D9\D3D9Graphics.cpp:2571:    if (SUCCEEDED(impl_->device_->Reset(&impl_->presentParams_)))
Direct3D9\D3D9Graphics.cpp:2582:    if (impl_->defaultColorSurface_)
Direct3D9\D3D9Graphics.cpp:2584:        impl_->defaultColorSurface_->Release();
Direct3D9\D3D9Graphics.cpp:2585:        impl_->defaultColorSurface_ = 0;
Direct3D9\D3D9Graphics.cpp:2587:    if (impl_->defaultDepthStencilSurface_)
Direct3D9\D3D9Graphics.cpp:2589:        impl_->defaultDepthStencilSurface_->Release();
Direct3D9\D3D9Graphics.cpp:2590:        impl_->defaultDepthStencilSurface_ = 0;
Direct3D9\D3D9Graphics.cpp:2592:    if (impl_->frameQuery_)
Direct3D9\D3D9Graphics.cpp:2594:        impl_->frameQuery_->Release();
Direct3D9\D3D9Graphics.cpp:2595:        impl_->frameQuery_ = 0;
Direct3D9\D3D9Graphics.cpp:2602:            (*i)->OnDeviceLost();
Direct3D9\D3D9Graphics.cpp:2614:            (*i)->OnDeviceReset();
Direct3D9\D3D9Graphics.cpp:2618:    impl_->device_->GetRenderTarget(0, &impl_->defaultColorSurface_);
Direct3D9\D3D9Graphics.cpp:2619:    impl_->device_->GetDepthStencilSurface(&impl_->defaultDepthStencilSurface_);
Direct3D9\D3D9Graphics.cpp:2622:    impl_->device_->CreateQuery(D3DQUERYTYPE_EVENT, &impl_->frameQuery_);
Direct3D9\D3D9Graphics.cpp:2640:        impl_->minMagFilters_[i] = D3DTEXF_POINT;
Direct3D9\D3D9Graphics.cpp:2641:        impl_->mipFilters_[i] = D3DTEXF_NONE;
Direct3D9\D3D9Graphics.cpp:2642:        impl_->uAddressModes_[i] = D3DTADDRESS_WRAP;
Direct3D9\D3D9Graphics.cpp:2643:        impl_->vAddressModes_[i] = D3DTADDRESS_WRAP;
Direct3D9\D3D9Graphics.cpp:2644:        impl_->wAddressModes_[i] = D3DTADDRESS_WRAP;
Direct3D9\D3D9Graphics.cpp:2645:        impl_->borderColors_[i] = Color(0.0f, 0.0f, 0.0f, 0.0f);
Direct3D9\D3D9Graphics.cpp:2646:        impl_->sRGBModes_[i] = false;
Direct3D9\D3D9Graphics.cpp:2652:        impl_->colorSurfaces_[i] = 0;
Direct3D9\D3D9Graphics.cpp:2656:    impl_->depthStencilSurface_ = 0;
Direct3D9\D3D9Graphics.cpp:2658:    impl_->sRGBWrite_ = false;
Direct3D9\D3D9Graphics.cpp:2687:    impl_->blendEnable_ = FALSE;
Direct3D9\D3D9Graphics.cpp:2688:    impl_->srcBlend_ = D3DBLEND_ONE;
Direct3D9\D3D9Graphics.cpp:2689:    impl_->destBlend_ = D3DBLEND_ZERO;
Direct3D9\D3D9Graphics.cpp:2690:    impl_->blendOp_ = D3DBLENDOP_ADD;
Direct3D9\D3D9RenderSurface.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9RenderSurface.h:33:/// %Color or depth-stencil surface that can be rendered into.
Direct3D9\D3D9RenderSurface.h:53:    /// Set linked depth-stencil surface.
Direct3D9\D3D9RenderSurface.h:78:    /// Return linked depth-stencil surface.
Direct3D9\D3D9ShaderProgram.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9ShaderProgram.h:38:        const HashMap<StringHash, ShaderParameter>& vsParams = vertexShader->GetParameters();
Direct3D9\D3D9ShaderProgram.h:40:        parameters_[i->first_] = i->second_;
Direct3D9\D3D9ShaderProgram.h:42:        const HashMap<StringHash, ShaderParameter>& psParams = pixelShader->GetParameters();
Direct3D9\D3D9ShaderProgram.h:44:            parameters_[i->first_] = i->second_;
Direct3D9\D3D9ShaderVariation.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9ShaderVariation.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9ShaderVariation.cpp:42:    GPUObject(owner->GetSubsystem<Graphics>()),
Direct3D9\D3D9ShaderVariation.cpp:68:    // Check for up-to-date bytecode on disk
Direct3D9\D3D9ShaderVariation.cpp:70:    SplitPath(owner_->GetName(), path, name, extension);
Direct3D9\D3D9ShaderVariation.cpp:82:        if (owner_->GetTimeStamp())
Direct3D9\D3D9ShaderVariation.cpp:87:    IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Direct3D9\D3D9ShaderVariation.cpp:90:        if (!device || FAILED(device->CreateVertexShader(
Direct3D9\D3D9ShaderVariation.cpp:97:        if (!device || FAILED(device->CreatePixelShader(
Direct3D9\D3D9ShaderVariation.cpp:113:        graphics_->CleanupShaderPrograms(this);
Direct3D9\D3D9ShaderVariation.cpp:117:            if (graphics_->GetVertexShader() == this)
Direct3D9\D3D9ShaderVariation.cpp:118:                graphics_->SetShaders(0, 0);
Direct3D9\D3D9ShaderVariation.cpp:120:            ((IDirect3DVertexShader9*)object_)->Release();
Direct3D9\D3D9ShaderVariation.cpp:124:            if (graphics_->GetPixelShader() == this)
Direct3D9\D3D9ShaderVariation.cpp:125:                graphics_->SetShaders(0, 0);
Direct3D9\D3D9ShaderVariation.cpp:127:            ((IDirect3DPixelShader9*)object_)->Release();
Direct3D9\D3D9ShaderVariation.cpp:157:    ResourceCache* cache = owner_->GetSubsystem<ResourceCache>();
Direct3D9\D3D9ShaderVariation.cpp:158:    if (!cache->Exists(binaryShaderName))
Direct3D9\D3D9ShaderVariation.cpp:161:    FileSystem* fileSystem = owner_->GetSubsystem<FileSystem>();
Direct3D9\D3D9ShaderVariation.cpp:162:    unsigned sourceTimeStamp = owner_->GetTimeStamp();
Direct3D9\D3D9ShaderVariation.cpp:165:    if (sourceTimeStamp && fileSystem->GetLastModifiedTime(cache->GetResourceFileName(binaryShaderName)) <
Direct3D9\D3D9ShaderVariation.cpp:169:    SharedPtr<File> file = cache->GetFile(binaryShaderName);
Direct3D9\D3D9ShaderVariation.cpp:170:    if (!file || file->ReadFileID() != "USHD")
Direct3D9\D3D9ShaderVariation.cpp:177:    unsigned short shaderType = file->ReadUShort();
Direct3D9\D3D9ShaderVariation.cpp:178:    unsigned short shaderModel = file->ReadUShort();
Direct3D9\D3D9ShaderVariation.cpp:180:    unsigned numParameters = file->ReadUInt();
Direct3D9\D3D9ShaderVariation.cpp:183:        String name = file->ReadString();
Direct3D9\D3D9ShaderVariation.cpp:184:        unsigned reg = file->ReadUByte();
Direct3D9\D3D9ShaderVariation.cpp:185:        unsigned regCount = file->ReadUByte();
Direct3D9\D3D9ShaderVariation.cpp:191:    unsigned numTextureUnits = file->ReadUInt();
Direct3D9\D3D9ShaderVariation.cpp:194:        String unitName = file->ReadString();
Direct3D9\D3D9ShaderVariation.cpp:195:        unsigned reg = file->ReadUByte();
Direct3D9\D3D9ShaderVariation.cpp:201:    unsigned byteCodeSize = file->ReadUInt();
Direct3D9\D3D9ShaderVariation.cpp:205:        file->Read(&byteCode[0], byteCodeSize);
Direct3D9\D3D9ShaderVariation.cpp:223:    const String& sourceCode = owner_->GetSourceCode(type_);
Direct3D9\D3D9ShaderVariation.cpp:286:    if (FAILED(D3DCompile(sourceCode.CString(), sourceCode.Length(), owner_->GetName().CString(), &macros.Front(), 0,
Direct3D9\D3D9ShaderVariation.cpp:288:        compilerOutput_ = String((const char*)errorMsgs->GetBufferPointer(), errorMsgs->GetBufferSize());
Direct3D9\D3D9ShaderVariation.cpp:297:        unsigned char* bufData = (unsigned char*)shaderCode->GetBufferPointer();
Direct3D9\D3D9ShaderVariation.cpp:298:        unsigned bufSize = shaderCode->GetBufferSize();
Direct3D9\D3D9ShaderVariation.cpp:304:        shaderCode->Release();
Direct3D9\D3D9ShaderVariation.cpp:306:        errorMsgs->Release();
Direct3D9\D3D9ShaderVariation.cpp:315:    for (int i = 0; i < parseData->symbol_count; i++)
Direct3D9\D3D9ShaderVariation.cpp:317:        MOJOSHADER_symbol const& symbol = parseData->symbols[i];
Direct3D9\D3D9ShaderVariation.cpp:329:            // Skip if it's a G-buffer sampler, which are aliases for the standard texture units
Direct3D9\D3D9ShaderVariation.cpp:374:    ResourceCache* cache = owner_->GetSubsystem<ResourceCache>();
Direct3D9\D3D9ShaderVariation.cpp:375:    FileSystem* fileSystem = owner_->GetSubsystem<FileSystem>();
Direct3D9\D3D9ShaderVariation.cpp:377:    String path = GetPath(cache->GetResourceFileName(owner_->GetName())) + "Cache/";
Direct3D9\D3D9ShaderVariation.cpp:379:    if (!fileSystem->DirExists(path))
Direct3D9\D3D9ShaderVariation.cpp:380:        fileSystem->CreateDir(path);
Direct3D9\D3D9ShaderVariation.cpp:382:    SharedPtr<File> file(new File(owner_->GetContext(), fullName, FILE_WRITE));
Direct3D9\D3D9ShaderVariation.cpp:383:    if (!file->IsOpen())
Direct3D9\D3D9ShaderVariation.cpp:386:    file->WriteFileID("USHD");
Direct3D9\D3D9ShaderVariation.cpp:387:    file->WriteShort((unsigned short)type_);
Direct3D9\D3D9ShaderVariation.cpp:388:    file->WriteShort(3);
Direct3D9\D3D9ShaderVariation.cpp:390:    file->WriteUInt(parameters_.Size());
Direct3D9\D3D9ShaderVariation.cpp:393:        file->WriteString(i->second_.name_);
Direct3D9\D3D9ShaderVariation.cpp:394:        file->WriteUByte(i->second_.register_);
Direct3D9\D3D9ShaderVariation.cpp:395:        file->WriteUByte(i->second_.regCount_);
Direct3D9\D3D9ShaderVariation.cpp:404:    file->WriteUInt(usedTextureUnits);
Direct3D9\D3D9ShaderVariation.cpp:409:            file->WriteString(graphics_->GetTextureUnitName((TextureUnit)i));
Direct3D9\D3D9ShaderVariation.cpp:410:            file->WriteUByte(i);
Direct3D9\D3D9ShaderVariation.cpp:415:    file->WriteUInt(dataSize);
Direct3D9\D3D9ShaderVariation.cpp:417:        file->Write(&byteCode[0], dataSize);
Direct3D9\D3D9Texture.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9Texture.cpp:74:        mipsToSkip_[i] = MAX_TEXTURE_QUALITY_LEVELS - 1 - i;
Direct3D9\D3D9Texture.cpp:107:        enable &= graphics_->GetSRGBSupport();
Direct3D9\D3D9Texture.cpp:126:            if (mipsToSkip_[i] > mipsToSkip_[i - 1])
Direct3D9\D3D9Texture.cpp:127:                mipsToSkip_[i] = mipsToSkip_[i - 1];
Direct3D9\D3D9Texture.cpp:241:    XMLElement rootElem = file->GetRoot();
Direct3D9\D3D9Texture.cpp:257:                TextureCoordinate coordIndex = (TextureCoordinate)(coord[0] - 'u');
Direct3D9\D3D9Texture.cpp:297:    unsigned textureBudget = cache->GetMemoryBudget(type);
Direct3D9\D3D9Texture.cpp:298:    unsigned textureUse = cache->GetMemoryUse(type);
Direct3D9\D3D9Texture.cpp:305:        cache->ReleaseResources(Material::GetTypeStatic());
Direct3D9\D3D9Texture.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9Texture.h:53:    /// Set shadow compare mode. No-op on D3D9.
Direct3D9\D3D9Texture2D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9Texture2D.h:63:    /// Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.
Direct3D9\D3D9Texture3D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9Texture3D.h:62:    /// Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.
Direct3D9\D3D9Texture2D.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9Texture2D.cpp:52:    context->RegisterFactory<Texture2D>();
Direct3D9\D3D9Texture2D.cpp:62:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9Texture2D.cpp:71:    if (!loadImage_->Load(source))
Direct3D9\D3D9Texture2D.cpp:79:        loadImage_->PrecalculateLevels();
Direct3D9\D3D9Texture2D.cpp:84:    loadParameters_ = cache->GetTempResource<XMLFile>(xmlName, false);
Direct3D9\D3D9Texture2D.cpp:92:    if (!graphics_ || graphics_->IsDeviceLost())
Direct3D9\D3D9Texture2D.cpp:119:        if (cache->Exists(GetName()))
Direct3D9\D3D9Texture2D.cpp:120:            dataLost_ = !cache->ReloadResource(this);
Direct3D9\D3D9Texture2D.cpp:141:            if (graphics_->GetTexture(i) == this)
Direct3D9\D3D9Texture2D.cpp:142:                graphics_->SetTexture(i, 0);
Direct3D9\D3D9Texture2D.cpp:146:            renderSurface_->Release();
Direct3D9\D3D9Texture2D.cpp:148:        ((IDirect3DTexture9*)object_)->Release();
Direct3D9\D3D9Texture2D.cpp:154:            renderSurface_->Release();
Direct3D9\D3D9Texture2D.cpp:220:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9Texture2D.cpp:252:    if (FAILED(((IDirect3DTexture9*)object_)->LockRect(level, &d3dLockedRect, (flags & D3DLOCK_DISCARD) ? 0 : &d3dRect, flags)))
Direct3D9\D3D9Texture2D.cpp:267:    // GetRowDataSize() returns CPU-side (source) data size, so need to convert for X8R8G8B8
Direct3D9\D3D9Texture2D.cpp:308:    ((IDirect3DTexture9*)object_)->UnlockRect(level);
Direct3D9\D3D9Texture2D.cpp:325:        quality = renderer->GetTextureQuality();
Direct3D9\D3D9Texture2D.cpp:327:    if (!image->IsCompressed())
Direct3D9\D3D9Texture2D.cpp:329:        unsigned char* levelData = image->GetData();
Direct3D9\D3D9Texture2D.cpp:330:        int levelWidth = image->GetWidth();
Direct3D9\D3D9Texture2D.cpp:331:        int levelHeight = image->GetHeight();
Direct3D9\D3D9Texture2D.cpp:332:        unsigned components = image->GetComponents();
Direct3D9\D3D9Texture2D.cpp:338:            image = image->GetNextLevel();
Direct3D9\D3D9Texture2D.cpp:339:            levelData = image->GetData();
Direct3D9\D3D9Texture2D.cpp:340:            levelWidth = image->GetWidth();
Direct3D9\D3D9Texture2D.cpp:341:            levelHeight = image->GetHeight();
Direct3D9\D3D9Texture2D.cpp:373:            if (i < levels_ - 1)
Direct3D9\D3D9Texture2D.cpp:375:                image = image->GetNextLevel();
Direct3D9\D3D9Texture2D.cpp:376:                levelData = image->GetData();
Direct3D9\D3D9Texture2D.cpp:377:                levelWidth = image->GetWidth();
Direct3D9\D3D9Texture2D.cpp:378:                levelHeight = image->GetHeight();
Direct3D9\D3D9Texture2D.cpp:384:        int width = image->GetWidth();
Direct3D9\D3D9Texture2D.cpp:385:        int height = image->GetHeight();
Direct3D9\D3D9Texture2D.cpp:386:        unsigned levels = image->GetNumCompressedLevels();
Direct3D9\D3D9Texture2D.cpp:387:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Direct3D9\D3D9Texture2D.cpp:398:            mipsToSkip = levels - 1;
Direct3D9\D3D9Texture2D.cpp:400:            --mipsToSkip;
Direct3D9\D3D9Texture2D.cpp:404:        SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Direct3D9\D3D9Texture2D.cpp:407:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Direct3D9\D3D9Texture2D.cpp:409:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Direct3D9\D3D9Texture2D.cpp:450:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9Texture2D.cpp:466:    if (FAILED(((IDirect3DTexture9*)object_)->LockRect(level, &d3dLockedRect, &d3dRect, D3DLOCK_READONLY)))
Direct3D9\D3D9Texture2D.cpp:478:    // GetRowDataSize() returns CPU-side (destination) data size, so need to convert for X8R8G8B8
Direct3D9\D3D9Texture2D.cpp:519:    ((IDirect3DTexture9*)object_)->UnlockRect(level);
Direct3D9\D3D9Texture2D.cpp:530:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9Texture2D.cpp:536:    IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Direct3D9\D3D9Texture2D.cpp:537:    // If creating a depth-stencil texture, and it is not supported, create a depth-stencil surface instead
Direct3D9\D3D9Texture2D.cpp:538:    if (usage_ & D3DUSAGE_DEPTHSTENCIL && !graphics_->GetImpl()->CheckFormatSupport((D3DFORMAT)format_, usage_, D3DRTYPE_TEXTURE))
Direct3D9\D3D9Texture2D.cpp:540:        if (!device || FAILED(device->CreateDepthStencilSurface(
Direct3D9\D3D9Texture2D.cpp:547:            (IDirect3DSurface9**)&renderSurface_->surface_,
Direct3D9\D3D9Texture2D.cpp:550:            LOGERROR("Could not create depth-stencil surface");
Direct3D9\D3D9Texture2D.cpp:558:        if (!device || FAILED(graphics_->GetImpl()->GetDevice()->CreateTexture(
Direct3D9\D3D9Texture2D.cpp:572:        levels_ = ((IDirect3DTexture9*)object_)->GetLevelCount();
Direct3D9\D3D9Texture2D.cpp:575:            ((IDirect3DTexture9*)object_)->GetSurfaceLevel(0, (IDirect3DSurface9**)&renderSurface_->surface_);
Direct3D9\D3D9Texture2D.cpp:583:    if (renderSurface_ && renderSurface_->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Direct3D9\D3D9Texture2D.cpp:584:        renderSurface_->QueueUpdate();
Direct3D9\D3D9Texture3D.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9Texture3D.cpp:52:    context->RegisterFactory<Texture3D>();
Direct3D9\D3D9Texture3D.cpp:64:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9Texture3D.cpp:74:    cache->ResetDependencies(this);
Direct3D9\D3D9Texture3D.cpp:77:    if (!loadParameters_->Load(source))
Direct3D9\D3D9Texture3D.cpp:83:    XMLElement textureElem = loadParameters_->GetRoot();
Direct3D9\D3D9Texture3D.cpp:97:        loadImage_ = cache->GetTempResource<Image>(name);
Direct3D9\D3D9Texture3D.cpp:100:            loadImage_->PrecalculateLevels();
Direct3D9\D3D9Texture3D.cpp:101:        cache->StoreResourceDependency(this, name);
Direct3D9\D3D9Texture3D.cpp:114:        SharedPtr<File> file = GetSubsystem<ResourceCache>()->GetFile(name);
Direct3D9\D3D9Texture3D.cpp:116:        if (!loadImage_->LoadColorLUT(*(file.Get())))
Direct3D9\D3D9Texture3D.cpp:124:            loadImage_->PrecalculateLevels();
Direct3D9\D3D9Texture3D.cpp:125:        cache->StoreResourceDependency(this, name);
Direct3D9\D3D9Texture3D.cpp:136:    if (!graphics_ || graphics_->IsDeviceLost())
Direct3D9\D3D9Texture3D.cpp:163:        if (cache->Exists(GetName()))
Direct3D9\D3D9Texture3D.cpp:164:            dataLost_ = !cache->ReloadResource(this);
Direct3D9\D3D9Texture3D.cpp:185:            if (graphics_->GetTexture(i) == this)
Direct3D9\D3D9Texture3D.cpp:186:                graphics_->SetTexture(i, 0);
Direct3D9\D3D9Texture3D.cpp:190:            renderSurface_->Release();
Direct3D9\D3D9Texture3D.cpp:192:        ((IDirect3DVolumeTexture9*)object_)->Release();
Direct3D9\D3D9Texture3D.cpp:198:            renderSurface_->Release();
Direct3D9\D3D9Texture3D.cpp:262:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9Texture3D.cpp:297:    if (FAILED(((IDirect3DVolumeTexture9*)object_)->LockBox(level, &d3dLockedBox, (flags & D3DLOCK_DISCARD) ? 0 : &d3dBox, flags)))
Direct3D9\D3D9Texture3D.cpp:312:    // GetRowDataSize() returns CPU-side (source) data size, so need to convert for X8R8G8B8
Direct3D9\D3D9Texture3D.cpp:362:    ((IDirect3DVolumeTexture9*)object_)->UnlockBox(level);
Direct3D9\D3D9Texture3D.cpp:379:        quality = renderer->GetTextureQuality();
Direct3D9\D3D9Texture3D.cpp:381:    if (!image->IsCompressed())
Direct3D9\D3D9Texture3D.cpp:383:        unsigned char* levelData = image->GetData();
Direct3D9\D3D9Texture3D.cpp:384:        int levelWidth = image->GetWidth();
Direct3D9\D3D9Texture3D.cpp:385:        int levelHeight = image->GetHeight();
Direct3D9\D3D9Texture3D.cpp:386:        int levelDepth = image->GetDepth();
Direct3D9\D3D9Texture3D.cpp:387:        unsigned components = image->GetComponents();
Direct3D9\D3D9Texture3D.cpp:393:            image = image->GetNextLevel();
Direct3D9\D3D9Texture3D.cpp:394:            levelData = image->GetData();
Direct3D9\D3D9Texture3D.cpp:395:            levelWidth = image->GetWidth();
Direct3D9\D3D9Texture3D.cpp:396:            levelHeight = image->GetHeight();
Direct3D9\D3D9Texture3D.cpp:397:            levelDepth = image->GetDepth();
Direct3D9\D3D9Texture3D.cpp:429:            if (i < levels_ - 1)
Direct3D9\D3D9Texture3D.cpp:431:                image = image->GetNextLevel();
Direct3D9\D3D9Texture3D.cpp:432:                levelData = image->GetData();
Direct3D9\D3D9Texture3D.cpp:433:                levelWidth = image->GetWidth();
Direct3D9\D3D9Texture3D.cpp:434:                levelHeight = image->GetHeight();
Direct3D9\D3D9Texture3D.cpp:435:                levelDepth = image->GetDepth();
Direct3D9\D3D9Texture3D.cpp:441:        int width = image->GetWidth();
Direct3D9\D3D9Texture3D.cpp:442:        int height = image->GetHeight();
Direct3D9\D3D9Texture3D.cpp:443:        int depth = image->GetDepth();
Direct3D9\D3D9Texture3D.cpp:444:        unsigned levels = image->GetNumCompressedLevels();
Direct3D9\D3D9Texture3D.cpp:445:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Direct3D9\D3D9Texture3D.cpp:456:            mipsToSkip = levels - 1;
Direct3D9\D3D9Texture3D.cpp:458:            --mipsToSkip;
Direct3D9\D3D9Texture3D.cpp:463:        SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Direct3D9\D3D9Texture3D.cpp:466:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Direct3D9\D3D9Texture3D.cpp:468:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Direct3D9\D3D9Texture3D.cpp:509:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9Texture3D.cpp:528:    if (FAILED(((IDirect3DVolumeTexture9*)object_)->LockBox(level, &d3dLockedBox, &d3dBox, D3DLOCK_READONLY)))
Direct3D9\D3D9Texture3D.cpp:540:    // GetRowDataSize() returns CPU-side (destination) data size, so need to convert for X8R8G8B8
Direct3D9\D3D9Texture3D.cpp:590:    ((IDirect3DVolumeTexture9*)object_)->UnlockBox(level);
Direct3D9\D3D9Texture3D.cpp:601:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9Texture3D.cpp:607:    IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Direct3D9\D3D9Texture3D.cpp:609:    if (!device || FAILED(graphics_->GetImpl()->GetDevice()->CreateVolumeTexture(
Direct3D9\D3D9Texture3D.cpp:624:    levels_ = ((IDirect3DVolumeTexture9*)object_)->GetLevelCount();
Direct3D9\D3D9Texture3D.cpp:631:    if (renderSurface_ && renderSurface_->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Direct3D9\D3D9Texture3D.cpp:632:        renderSurface_->QueueUpdate();
Direct3D9\D3D9TextureCube.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9TextureCube.h:65:    /// Set data of one face from an image. Return true if successful. Optionally make a single channel image alpha-only.
Direct3D9\D3D9TextureCube.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9TextureCube.cpp:55:    return SharedPtr<Image>(src->GetSubimage(IntRect(tileX * tileWidth, tileY * tileHeight, (tileX + 1) * tileWidth, (tileY + 1) * tileHeight)));
Direct3D9\D3D9TextureCube.cpp:60:    lockedLevel_(-1)
Direct3D9\D3D9TextureCube.cpp:78:    context->RegisterFactory<TextureCube>();
Direct3D9\D3D9TextureCube.cpp:90:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9TextureCube.cpp:97:    cache->ResetDependencies(this);
Direct3D9\D3D9TextureCube.cpp:103:    if (!loadParameters_->Load(source))
Direct3D9\D3D9TextureCube.cpp:111:    XMLElement textureElem = loadParameters_->GetRoot();
Direct3D9\D3D9TextureCube.cpp:122:        SharedPtr<Image> image = cache->GetTempResource<Image>(name);
Direct3D9\D3D9TextureCube.cpp:132:            faceWidth = image->GetWidth() / MAX_CUBEMAP_FACES;
Direct3D9\D3D9TextureCube.cpp:133:            faceHeight = image->GetHeight();
Direct3D9\D3D9TextureCube.cpp:143:            faceWidth = image->GetWidth() / MAX_CUBEMAP_FACES;
Direct3D9\D3D9TextureCube.cpp:144:            faceHeight = image->GetHeight();
Direct3D9\D3D9TextureCube.cpp:150:            faceWidth = image->GetWidth() / 4;
Direct3D9\D3D9TextureCube.cpp:151:            faceHeight = image->GetHeight() / 3;
Direct3D9\D3D9TextureCube.cpp:161:            faceWidth = image->GetWidth() / 3;
Direct3D9\D3D9TextureCube.cpp:162:            faceHeight = image->GetHeight() / 4;
Direct3D9\D3D9TextureCube.cpp:171:                loadImages_[FACE_NEGATIVE_Z]->FlipVertical();
Direct3D9\D3D9TextureCube.cpp:172:                loadImages_[FACE_NEGATIVE_Z]->FlipHorizontal();
Direct3D9\D3D9TextureCube.cpp:177:            faceWidth = image->GetWidth() / 3;
Direct3D9\D3D9TextureCube.cpp:178:            faceHeight = image->GetHeight() / 2;
Direct3D9\D3D9TextureCube.cpp:200:            loadImages_.Push(cache->GetTempResource<Image>(name));
Direct3D9\D3D9TextureCube.cpp:201:            cache->StoreResourceDependency(this, name);
Direct3D9\D3D9TextureCube.cpp:213:                loadImages_[i]->PrecalculateLevels();
Direct3D9\D3D9TextureCube.cpp:223:    if (!graphics_ || graphics_->IsDeviceLost())
Direct3D9\D3D9TextureCube.cpp:252:        if (cache->Exists(GetName()))
Direct3D9\D3D9TextureCube.cpp:253:            dataLost_ = !cache->ReloadResource(this);
Direct3D9\D3D9TextureCube.cpp:274:            if (graphics_->GetTexture(i) == this)
Direct3D9\D3D9TextureCube.cpp:275:                graphics_->SetTexture(i, 0);
Direct3D9\D3D9TextureCube.cpp:281:                renderSurfaces_[i]->Release();
Direct3D9\D3D9TextureCube.cpp:284:        ((IDirect3DCubeTexture9*)object_)->Release();
Direct3D9\D3D9TextureCube.cpp:298:        LOGERROR("Depth-stencil usage not supported for cube maps");
Direct3D9\D3D9TextureCube.cpp:364:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9TextureCube.cpp:396:    if (FAILED(((IDirect3DCubeTexture9*)object_)->LockRect((D3DCUBEMAP_FACES)face, level, &d3dLockedRect, (flags &
Direct3D9\D3D9TextureCube.cpp:412:    // GetRowDataSize() returns CPU-side (source) data size, so need to convert for X8R8G8B8
Direct3D9\D3D9TextureCube.cpp:453:    ((IDirect3DCubeTexture9*)object_)->UnlockRect((D3DCUBEMAP_FACES)face, level);
Direct3D9\D3D9TextureCube.cpp:460:    if (!image->Load(source))
Direct3D9\D3D9TextureCube.cpp:479:        quality = renderer->GetTextureQuality();
Direct3D9\D3D9TextureCube.cpp:481:    if (!image->IsCompressed())
Direct3D9\D3D9TextureCube.cpp:483:        unsigned char* levelData = image->GetData();
Direct3D9\D3D9TextureCube.cpp:484:        int levelWidth = image->GetWidth();
Direct3D9\D3D9TextureCube.cpp:485:        int levelHeight = image->GetHeight();
Direct3D9\D3D9TextureCube.cpp:486:        unsigned components = image->GetComponents();
Direct3D9\D3D9TextureCube.cpp:498:            image = image->GetNextLevel();
Direct3D9\D3D9TextureCube.cpp:499:            levelData = image->GetData();
Direct3D9\D3D9TextureCube.cpp:500:            levelWidth = image->GetWidth();
Direct3D9\D3D9TextureCube.cpp:501:            levelHeight = image->GetHeight();
Direct3D9\D3D9TextureCube.cpp:550:            if (i < levels_ - 1)
Direct3D9\D3D9TextureCube.cpp:552:                image = image->GetNextLevel();
Direct3D9\D3D9TextureCube.cpp:553:                levelData = image->GetData();
Direct3D9\D3D9TextureCube.cpp:554:                levelWidth = image->GetWidth();
Direct3D9\D3D9TextureCube.cpp:555:                levelHeight = image->GetHeight();
Direct3D9\D3D9TextureCube.cpp:561:        int width = image->GetWidth();
Direct3D9\D3D9TextureCube.cpp:562:        int height = image->GetHeight();
Direct3D9\D3D9TextureCube.cpp:563:        unsigned levels = image->GetNumCompressedLevels();
Direct3D9\D3D9TextureCube.cpp:564:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Direct3D9\D3D9TextureCube.cpp:581:            mipsToSkip = levels - 1;
Direct3D9\D3D9TextureCube.cpp:583:            --mipsToSkip;
Direct3D9\D3D9TextureCube.cpp:590:            SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Direct3D9\D3D9TextureCube.cpp:607:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Direct3D9\D3D9TextureCube.cpp:609:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Direct3D9\D3D9TextureCube.cpp:655:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9TextureCube.cpp:671:    if (FAILED(((IDirect3DCubeTexture9*)object_)->LockRect((D3DCUBEMAP_FACES)face, level, &d3dLockedRect, &d3dRect, D3DLOCK_READONLY)))
Direct3D9\D3D9TextureCube.cpp:683:    // GetRowDataSize() returns CPU-side (destination) data size, so need to convert for X8R8G8B8
Direct3D9\D3D9TextureCube.cpp:724:    ((IDirect3DCubeTexture9*)object_)->UnlockRect((D3DCUBEMAP_FACES)face, level);
Direct3D9\D3D9TextureCube.cpp:735:    if (graphics_->IsDeviceLost())
Direct3D9\D3D9TextureCube.cpp:741:    IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Direct3D9\D3D9TextureCube.cpp:742:    if (!device || FAILED(device->CreateCubeTexture(
Direct3D9\D3D9TextureCube.cpp:755:    levels_ = ((IDirect3DCubeTexture9*)object_)->GetLevelCount();
Direct3D9\D3D9TextureCube.cpp:761:            ((IDirect3DCubeTexture9*)object_)->GetCubeMapSurface((D3DCUBEMAP_FACES)i, 0,
Direct3D9\D3D9TextureCube.cpp:762:                (IDirect3DSurface9**)&renderSurfaces_[i]->surface_);
Direct3D9\D3D9TextureCube.cpp:773:        if (renderSurfaces_[i] && renderSurfaces_[i]->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Direct3D9\D3D9TextureCube.cpp:774:            renderSurfaces_[i]->QueueUpdate();
Direct3D9\D3D9VertexBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9VertexBuffer.cpp:105:            if (graphics_->GetVertexBuffer(i) == this)
Direct3D9\D3D9VertexBuffer.cpp:106:                graphics_->SetVertexBuffer(0);
Direct3D9\D3D9VertexBuffer.cpp:109:        ((IDirect3DVertexBuffer9*)object_)->Release();
Direct3D9\D3D9VertexBuffer.cpp:178:        if (graphics_->IsDeviceLost())
Direct3D9\D3D9VertexBuffer.cpp:230:        if (graphics_->IsDeviceLost())
Direct3D9\D3D9VertexBuffer.cpp:277:    if (object_ && !shadowData_ && !graphics_->IsDeviceLost())
Direct3D9\D3D9VertexBuffer.cpp:287:        lockScratchData_ = graphics_->ReserveScratchBuffer(count * vertexSize_);
Direct3D9\D3D9VertexBuffer.cpp:310:            graphics_->FreeScratchBuffer(lockScratchData_);
Direct3D9\D3D9VertexBuffer.cpp:391:        if (graphics_->IsDeviceLost())
Direct3D9\D3D9VertexBuffer.cpp:397:        IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Direct3D9\D3D9VertexBuffer.cpp:398:        if (!device || FAILED(device->CreateVertexBuffer(
Direct3D9\D3D9VertexBuffer.cpp:433:        if (FAILED(((IDirect3DVertexBuffer9*)object_)->Lock(start * vertexSize_, count * vertexSize_, &hwData, flags)))
Direct3D9\D3D9VertexBuffer.cpp:446:        ((IDirect3DVertexBuffer9*)object_)->Unlock();
Direct3D9\D3D9VertexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9VertexBuffer.h:58:    /// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
Direct3D9\D3D9VertexDeclaration.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Direct3D9\D3D9VertexDeclaration.cpp:122:                elementMask = buffers[i]->GetElementMask();
Direct3D9\D3D9VertexDeclaration.cpp:125:                if ((buffers[i]->GetElementMask() & elementMask) != elementMask)
Direct3D9\D3D9VertexDeclaration.cpp:138:                    newElement.offset_ = buffers[i]->GetElementOffset(element);
Direct3D9\D3D9VertexDeclaration.cpp:163:                elementMask = buffers[i]->GetElementMask();
Direct3D9\D3D9VertexDeclaration.cpp:166:                if ((buffers[i]->GetElementMask() & elementMask) != elementMask)
Direct3D9\D3D9VertexDeclaration.cpp:179:                    newElement.offset_ = buffers[i]->GetElementOffset(element);
Direct3D9\D3D9VertexDeclaration.cpp:203:        dest->Stream = i->stream_;
Direct3D9\D3D9VertexDeclaration.cpp:204:        dest->Offset = i->offset_;
Direct3D9\D3D9VertexDeclaration.cpp:205:        dest->Type = d3dElementType[i->element_];
Direct3D9\D3D9VertexDeclaration.cpp:206:        dest->Method = D3DDECLMETHOD_DEFAULT;
Direct3D9\D3D9VertexDeclaration.cpp:207:        dest->Usage = d3dElementUsage[i->element_];
Direct3D9\D3D9VertexDeclaration.cpp:208:        dest->UsageIndex = d3dElementUsageIndex[i->element_];
Direct3D9\D3D9VertexDeclaration.cpp:212:    dest->Stream = 0xff;
Direct3D9\D3D9VertexDeclaration.cpp:213:    dest->Offset = 0;
Direct3D9\D3D9VertexDeclaration.cpp:214:    dest->Type = D3DDECLTYPE_UNUSED;
Direct3D9\D3D9VertexDeclaration.cpp:215:    dest->Method = 0;
Direct3D9\D3D9VertexDeclaration.cpp:216:    dest->Usage = 0;
Direct3D9\D3D9VertexDeclaration.cpp:217:    dest->UsageIndex = 0;
Direct3D9\D3D9VertexDeclaration.cpp:219:    IDirect3DDevice9* device = graphics->GetImpl()->GetDevice();
Direct3D9\D3D9VertexDeclaration.cpp:223:    device->CreateVertexDeclaration(elementArray, &declaration_);
Direct3D9\D3D9VertexDeclaration.cpp:230:        declaration_->Release();
Direct3D9\D3D9VertexDeclaration.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Drawable.cpp:3:// Copyright (c) 2008-2015 the Urho3D project.
Drawable.cpp:116:        result.normal_ = -query.ray_.direction_;
Drawable.cpp:132:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
Drawable.cpp:133:    distance_ = frame.camera_->GetDistance(worldBoundingBox.Center());
Drawable.cpp:142:    float newLodDistance = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
Drawable.cpp:169:        debug->AddBoundingBox(GetWorldBoundingBox(), Color::GREEN, depthTest);
Drawable.cpp:241:            octant_->GetRoot()->QueueUpdate(this);
Drawable.cpp:249:        octant_->GetRoot()->QueueUpdate(this);
Drawable.cpp:268:    return renderer && viewFrameNumber_ == renderer->GetFrameInfo().frameNumber_ && !viewCameras_.Empty();
Drawable.cpp:274:    return renderer && viewFrameNumber_ == renderer->GetFrameInfo().frameNumber_ && (!camera || viewCameras_.Contains(camera));
Drawable.cpp:286:    // If the zone assignment was temporary (inconclusive) set the dirty flag so that it will be re-evaluated on the next frame
Drawable.cpp:330:        lights_[i]->SetIntensitySortValue(box);
Drawable.cpp:341:        for (unsigned i = vertexLights_.Size() - 1; i < vertexLights_.Size(); --i)
Drawable.cpp:343:            if (!vertexLights_[i]->GetPerVertex())
Drawable.cpp:353:        vertexLights_[i]->SetIntensitySortValue(box);
Drawable.cpp:364:        node->AddListener(this);
Drawable.cpp:374:        octant_->GetRoot()->QueueUpdate(this);
Drawable.cpp:390:        Octree* octree = scene->GetComponent<Octree>();
Drawable.cpp:392:            octree->InsertDrawable(this);
Drawable.cpp:407:        Octree* octree = octant_->GetRoot();
Drawable.cpp:409:            octree->CancelUpdate(this);
Drawable.cpp:414:        octant_->RemoveDrawable(this);
Drawable.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Drawable.h:121:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
Drawable.h:150:    /// Set maximum number of per-pixel lights. Default 0 is unlimited.
Drawable.h:163:    /// Return world-space bounding box.
Drawable.h:181:    /// Return maximum number of per-pixel lights.
Drawable.h:196:    /// Set new zone. Zone assignment may optionally be temporary, meaning it needs to be re-evaluated on the next frame.
Drawable.h:200:    /// Set view-space depth bounds.
Drawable.h:206:    /// Sort and limit per-pixel lights to maximum allowed. Convert extra lights into vertex lights.
Drawable.h:208:    /// Sort and limit per-vertex lights to maximum allowed.
Drawable.h:228:    /// Return per-pixel lights.
Drawable.h:230:    /// Return per-vertex lights.
Drawable.h:232:    /// Return the first added per-pixel light.
Drawable.h:234:    /// Return the minimum view-space depth.
Drawable.h:236:    /// Return the maximum view-space depth.
Drawable.h:239:    // Add a per-pixel light affecting the object this frame.
Drawable.h:245:        // Need to store into the light list only if the per-pixel lights are being limited.
Drawable.h:251:    // Add a per-vertex light affecting the object this frame.
Drawable.h:262:    /// Recalculate the world-space bounding box.
Drawable.h:273:    /// World-space bounding box.
Drawable.h:275:    /// Local-space bounding box.
Drawable.h:325:    /// Maximum per-pixel lights.
Drawable.h:329:    /// First per-pixel light added this frame.
Drawable.h:331:    /// Per-pixel lights affecting this drawable.
Drawable.h:333:    /// Per-vertex lights affecting this drawable.
Drawable.h:339:    return lhs->GetSortValue() < rhs->GetSortValue();
DrawableEvents.h:2:// Copyright (c) 2008-2015 the Urho3D project.
DrawableEvents.h:42:    PARAM(P_DATA, Data);                    // User-defined data type
Geometry.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Geometry.cpp:87:            elementMasks_[index] = buffer->GetElementMask();
Geometry.cpp:108:    if (indexBuffer_ && indexStart + indexCount > indexBuffer_->GetIndexCount())
Geometry.cpp:110:        LOGERROR("Illegal draw range " + String(indexStart) + " to " + String(indexStart + indexCount - 1) + ", index buffer has " +
Geometry.cpp:111:            String(indexBuffer_->GetIndexCount()) + " indices");
Geometry.cpp:123:        vertexCount_ = vertexBuffers_[0] ? vertexBuffers_[0]->GetVertexCount() : 0;
Geometry.cpp:126:            indexBuffer_->GetUsedVertexRange(indexStart_, indexCount_, vertexStart_, vertexCount_);
Geometry.cpp:142:        if (checkIllegal && indexStart + indexCount > indexBuffer_->GetIndexCount())
Geometry.cpp:144:            LOGERROR("Illegal draw range " + String(indexStart) + " to " + String(indexStart + indexCount - 1) +
Geometry.cpp:145:                ", index buffer has " + String(indexBuffer_->GetIndexCount()) + " indices");
Geometry.cpp:189:        graphics->SetIndexBuffer(indexBuffer_);
Geometry.cpp:190:        graphics->SetVertexBuffers(vertexBuffers_, elementMasks_);
Geometry.cpp:191:        graphics->Draw(primitiveType_, indexStart_, indexCount_, vertexStart_, vertexCount_);
Geometry.cpp:195:        graphics->SetVertexBuffers(vertexBuffers_, elementMasks_);
Geometry.cpp:196:        graphics->Draw(primitiveType_, vertexStart_, vertexCount_);
Geometry.cpp:239:            vertexData = vertexBuffers_[positionBufferIndex_]->GetShadowData();
Geometry.cpp:242:                vertexSize = vertexBuffers_[positionBufferIndex_]->GetVertexSize();
Geometry.cpp:243:                elementMask = vertexBuffers_[positionBufferIndex_]->GetElementMask();
Geometry.cpp:268:            indexData = indexBuffer_->GetShadowData();
Geometry.cpp:270:                indexSize = indexBuffer_->GetIndexSize();
Geometry.cpp:295:            vertexData = vertexBuffers_[positionBufferIndex_]->GetShadowDataShared();
Geometry.cpp:298:                vertexSize = vertexBuffers_[positionBufferIndex_]->GetVertexSize();
Geometry.cpp:299:                elementMask = vertexBuffers_[positionBufferIndex_]->GetElementMask();
Geometry.cpp:324:            indexData = indexBuffer_->GetShadowDataShared();
Geometry.cpp:326:                indexSize = indexBuffer_->GetIndexSize();
Geometry.cpp:378:        if (vertexBuffers_[i] && vertexBuffers_[i]->GetElementMask() & MASK_POSITION)
GPUObject.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Geometry.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Geometry.h:60:    /// Override raw vertex data to be returned for CPU-side operations.
Geometry.h:62:    /// Override raw index data to be returned for CPU-side operations.
Graphics.h:2:// Copyright (c) 2008-2015 the Urho3D project.
GraphicsDefs.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
GraphicsDefs.h:2:// Copyright (c) 2008-2015 the Urho3D project.
GraphicsDefs.h:33:/// Graphics capability support level. HTML5 (Emscripten) also uses OpenGL ES, but is considered a desktop platform capability-wise
GraphicsEvents.h:2:// Copyright (c) 2008-2015 the Urho3D project.
GraphicsImpl.h:2:// Copyright (c) 2008-2015 the Urho3D project.
IndexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Light.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Light.h:111:    /// The point relative to the total shadow range where shadow fade begins (0.0 - 1.0)
Light.h:140:    /// Non-uniform focusing flag.
Light.h:142:    /// Auto-size (reduce resolution when far away) flag.
Light.h:167:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
Light.h:190:    /// Set shadow fade out start distance. Only has effect if shadow distance is also non-zero.
Light.h:198:    /// Set shadow intensity between 0.0 - 1.0. 0.0 (the default) gives fully dark shadows.
Light.h:200:    /// Set shadow resolution between 0.25 - 1.0. Determines the shadow map to use.
Light.h:279:    /// Recalculate the world-space bounding box.
Light.h:321:    /// Per-vertex lighting flag.
Light.h:327:    // When sorting lights, give priority to per-vertex lights, so that vertex lit base pass can be evaluated first
Light.h:328:    if (lhs->GetPerVertex() != rhs->GetPerVertex())
Light.h:329:        return lhs->GetPerVertex();
Light.h:331:        return lhs->GetSortValue() < rhs->GetSortValue();
Material.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Material.cpp:114:            unit = (TextureUnit)Clamp(ToInt(name), 0, MAX_TEXTURE_UNITS - 1);
Material.cpp:168:    static_cast<Material*>(target_.Get())->SetShaderParameter(name_, newValue);
Material.cpp:189:    context->RegisterFactory<Material>();
Material.cpp:200:    if (loadXMLFile_->Load(source))
Material.cpp:207:            XMLElement rootElem = loadXMLFile_->GetRoot();
Material.cpp:211:                cache->BackgroundLoadResource<Technique>(techniqueElem.GetAttribute("name"), true, this);
Material.cpp:228:                        cache->BackgroundLoadResource<Texture3D>(name, true, this);
Material.cpp:231:                        cache->BackgroundLoadResource<TextureCube>(name, true, this);
Material.cpp:234:                    cache->BackgroundLoadResource<Texture2D>(name, true, this);
Material.cpp:260:        XMLElement rootElem = loadXMLFile_->GetRoot();
Material.cpp:272:    XMLElement materialElem = xml->CreateRoot("material");
Material.cpp:275:    return xml->Save(dest);
Material.cpp:295:        Technique* tech = cache->GetResource<Technique>(techniqueElem.GetAttribute("name"));
Material.cpp:327:                    SetTexture(unit, cache->GetResource<Texture3D>(name));
Material.cpp:330:                    SetTexture(unit, cache->GetResource<TextureCube>(name));
Material.cpp:333:                SetTexture(unit, cache->GetResource<Texture2D>(name));
Material.cpp:353:        if (!animation->LoadXML(parameterAnimationElem))
Material.cpp:414:        techniqueElem.SetString("name", entry.technique_->GetName());
Material.cpp:427:            textureElem.SetString("name", texture->GetName());
Material.cpp:435:        parameterElem.SetString("name", j->second_.name_);
Material.cpp:436:        parameterElem.SetVectorVariant("value", j->second_.value_);
Material.cpp:442:        ShaderParameterAnimationInfo* info = j->second_;
Material.cpp:444:        parameterAnimationElem.SetString("name", info->GetName());
Material.cpp:445:        if (!info->GetAnimation()->SaveXML(parameterAnimationElem))
Material.cpp:448:        parameterAnimationElem.SetAttribute("wrapmode", wrapModeNames[info->GetWrapMode()]);
Material.cpp:449:        parameterAnimationElem.SetFloat("speed", info->GetSpeed());
Material.cpp:525:        if (info && info->GetAnimation() == animation)
Material.cpp:527:            info->SetWrapMode(wrapMode);
Material.cpp:528:            info->SetSpeed(speed);
Material.cpp:557:        info->SetWrapMode(wrapMode);
Material.cpp:564:        info->SetSpeed(speed);
Material.cpp:583:    transform.m03_ = -0.5f * transform.m00_ + 0.5f;
Material.cpp:584:    transform.m13_ = -0.5f * transform.m11_ + 0.5f;
Material.cpp:589:    rotationMatrix.m10_ = -rotationMatrix.m01_;
Material.cpp:591:    rotationMatrix.m03_ = 0.5f - 0.5f * (rotationMatrix.m00_ + rotationMatrix.m01_);
Material.cpp:592:    rotationMatrix.m13_ = 0.5f - 0.5f * (rotationMatrix.m10_ + rotationMatrix.m11_);
Material.cpp:659:            tech->ReleaseShaders();
Material.cpp:667:    ret->SetName(cloneName);
Material.cpp:668:    ret->techniques_ = techniques_;
Material.cpp:669:    ret->shaderParameters_ = shaderParameters_;
Material.cpp:670:    ret->textures_ = textures_;
Material.cpp:671:    ret->occlusion_ = occlusion_;
Material.cpp:672:    ret->specular_ = specular_;
Material.cpp:673:    ret->cullMode_ = cullMode_;
Material.cpp:674:    ret->shadowCullMode_ = shadowCullMode_;
Material.cpp:675:    ret->fillMode_ = fillMode_;
Material.cpp:676:    ret->RefreshMemoryUse();
Material.cpp:704:    return tech ? tech->GetPass(passName) : 0;
Material.cpp:710:    return i != textures_.End() ? i->second_.Get() : (Texture*)0;
Material.cpp:716:    return i != shaderParameters_.End() ? i->second_.value_ : Variant::EMPTY;
Material.cpp:722:    return info == 0 ? 0 : info->GetAnimation();
Material.cpp:728:    return info == 0 ? WM_LOOP : info->GetWrapMode();
Material.cpp:734:    return info == 0 ? 0 : info->GetSpeed();
Material.cpp:765:            Pass* pass = tech->GetPass("base");
Material.cpp:766:            if (pass && pass->GetDepthWrite() && !pass->GetAlphaMask())
Material.cpp:774:    // Needs to be a no-op when async loading, as this does a GetResource() which is not allowed from worker threads
Material.cpp:779:    SetTechnique(0, GetSubsystem<ResourceCache>()->GetResource<Technique>("Techniques/NoTexture.xml"));
Material.cpp:807:        temp.WriteStringHash(i->first_);
Material.cpp:808:        temp.WriteVariant(i->second_.value_);
Material.cpp:835:    return i->second_;
Material.cpp:864:        if (i->second_->Update(timeStep))
Material.cpp:865:            finishedNames.Push(i->second_->GetName());
Material.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Material.h:207:    /// Parse a shader parameter value from a string. Retunrs either a bool, a float, or a 2 to 4-component vector.
Material.h:211:    /// Re-evaluate occlusion rendering.
Model.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Model.h:127:    /// Set local-space bounding box.
Model.h:147:    /// Clone the model. The geometry data is deep-copied and can be modified in the clone without affecting the original.
OcclusionBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OcclusionBuffer.h:81:    /// Draw a triangle mesh to the buffer using non-indexed geometry.
Light.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Light.cpp:66:    constantBias_ = Clamp(constantBias_, -1.0f, 1.0f);
Light.cpp:67:    slopeScaledBias_ = Clamp(slopeScaledBias_, -16.0f, 16.0f);
Light.cpp:110:    context->RegisterFactory<Light>(SCENE_CATEGORY);
Light.cpp:132:    ATTRIBUTE("Non-uniform View", bool, shadowFocus_.nonUniform_, true, AM_DEFAULT);
Light.cpp:133:    ATTRIBUTE("Auto-Reduce Size", bool, shadowFocus_.autoSize_, true, AM_DEFAULT);
Light.cpp:174:            Matrix3x4 inverse(node_->GetWorldTransform().Inverse());
Light.cpp:191:            distance = query.ray_.HitDistance(Sphere(node_->GetWorldPosition(), range_));
Light.cpp:201:    result.normal_ = -query.ray_.direction_;
Light.cpp:219:        distance_ = frame.camera_->GetDistance(node_->GetWorldPosition());
Light.cpp:234:                Vector3 start = node_->GetWorldPosition();
Light.cpp:235:                Vector3 end = start + node_->GetWorldDirection() * 10.f;
Light.cpp:236:                for (int i = -1; i < 2; ++i)
Light.cpp:238:                    for (int j = -1; j < 2; ++j)
Light.cpp:241:                        debug->AddSphere(Sphere(start + offset, 0.1f), color, depthTest);
Light.cpp:242:                        debug->AddLine(start + offset, end + offset, color, depthTest);
Light.cpp:249:            debug->AddFrustum(GetFrustum(), color, depthTest);
Light.cpp:253:            debug->AddSphere(Sphere(node_->GetWorldPosition(), range_), color, depthTest);
Light.cpp:377:    Matrix3x4 frustumTransform(node_ ? Matrix3x4(node_->GetWorldPosition(), node_->GetWorldRotation(), 1.0f) :
Light.cpp:414:            camera->GetFrustumSize(near, far);
Light.cpp:415:            quadTransform.SetTranslation(Vector3(0.0f, 0.0f, (camera->GetNearClip() + camera->GetFarClip()) * 0.5f));
Light.cpp:417:            volumeTransform_ = camera->GetEffectiveWorldTransform() * quadTransform;
Light.cpp:425:            volumeTransform_ = Matrix3x4(node_->GetWorldPosition(), node_->GetWorldRotation(), Vector3(xScale, yScale, range_));
Light.cpp:430:        volumeTransform_ = Matrix3x4(node_->GetWorldPosition(), Quaternion::IDENTITY, range_);
Light.cpp:440:    rampTexture_ = static_cast<Texture*>(cache->GetResource(value.type_, value.name_));
Light.cpp:446:    shapeTexture_ = static_cast<Texture*>(cache->GetResource(value.type_, value.name_));
Light.cpp:465:        worldBoundingBox_.Define(-M_LARGE_VALUE, M_LARGE_VALUE);
Light.cpp:475:            const Vector3& center = node_->GetWorldPosition();
Light.cpp:477:            worldBoundingBox_.Define(center - edge, center + edge);
Light.cpp:498:            sortValue_ = -Max(distance, M_MIN_NEARCLIP) * GetIntensityDivisor();
Light.cpp:500:            sortValue_ = -M_LARGE_VALUE * GetIntensityDivisor();
Light.cpp:516:            Vector3 lightPos = node_->GetWorldPosition();
Light.cpp:517:            Vector3 lightDir = node_->GetWorldDirection();
Light.cpp:521:            float centerDistance = (centerProj - lightPos).Length();
Light.cpp:522:            Ray centerRay(centerProj, centerPos - centerProj);
Light.cpp:526:            Vector3 cornerPos = centerPos + box.HalfSize() * Vector3(centerPos.x_ < centerProj.x_ ? 1.0f : -1.0f,
Light.cpp:527:                centerPos.y_ < centerProj.y_ ? 1.0f : -1.0f, centerPos.z_ < centerProj.z_ ? 1.0f : -1.0f);
Light.cpp:529:            float cornerDistance = (cornerProj - lightPos).Length();
Light.cpp:530:            float cornerAngle = (cornerPos - cornerProj).Length() / cornerDistance;
Light.cpp:536:            float att = Max(1.0f - spotFactor * spotFactor, M_EPSILON);
Light.cpp:544:            Vector3 lightPos = node_->GetWorldPosition();
Light.cpp:545:            Vector3 lightDir = (centerPos - lightPos).Normalized();
Light.cpp:549:            float att = Max(1.0f - normDistance * normDistance, M_EPSILON);
OcclusionBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OcclusionBuffer.cpp:110:    view_ = camera->GetView();
OcclusionBuffer.cpp:111:    projection_ = camera->GetProjection(false);
OcclusionBuffer.cpp:113:    nearClip_ = camera->GetNearClip();
OcclusionBuffer.cpp:114:    farClip_ = camera->GetFarClip();
OcclusionBuffer.cpp:115:    reverseCulling_ = camera->GetReverseCulling();
OcclusionBuffer.cpp:151:    while (count--)
OcclusionBuffer.cpp:167:    // 16-bit indices
OcclusionBuffer.cpp:200:    // 16-bit indices
OcclusionBuffer.cpp:254:    // Build the first mip level from the pixel-level data
OcclusionBuffer.cpp:272:                    dest->min_ = Min(minUpper, minLower);
OcclusionBuffer.cpp:275:                    dest->max_ = Max(maxUpper, maxLower);
OcclusionBuffer.cpp:286:                    dest->min_ = Min(src[0], src[1]);
OcclusionBuffer.cpp:287:                    dest->max_ = Max(src[0], src[1]);
OcclusionBuffer.cpp:306:            DepthValue* src = mipBuffers_[i - 1].Get() + (y * 2) * prevWidth;
OcclusionBuffer.cpp:317:                    dest->min_ = Min(minUpper, minLower);
OcclusionBuffer.cpp:320:                    dest->max_ = Max(maxUpper, maxLower);
OcclusionBuffer.cpp:331:                    dest->min_ = Min(src[0].min_, src[1].min_);
OcclusionBuffer.cpp:332:                    dest->max_ = Max(src[0].max_, src[1].max_);
OcclusionBuffer.cpp:367:        vertices[i].z_ -= OCCLUSION_RELATIVE_BIAS;
OcclusionBuffer.cpp:397:        (int)(minX - 1.5f), (int)(minY - 1.5f),
OcclusionBuffer.cpp:413:        rect.right_ = width_ - 1;
OcclusionBuffer.cpp:415:        rect.bottom_ = height_ - 1;
OcclusionBuffer.cpp:418:    int z = (int)(minZ + 0.5f) - OCCLUSION_FIXED_BIAS;
OcclusionBuffer.cpp:423:        for (int i = mipBuffers_.Size() - 1; i >= 0; --i)
OcclusionBuffer.cpp:441:                    if (z <= src->min_)
OcclusionBuffer.cpp:443:                    if (z <= src->max_)
OcclusionBuffer.cpp:455:    // If no conclusive result, finally check the pixel-level data
OcclusionBuffer.cpp:501:    float t = d0 / (d0 - d1);
OcclusionBuffer.cpp:502:    return v0 + t * (v1 - v0);
OcclusionBuffer.cpp:507:    float aX = v0.x_ - v1.x_;
OcclusionBuffer.cpp:508:    float aY = v0.y_ - v1.y_;
OcclusionBuffer.cpp:509:    float bX = v2.x_ - v1.x_;
OcclusionBuffer.cpp:510:    float bY = v2.y_ - v1.y_;
OcclusionBuffer.cpp:511:    return aX * bY - aY * bX;
OcclusionBuffer.cpp:518:    scaleY_ = -0.5f * height_;
OcclusionBuffer.cpp:539:        if (vertices[i].x_ < -vertices[i].w_)
OcclusionBuffer.cpp:543:        if (vertices[i].y_ < -vertices[i].w_)
OcclusionBuffer.cpp:585:            ClipVertices(Vector4(-1.0f, 0.0f, 0.0f, 1.0f), vertices, triangles, numTriangles);
OcclusionBuffer.cpp:589:            ClipVertices(Vector4(0.0f, -1.0f, 0.0f, 1.0f), vertices, triangles, numTriangles);
OcclusionBuffer.cpp:593:            ClipVertices(Vector4(0.0f, 0.0f, -1.0f, 1.0f), vertices, triangles, numTriangles);
OcclusionBuffer.cpp:640:            // If 2 vertices behind the plane, create a new triangle in-place
OcclusionBuffer.cpp:656:            // 1 vertex behind the plane: create one new triangle, and modify one in-place
OcclusionBuffer.cpp:700:        float invdX = 1.0f / (((vertices[1].x_ - vertices[2].x_) *
OcclusionBuffer.cpp:701:            (vertices[0].y_ - vertices[2].y_)) -
OcclusionBuffer.cpp:702:            ((vertices[0].x_ - vertices[2].x_) *
OcclusionBuffer.cpp:703:            (vertices[1].y_ - vertices[2].y_)));
OcclusionBuffer.cpp:705:        float invdY = -invdX;
OcclusionBuffer.cpp:707:        dInvZdX_ = invdX * (((vertices[1].z_ - vertices[2].z_) * (vertices[0].y_ - vertices[2].y_)) -
OcclusionBuffer.cpp:708:            ((vertices[0].z_ - vertices[2].z_) * (vertices[1].y_ - vertices[2].y_)));
OcclusionBuffer.cpp:710:        dInvZdY_ = invdY * (((vertices[1].z_ - vertices[2].z_) * (vertices[0].x_ - vertices[2].x_)) -
OcclusionBuffer.cpp:711:            ((vertices[0].z_ - vertices[2].z_) * (vertices[1].x_ - vertices[2].x_)));
OcclusionBuffer.cpp:730:        float height = (bottom.y_ - top.y_);
OcclusionBuffer.cpp:731:        float slope = (height != 0.0f) ? (bottom.x_ - top.x_) / height : 0.0f;
OcclusionBuffer.cpp:732:        float yPreStep = (float)(topY + 1) - top.y_;
OcclusionBuffer.cpp:756:    // Sort vertices in Y-direction
Model.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Model.cpp:72:    context->RegisterFactory<Model>();
Model.cpp:123:            buffer->SetShadowed(true);
Model.cpp:124:            buffer->SetSize(vertexCount, elementMask);
Model.cpp:125:            void* dest = buffer->Lock(0, vertexCount);
Model.cpp:127:            buffer->Unlock();
Model.cpp:158:            buffer->SetShadowed(true);
Model.cpp:159:            buffer->SetSize(indexCount, indexSize > sizeof(unsigned short));
Model.cpp:160:            void* dest = buffer->Lock(0, indexCount);
Model.cpp:162:            buffer->Unlock();
Model.cpp:217:            geometry->SetLodDistance(distance);
Model.cpp:302:            buffer->SetShadowed(true);
Model.cpp:303:            buffer->SetSize(desc.vertexCount_, desc.elementMask_);
Model.cpp:304:            buffer->SetData(desc.data_.Get());
Model.cpp:315:            buffer->SetShadowed(true);
Model.cpp:316:            buffer->SetSize(desc.indexCount_, desc.indexSize_ > sizeof(unsigned short));
Model.cpp:317:            buffer->SetData(desc.data_.Get());
Model.cpp:328:            geometry->SetVertexBuffer(0, vertexBuffers_[desc.vbRef_]);
Model.cpp:329:            geometry->SetIndexBuffer(indexBuffers_[desc.ibRef_]);
Model.cpp:330:            geometry->SetDrawRange(desc.type_, desc.indexStart_, desc.indexCount_);
Model.cpp:351:        dest.WriteUInt(buffer->GetVertexCount());
Model.cpp:352:        dest.WriteUInt(buffer->GetElementMask());
Model.cpp:355:        dest.Write(buffer->GetShadowData(), buffer->GetVertexCount() * buffer->GetVertexSize());
Model.cpp:362:        dest.WriteUInt(buffer->GetIndexCount());
Model.cpp:363:        dest.WriteUInt(buffer->GetIndexSize());
Model.cpp:364:        dest.Write(buffer->GetShadowData(), buffer->GetIndexCount() * buffer->GetIndexSize());
Model.cpp:380:            dest.WriteFloat(geometry->GetLodDistance());
Model.cpp:381:            dest.WriteUInt(geometry->GetPrimitiveType());
Model.cpp:382:            dest.WriteUInt(LookupVertexBuffer(geometry->GetVertexBuffer(0), vertexBuffers_));
Model.cpp:383:            dest.WriteUInt(LookupIndexBuffer(geometry->GetIndexBuffer(), indexBuffers_));
Model.cpp:384:            dest.WriteUInt(geometry->GetIndexStart());
Model.cpp:385:            dest.WriteUInt(geometry->GetIndexCount());
Model.cpp:400:            dest.WriteUInt(j->first_);
Model.cpp:401:            dest.WriteUInt(j->second_.elementMask_);
Model.cpp:402:            dest.WriteUInt(j->second_.vertexCount_);
Model.cpp:407:            if (j->second_.elementMask_ & MASK_POSITION)
Model.cpp:409:            if (j->second_.elementMask_ & MASK_NORMAL)
Model.cpp:411:            if (j->second_.elementMask_ & MASK_TANGENT)
Model.cpp:414:            dest.Write(j->second_.morphData_.Get(), vertexSize * j->second_.vertexCount_);
Model.cpp:445:        if (!buffers[i]->IsShadowed())
Model.cpp:475:        if (!buffers[i]->IsShadowed())
Model.cpp:492:    // For easier creation of from-scratch geometry, ensure that all geometries start with at least 1 LOD level (0 makes no sense)
Model.cpp:565:    ret->SetName(cloneName);
Model.cpp:566:    ret->boundingBox_ = boundingBox_;
Model.cpp:567:    ret->skeleton_ = skeleton_;
Model.cpp:568:    ret->geometryBoneMappings_ = geometryBoneMappings_;
Model.cpp:569:    ret->geometryCenters_ = geometryCenters_;
Model.cpp:570:    ret->morphs_ = morphs_;
Model.cpp:571:    ret->morphRangeStarts_ = morphRangeStarts_;
Model.cpp:572:    ret->morphRangeCounts_ = morphRangeCounts_;
Model.cpp:584:            cloneBuffer->SetSize(origBuffer->GetVertexCount(), origBuffer->GetElementMask(), origBuffer->IsDynamic());
Model.cpp:585:            cloneBuffer->SetShadowed(origBuffer->IsShadowed());
Model.cpp:586:            if (origBuffer->IsShadowed())
Model.cpp:587:                cloneBuffer->SetData(origBuffer->GetShadowData());
Model.cpp:590:                void* origData = origBuffer->Lock(0, origBuffer->GetVertexCount());
Model.cpp:592:                    cloneBuffer->SetData(origData);
Model.cpp:599:        ret->vertexBuffers_.Push(cloneBuffer);
Model.cpp:611:            cloneBuffer->SetSize(origBuffer->GetIndexCount(), origBuffer->GetIndexSize() == sizeof(unsigned), origBuffer->IsDynamic());
Model.cpp:612:            cloneBuffer->SetShadowed(origBuffer->IsShadowed());
Model.cpp:613:            if (origBuffer->IsShadowed())
Model.cpp:614:                cloneBuffer->SetData(origBuffer->GetShadowData());
Model.cpp:617:                void* origData = origBuffer->Lock(0, origBuffer->GetIndexCount());
Model.cpp:619:                    cloneBuffer->SetData(origData);
Model.cpp:626:        ret->indexBuffers_.Push(cloneBuffer);
Model.cpp:630:    ret->geometries_.Resize(geometries_.Size());
Model.cpp:633:        ret->geometries_[i].Resize(geometries_[i].Size());
Model.cpp:642:                cloneGeometry->SetIndexBuffer(ibMapping[origGeometry->GetIndexBuffer()]);
Model.cpp:643:                unsigned numVbs = origGeometry->GetNumVertexBuffers();
Model.cpp:646:                    cloneGeometry->SetVertexBuffer(k, vbMapping[origGeometry->GetVertexBuffer(k)],
Model.cpp:647:                        origGeometry->GetVertexElementMask(k));
Model.cpp:649:                cloneGeometry->SetDrawRange(origGeometry->GetPrimitiveType(), origGeometry->GetIndexStart(),
Model.cpp:650:                    origGeometry->GetIndexCount(), origGeometry->GetVertexStart(), origGeometry->GetVertexCount(), false);
Model.cpp:651:                cloneGeometry->SetLodDistance(origGeometry->GetLodDistance());
Model.cpp:654:            ret->geometries_[i][j] = cloneGeometry;
Model.cpp:660:    for (Vector<ModelMorph>::Iterator i = ret->morphs_.Begin(); i != ret->morphs_.End(); ++i)
Model.cpp:665:            VertexBufferMorph& vbMorph = j->second_;
Model.cpp:675:    ret->SetMemoryUse(GetMemoryUse());
Model.cpp:691:        lodLevel = geometries_[index].Size() - 1;
Model.cpp:710:        if (i->nameHash_ == nameHash)
Octree.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Octree.h:59:        drawable->SetOctant(this);
Octree.h:70:                drawable->SetOctant(0);
Octree.h:75:    /// Return world-space bounding box.
Octree.h:110:            parent_->IncDrawableCount();
Octree.h:118:        --numDrawables_;
Octree.h:122:                parent->DeleteChild(index_);
Octree.h:126:            parent->DecDrawableCount();
OctreeQuery.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OctreeQuery.cpp:44:        if ((drawable->GetDrawableFlags() & drawableFlags_) && (drawable->GetViewMask() & viewMask_))
OctreeQuery.cpp:46:            if (inside || drawable->GetWorldBoundingBox().IsInside(point_))
OctreeQuery.cpp:66:        if ((drawable->GetDrawableFlags() & drawableFlags_) && (drawable->GetViewMask() & viewMask_))
OctreeQuery.cpp:68:            if (inside || sphere_.IsInsideFast(drawable->GetWorldBoundingBox()))
OctreeQuery.cpp:88:        if ((drawable->GetDrawableFlags() & drawableFlags_) && (drawable->GetViewMask() & viewMask_))
OctreeQuery.cpp:90:            if (inside || box_.IsInsideFast(drawable->GetWorldBoundingBox()))
OctreeQuery.cpp:110:        if ((drawable->GetDrawableFlags() & drawableFlags_) && (drawable->GetViewMask() & viewMask_))
OctreeQuery.cpp:112:            if (inside || frustum_.IsInsideFast(drawable->GetWorldBoundingBox()))
Octree.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Octree.cpp:53:    Octree* octree = reinterpret_cast<Octree*>(item->aux_);
Octree.cpp:54:    Drawable** start = reinterpret_cast<Drawable**>(item->start_);
Octree.cpp:55:    Drawable** end = reinterpret_cast<Drawable**>(item->end_);
Octree.cpp:56:    const RayOctreeQuery& query = *octree->rayQuery_;
Octree.cpp:57:    PODVector<RayQueryResult>& results = octree->rayQueryResults_[threadIndex];
Octree.cpp:62:        drawable->ProcessRayQuery(query, results);
Octree.cpp:69:    const FrameInfo& frame = *(reinterpret_cast<FrameInfo*>(item->aux_));
Octree.cpp:70:    Drawable** start = reinterpret_cast<Drawable**>(item->start_);
Octree.cpp:71:    Drawable** end = reinterpret_cast<Drawable**>(item->end_);
Octree.cpp:77:            drawable->Update(frame);
Octree.cpp:107:            (*i)->SetOctant(root_);
Octree.cpp:108:            root_->drawables_.Push(*i);
Octree.cpp:109:            root_->QueueUpdate(*i);
Octree.cpp:156:    const BoundingBox& box = drawable->GetWorldBoundingBox();
Octree.cpp:158:    // If root octant, insert all non-occludees here, so that octant occlusion does not hide the drawable.
Octree.cpp:162:        insertHere = !drawable->IsOccludee() || cullingBox_.IsInside(box) != INSIDE || CheckDrawableFit(box);
Octree.cpp:168:        Octant* oldOctant = drawable->octant_;
Octree.cpp:174:                oldOctant->RemoveDrawable(drawable, false);
Octree.cpp:184:        GetOrCreateChild(x + y + z)->InsertDrawable(drawable);
Octree.cpp:193:    if (level_ >= root_->GetNumLevels() || boxSize.x_ >= halfSize_.x_ || boxSize.y_ >= halfSize_.y_ ||
Octree.cpp:199:        if (box.min_.x_ <= worldBoundingBox_.min_.x_ - 0.5f * halfSize_.x_ ||
Octree.cpp:201:            box.min_.y_ <= worldBoundingBox_.min_.y_ - 0.5f * halfSize_.y_ ||
Octree.cpp:203:            box.min_.z_ <= worldBoundingBox_.min_.z_ - 0.5f * halfSize_.z_ ||
Octree.cpp:218:        (*i)->SetOctant(0);
Octree.cpp:223:            children_[i]->ResetRoot();
Octree.cpp:229:    if (debug && debug->IsInside(worldBoundingBox_))
Octree.cpp:231:        debug->AddBoundingBox(worldBoundingBox_, Color(0.25f, 0.25f, 0.25f), depthTest);
Octree.cpp:236:                children_[i]->DrawDebugGeometry(debug, depthTest);
Octree.cpp:246:    cullingBox_ = BoundingBox(worldBoundingBox_.min_ - halfSize_, worldBoundingBox_.max_ + halfSize_);
Octree.cpp:273:            children_[i]->GetDrawablesInternal(query, inside);
Octree.cpp:292:            if ((drawable->GetDrawableFlags() & query.drawableFlags_) && (drawable->GetViewMask() & query.viewMask_))
Octree.cpp:293:                drawable->ProcessRayQuery(query, query.result_);
Octree.cpp:300:            children_[i]->GetDrawablesInternal(query);
Octree.cpp:319:            if ((drawable->GetDrawableFlags() & query.drawableFlags_) && (drawable->GetViewMask() & query.viewMask_))
Octree.cpp:327:            children_[i]->GetDrawablesOnlyInternal(query, drawables);
Octree.cpp:333:    Octant(BoundingBox(-DEFAULT_OCTREE_SIZE, DEFAULT_OCTREE_SIZE), 0, 0, this),
Octree.cpp:338:    rayQueryResults_.Resize(workQueue ? workQueue->GetNumThreads() + 1 : 1);
Octree.cpp:356:    context->RegisterFactory<Octree>(SUBSYSTEM_CATEGORY);
Octree.cpp:358:    Vector3 defaultBoundsMin = -Vector3::ONE * DEFAULT_OCTREE_SIZE;
Octree.cpp:404:        // (for example physics objects) should not perform non-threadsafe work when marked dirty
Octree.cpp:407:        scene->BeginThreadedUpdate();
Octree.cpp:409:        int numWorkItems = queue->GetNumThreads() + 1; // Worker threads + main thread
Octree.cpp:416:            SharedPtr<WorkItem> item = queue->GetFreeItem();
Octree.cpp:417:            item->priority_ = M_MAX_UNSIGNED;
Octree.cpp:418:            item->workFunction_ = UpdateDrawablesWork;
Octree.cpp:419:            item->aux_ = const_cast<FrameInfo*>(&frame);
Octree.cpp:422:            if (i < numWorkItems - 1 && end - start > drawablesPerItem)
Octree.cpp:425:            item->start_ = &(*start);
Octree.cpp:426:            item->end_ = &(*end);
Octree.cpp:427:            queue->AddWorkItem(item);
Octree.cpp:432:        queue->Complete(M_MAX_UNSIGNED);
Octree.cpp:433:        scene->EndThreadedUpdate();
Octree.cpp:445:        scene->SendEvent(E_SCENEDRAWABLEUPDATEFINISHED, eventData);
Octree.cpp:457:            drawable->updateQueued_ = false;
Octree.cpp:458:            Octant* octant = drawable->GetOctant();
Octree.cpp:459:            const BoundingBox& box = drawable->GetWorldBoundingBox();
Octree.cpp:462:            if (!octant || octant->GetRoot() != this)
Octree.cpp:465:            if (drawable->IsOccludee() && octant->GetCullingBox().IsInside(box) == INSIDE && octant->CheckDrawableFit(box))
Octree.cpp:472:            octant = drawable->GetOctant();
Octree.cpp:473:            if (octant != this && octant->GetCullingBox().IsInside(box) != INSIDE)
Octree.cpp:476:                    " octant box " + octant->GetCullingBox().ToString());
Octree.cpp:487:    if (!drawable || drawable->GetOctant())
Octree.cpp:498:    Octant* octant = drawable->GetOctant();
Octree.cpp:499:    if (octant && octant->GetRoot() == this)
Octree.cpp:500:        octant->RemoveDrawable(drawable);
Octree.cpp:517:    // If no worker threads or no triangle-level testing, do not create work items
Octree.cpp:518:    if (!queue->GetNumThreads() || query.level_ < RAY_TRIANGLE)
Octree.cpp:536:                SharedPtr<WorkItem> item = queue->GetFreeItem();
Octree.cpp:537:                item->priority_ = M_MAX_UNSIGNED;
Octree.cpp:538:                item->workFunction_ = RaycastDrawablesWork;
Octree.cpp:539:                item->aux_ = const_cast<Octree*>(this);
Octree.cpp:542:                if (end - start > RAYCASTS_PER_WORK_ITEM)
Octree.cpp:545:                item->start_ = &(*start);
Octree.cpp:546:                item->end_ = &(*end);
Octree.cpp:547:                queue->AddWorkItem(item);
Octree.cpp:552:            // Merge per-thread results
Octree.cpp:553:            queue->Complete(M_MAX_UNSIGNED);
Octree.cpp:560:                (*i)->ProcessRayQuery(query, query.result_);
Octree.cpp:579:        drawable->SetSortValue(query.ray_.HitDistance(drawable->GetWorldBoundingBox()));
Octree.cpp:584:    // Then do the actual test according to the query, and early-out as possible
Octree.cpp:589:        if (drawable->GetSortValue() < Min(closestHit, query.maxDistance_))
Octree.cpp:592:            drawable->ProcessRayQuery(query, query.result_);
Octree.cpp:610:    if (scene && scene->IsThreadedUpdate())
Octree.cpp:618:    drawable->updateQueued_ = true;
Octree.cpp:624:    drawable->updateQueued_ = false;
Octree.cpp:637:    if (!scene || !scene->IsUpdateEnabled())
Octree.cpp:643:    frame.frameNumber_ = GetSubsystem<Time>()->GetFrameNumber();
OctreeQuery.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OctreeQuery.h:199:    /// Hit normal in world space. Negation of ray direction if per-triangle data not available.
OpenGL\OGLConstantBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLConstantBuffer.cpp:53:        graphics_->SetUBO(0);
OpenGL\OGLConstantBuffer.cpp:73:        LOGERROR("Can not create zero-sized constant buffer");
OpenGL\OGLConstantBuffer.cpp:91:        graphics_->SetUBO(object_);
OpenGL\OGLConstantBuffer.cpp:116:    while (rows--)
OpenGL\OGLConstantBuffer.cpp:132:        graphics_->SetUBO(object_);
OpenGL\OGLConstantBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLConstantBuffer.h:49:    /// Set size and create GPU-side buffer. Return true on success.
OpenGL\OGLGPUObject.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLGPUObject.cpp:38:        graphics->AddGPUObject(this);
OpenGL\OGLGPUObject.cpp:44:        graphics_->RemoveGPUObject(this);
OpenGL\OGLGPUObject.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLGraphicsImpl.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLGraphicsImpl.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLGraphicsImpl.h:96:/// %Graphics subsystem implementation. Holds API-specific objects.
OpenGL\OGLGraphics.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLGraphics.h:59:/// CPU-side scratch buffer for vertex data updates.
OpenGL\OGLGraphics.h:107:    /// Set allowed screen orientations as a space-separated list of "LandscapeLeft", "LandscapeRight", "Portrait" and "PortraitUpsideDown". Affects currently only iOS platform.
OpenGL\OGLGraphics.h:123:    /// Draw non-indexed geometry.
OpenGL\OGLGraphics.h:181:    /// Reset all rendertargets, depth-stencil surface and viewport.
OpenGL\OGLGraphics.h:185:    /// Reset depth-stencil surface.
OpenGL\OGLGraphics.h:191:    /// Set depth-stencil surface.
OpenGL\OGLGraphics.h:193:    /// Set depth-stencil surface.
OpenGL\OGLGraphics.h:228:    /// Return graphics implementation, which holds the actual API-specific resources.
OpenGL\OGLGraphics.h:230:    /// Return OS-specific external window handle. Null if not in use.
OpenGL\OGLGraphics.h:272:    /// Return 24-bit shadow map depth texture format, or 0 if not supported.
OpenGL\OGLGraphics.h:276:    /// Return whether light pre-pass rendering is supported.
OpenGL\OGLGraphics.h:322:    /// Return depth-stencil surface.
OpenGL\OGLGraphics.h:324:    /// Return readable depth-stencil texture. Not created automatically on OpenGL.
OpenGL\OGLGraphics.h:379:    /// Reserve a CPU-side scratch buffer.
OpenGL\OGLGraphics.h:381:    /// Free a CPU-side scratch buffer.
OpenGL\OGLGraphics.h:406:    /// Return the API-specific alpha texture format.
OpenGL\OGLGraphics.h:408:    /// Return the API-specific luminance texture format.
OpenGL\OGLGraphics.h:410:    /// Return the API-specific luminance alpha texture format.
OpenGL\OGLGraphics.h:412:    /// Return the API-specific RGB texture format.
OpenGL\OGLGraphics.h:414:    /// Return the API-specific RGBA texture format.
OpenGL\OGLGraphics.h:416:    /// Return the API-specific RGBA 16-bit texture format.
OpenGL\OGLGraphics.h:418:    /// Return the API-specific RGBA 16-bit float texture format.
OpenGL\OGLGraphics.h:420:    /// Return the API-specific RGBA 32-bit float texture format.
OpenGL\OGLGraphics.h:422:    /// Return the API-specific RG 16-bit texture format.
OpenGL\OGLGraphics.h:424:    /// Return the API-specific RG 16-bit float texture format.
OpenGL\OGLGraphics.h:426:    /// Return the API-specific RG 32-bit float texture format.
OpenGL\OGLGraphics.h:428:    /// Return the API-specific single channel 16-bit float texture format.
OpenGL\OGLGraphics.h:430:    /// Return the API-specific single channel 32-bit float texture format.
OpenGL\OGLGraphics.h:432:    /// Return the API-specific linear depth texture format.
OpenGL\OGLGraphics.h:434:    /// Return the API-specific hardware depth-stencil texture format.
OpenGL\OGLGraphics.h:436:    /// Return the API-specific readable hardware depth format, or 0 if not supported.
OpenGL\OGLGraphics.h:438:    /// Return the API-specific texture format from a textual description, for example "rgb".
OpenGL\OGLGraphics.h:539:    /// Shadow map 24-bit depth texture format.
OpenGL\OGLGraphics.h:569:    /// Depth-stencil surface in use.
OpenGL\OGLGraphics.h:595:    /// Current custom clip plane in post-projection space.
OpenGL\OGLIndexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLIndexBuffer.h:57:    /// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
OpenGL\OGLIndexBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLIndexBuffer.cpp:80:        if (!graphics_->IsDeviceLost())
OpenGL\OGLIndexBuffer.cpp:82:            if (graphics_->GetIndexBuffer() == this)
OpenGL\OGLIndexBuffer.cpp:83:                graphics_->SetIndexBuffer(0);
OpenGL\OGLIndexBuffer.cpp:144:        if (!graphics_->IsDeviceLost())
OpenGL\OGLIndexBuffer.cpp:146:            graphics_->SetIndexBuffer(this);
OpenGL\OGLIndexBuffer.cpp:191:        if (!graphics_->IsDeviceLost())
OpenGL\OGLIndexBuffer.cpp:193:            graphics_->SetIndexBuffer(this);
OpenGL\OGLIndexBuffer.cpp:243:        lockScratchData_ = graphics_->ReserveScratchBuffer(count * indexSize_);
OpenGL\OGLIndexBuffer.cpp:262:            graphics_->FreeScratchBuffer(lockScratchData_);
OpenGL\OGLIndexBuffer.cpp:314:    vertexCount = maxVertex - minVertex + 1;
OpenGL\OGLIndexBuffer.cpp:328:        if (graphics_->IsDeviceLost())
OpenGL\OGLIndexBuffer.cpp:342:        graphics_->SetIndexBuffer(this);
OpenGL\OGLRenderSurface.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLRenderSurface.cpp:95:        // Verify that there is at least 1 non-null viewport, as otherwise Renderer will not accept the surface and the update flag
OpenGL\OGLRenderSurface.cpp:108:            Renderer* renderer = parentTexture_->GetSubsystem<Renderer>();
OpenGL\OGLRenderSurface.cpp:110:                renderer->QueueRenderSurface(this);
OpenGL\OGLRenderSurface.cpp:119:    Graphics* graphics = parentTexture_->GetGraphics();
OpenGL\OGLRenderSurface.cpp:134:    Graphics* graphics = parentTexture_->GetGraphics();
OpenGL\OGLRenderSurface.cpp:140:        if (graphics->GetRenderTarget(i) == this)
OpenGL\OGLRenderSurface.cpp:141:            graphics->ResetRenderTarget(i);
OpenGL\OGLRenderSurface.cpp:144:    if (graphics->GetDepthStencil() == this)
OpenGL\OGLRenderSurface.cpp:145:        graphics->ResetDepthStencil();
OpenGL\OGLRenderSurface.cpp:147:    // Clean up also from non-active FBOs
OpenGL\OGLRenderSurface.cpp:148:    graphics->CleanupRenderSurface(this);
OpenGL\OGLRenderSurface.cpp:155:    Graphics* graphics = parentTexture_->GetGraphics();
OpenGL\OGLRenderSurface.cpp:159:    if (!graphics->IsDeviceLost())
OpenGL\OGLRenderSurface.cpp:163:            if (graphics->GetRenderTarget(i) == this)
OpenGL\OGLRenderSurface.cpp:164:                graphics->ResetRenderTarget(i);
OpenGL\OGLRenderSurface.cpp:167:        if (graphics->GetDepthStencil() == this)
OpenGL\OGLRenderSurface.cpp:168:            graphics->ResetDepthStencil();
OpenGL\OGLRenderSurface.cpp:170:        // Clean up also from non-active FBOs
OpenGL\OGLRenderSurface.cpp:171:        graphics->CleanupRenderSurface(this);
OpenGL\OGLRenderSurface.cpp:182:    return parentTexture_->GetWidth();
OpenGL\OGLRenderSurface.cpp:187:    return parentTexture_->GetHeight();
OpenGL\OGLRenderSurface.cpp:192:    return parentTexture_->GetUsage();
OpenGL\OGLRenderSurface.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLRenderSurface.h:35:/// %Color or depth-stencil surface that can be rendered into.
OpenGL\OGLRenderSurface.h:55:    /// Set linked depth-stencil surface.
OpenGL\OGLGraphics.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLGraphics.cpp:194:        primitiveCount = elementCount - 2;
OpenGL\OGLGraphics.cpp:199:        primitiveCount = elementCount - 1;
OpenGL\OGLGraphics.cpp:204:        primitiveCount = elementCount - 2;
OpenGL\OGLGraphics.cpp:257:    // Initialize SDL now. Graphics should be the first SDL-using subsystem to be created
OpenGL\OGLGraphics.cpp:271:    // Shut down SDL now. Graphics should be the last SDL-using subsystem to be destroyed
OpenGL\OGLGraphics.cpp:277:    if (!impl_->window_)
OpenGL\OGLGraphics.cpp:286:    if (impl_->window_)
OpenGL\OGLGraphics.cpp:287:        SDL_SetWindowTitle(impl_->window_, windowTitle_.CString());
OpenGL\OGLGraphics.cpp:293:    if (impl_->window_)
OpenGL\OGLGraphics.cpp:299:    if (impl_->window_)
OpenGL\OGLGraphics.cpp:300:        SDL_SetWindowPosition(impl_->window_, position.x_, position.y_);
OpenGL\OGLGraphics.cpp:372:                unsigned error = Abs(resolutions[i].x_ - width) + Abs(resolutions[i].y_ - height);
OpenGL\OGLGraphics.cpp:389:    if (!externalWindow_ || !impl_->context_)
OpenGL\OGLGraphics.cpp:458:                impl_->window_ = SDL_CreateWindow(windowTitle_.CString(), x, y, width, height, flags);
OpenGL\OGLGraphics.cpp:462:                if (!impl_->window_)
OpenGL\OGLGraphics.cpp:463:                    impl_->window_ = SDL_CreateWindowFrom(externalWindow_, SDL_WINDOW_OPENGL);
OpenGL\OGLGraphics.cpp:468:            if (impl_->window_)
OpenGL\OGLGraphics.cpp:492:            SDL_GetWindowSize(impl_->window_, &width, &height);
OpenGL\OGLGraphics.cpp:499:        if (!impl_->context_)
OpenGL\OGLGraphics.cpp:508:    glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint*)&impl_->systemFBO_);
OpenGL\OGLGraphics.cpp:518:    SDL_GetWindowSize(impl_->window_, &width_, &height_);
OpenGL\OGLGraphics.cpp:520:        SDL_GetWindowPosition(impl_->window_, &position_.x_, &position_.y_);
OpenGL\OGLGraphics.cpp:527:    SDL_GL_SwapWindow(impl_->window_);
OpenGL\OGLGraphics.cpp:568:        impl_->fboDirty_ = true;
OpenGL\OGLGraphics.cpp:631:        SDL_GetWindowSize(impl_->window_, &width, &height);
OpenGL\OGLGraphics.cpp:664:    SDL_GL_SwapWindow(impl_->window_);
OpenGL\OGLGraphics.cpp:706:    /// \todo Any user-set scissor test will be lost
OpenGL\OGLGraphics.cpp:724:    if (!destination || !destination->GetRenderSurface())
OpenGL\OGLGraphics.cpp:744:    glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, vpCopy.left_, height_ - vpCopy.bottom_, vpCopy.Width(), vpCopy.Height());
OpenGL\OGLGraphics.cpp:769:    if (!indexCount || !indexBuffer_ || !indexBuffer_->GetGPUObject())
OpenGL\OGLGraphics.cpp:774:    unsigned indexSize = indexBuffer_->GetIndexSize();
OpenGL\OGLGraphics.cpp:789:    if (!indexCount || !indexBuffer_ || !indexBuffer_->GetGPUObject() || !instancingSupport_)
OpenGL\OGLGraphics.cpp:794:    unsigned indexSize = indexBuffer_->GetIndexSize();
OpenGL\OGLGraphics.cpp:818:    // Note: this is not multi-instance safe
OpenGL\OGLGraphics.cpp:852:                elementMask = buffer->GetElementMask();
OpenGL\OGLGraphics.cpp:854:                elementMask = buffer->GetElementMask() & elementMasks[i];
OpenGL\OGLGraphics.cpp:870:        if (!buffer || !buffer->GetGPUObject())
OpenGL\OGLGraphics.cpp:873:        SetVBO(buffer->GetGPUObject());
OpenGL\OGLGraphics.cpp:874:        unsigned vertexSize = buffer->GetVertexSize();
OpenGL\OGLGraphics.cpp:886:                if ((impl_->enabledAttributes_ & elementBit) == 0)
OpenGL\OGLGraphics.cpp:889:                    impl_->enabledAttributes_ |= elementBit;
OpenGL\OGLGraphics.cpp:895:                    VertexBuffer::elementNormalize[j], vertexSize, reinterpret_cast<const GLvoid*>(buffer->GetElementOffset((VertexElement)j)
OpenGL\OGLGraphics.cpp:907:    unsigned disableAttributes = impl_->enabledAttributes_ & (~newAttributes);
OpenGL\OGLGraphics.cpp:915:            impl_->enabledAttributes_ &= ~(1 << disableIndex);
OpenGL\OGLGraphics.cpp:935:    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffer ? buffer->GetGPUObject() : 0);
OpenGL\OGLGraphics.cpp:945:    if (vs && !vs->GetGPUObject())
OpenGL\OGLGraphics.cpp:947:        if (vs->GetCompilerOutput().Empty())
OpenGL\OGLGraphics.cpp:951:            bool success = vs->Create();
OpenGL\OGLGraphics.cpp:953:                LOGDEBUG("Compiled vertex shader " + vs->GetFullName());
OpenGL\OGLGraphics.cpp:956:                LOGERROR("Failed to compile vertex shader " + vs->GetFullName() + ":\n" + vs->GetCompilerOutput());
OpenGL\OGLGraphics.cpp:964:    if (ps && !ps->GetGPUObject())
OpenGL\OGLGraphics.cpp:966:        if (ps->GetCompilerOutput().Empty())
OpenGL\OGLGraphics.cpp:970:            bool success = ps->Create();
OpenGL\OGLGraphics.cpp:972:                LOGDEBUG("Compiled pixel shader " + ps->GetFullName());
OpenGL\OGLGraphics.cpp:975:                LOGERROR("Failed to compile pixel shader " + ps->GetFullName() + ":\n" + ps->GetCompilerOutput());
OpenGL\OGLGraphics.cpp:1001:            if (i->second_->GetGPUObject())
OpenGL\OGLGraphics.cpp:1003:                glUseProgram(i->second_->GetGPUObject());
OpenGL\OGLGraphics.cpp:1004:                shaderProgram_ = i->second_;
OpenGL\OGLGraphics.cpp:1018:            if (newProgram->Link())
OpenGL\OGLGraphics.cpp:1020:                LOGDEBUG("Linked vertex shader " + vs->GetFullName() + " and pixel shader " + ps->GetFullName());
OpenGL\OGLGraphics.cpp:1027:                LOGERROR("Failed to link vertex shader " + vs->GetFullName() + " and pixel shader " + ps->GetFullName() + ":\n" +
OpenGL\OGLGraphics.cpp:1028:                    newProgram->GetLinkerOutput());
OpenGL\OGLGraphics.cpp:1041:        const SharedPtr<ConstantBuffer>* constantBuffers = shaderProgram_->GetConstantBuffers();
OpenGL\OGLGraphics.cpp:1047:                unsigned object = buffer ? buffer->GetGPUObject() : 0;
OpenGL\OGLGraphics.cpp:1050:                impl_->boundUBO_ = object;
OpenGL\OGLGraphics.cpp:1062:        shaderPrecache_->StoreShaders(vertexShader_, pixelShader_);
OpenGL\OGLGraphics.cpp:1069:        const ShaderParameter* info = shaderProgram_->GetParameter(param);
OpenGL\OGLGraphics.cpp:1072:            if (info->bufferPtr_)
OpenGL\OGLGraphics.cpp:1074:                ConstantBuffer* buffer = info->bufferPtr_;
OpenGL\OGLGraphics.cpp:1075:                if (!buffer->IsDirty())
OpenGL\OGLGraphics.cpp:1077:                buffer->SetParameter(info->location_, count * sizeof(float), data);
OpenGL\OGLGraphics.cpp:1081:            switch (info->type_)
OpenGL\OGLGraphics.cpp:1084:                glUniform1fv(info->location_, count, data);
OpenGL\OGLGraphics.cpp:1088:                glUniform2fv(info->location_, count / 2, data);
OpenGL\OGLGraphics.cpp:1092:                glUniform3fv(info->location_, count / 3, data);
OpenGL\OGLGraphics.cpp:1096:                glUniform4fv(info->location_, count / 4, data);
OpenGL\OGLGraphics.cpp:1100:                glUniformMatrix3fv(info->location_, count / 9, GL_FALSE, data);
OpenGL\OGLGraphics.cpp:1104:                glUniformMatrix4fv(info->location_, count / 16, GL_FALSE, data);
OpenGL\OGLGraphics.cpp:1115:        const ShaderParameter* info = shaderProgram_->GetParameter(param);
OpenGL\OGLGraphics.cpp:1118:            if (info->bufferPtr_)
OpenGL\OGLGraphics.cpp:1120:                ConstantBuffer* buffer = info->bufferPtr_;
OpenGL\OGLGraphics.cpp:1121:                if (!buffer->IsDirty())
OpenGL\OGLGraphics.cpp:1123:                buffer->SetParameter(info->location_, sizeof(float), &value);
OpenGL\OGLGraphics.cpp:1127:            glUniform1fv(info->location_, 1, &value);
OpenGL\OGLGraphics.cpp:1141:        const ShaderParameter* info = shaderProgram_->GetParameter(param);
OpenGL\OGLGraphics.cpp:1144:            if (info->bufferPtr_)
OpenGL\OGLGraphics.cpp:1146:                ConstantBuffer* buffer = info->bufferPtr_;
OpenGL\OGLGraphics.cpp:1147:                if (!buffer->IsDirty())
OpenGL\OGLGraphics.cpp:1149:                buffer->SetParameter(info->location_, sizeof(Vector2), &vector);
OpenGL\OGLGraphics.cpp:1154:            switch (info->type_)
OpenGL\OGLGraphics.cpp:1157:                glUniform1fv(info->location_, 1, vector.Data());
OpenGL\OGLGraphics.cpp:1161:                glUniform2fv(info->location_, 1, vector.Data());
OpenGL\OGLGraphics.cpp:1172:        const ShaderParameter* info = shaderProgram_->GetParameter(param);
OpenGL\OGLGraphics.cpp:1175:            if (info->bufferPtr_)
OpenGL\OGLGraphics.cpp:1177:                ConstantBuffer* buffer = info->bufferPtr_;
OpenGL\OGLGraphics.cpp:1178:                if (!buffer->IsDirty())
OpenGL\OGLGraphics.cpp:1180:                buffer->SetVector3ArrayParameter(info->location_, 3, &matrix);
OpenGL\OGLGraphics.cpp:1184:            glUniformMatrix3fv(info->location_, 1, GL_FALSE, matrix.Data());
OpenGL\OGLGraphics.cpp:1193:        const ShaderParameter* info = shaderProgram_->GetParameter(param);
OpenGL\OGLGraphics.cpp:1196:            if (info->bufferPtr_)
OpenGL\OGLGraphics.cpp:1198:                ConstantBuffer* buffer = info->bufferPtr_;
OpenGL\OGLGraphics.cpp:1199:                if (!buffer->IsDirty())
OpenGL\OGLGraphics.cpp:1201:                buffer->SetParameter(info->location_, sizeof(Vector3), &vector);
OpenGL\OGLGraphics.cpp:1206:            switch (info->type_)
OpenGL\OGLGraphics.cpp:1209:                glUniform1fv(info->location_, 1, vector.Data());
OpenGL\OGLGraphics.cpp:1213:                glUniform2fv(info->location_, 1, vector.Data());
OpenGL\OGLGraphics.cpp:1217:                glUniform3fv(info->location_, 1, vector.Data());
OpenGL\OGLGraphics.cpp:1228:        const ShaderParameter* info = shaderProgram_->GetParameter(param);
OpenGL\OGLGraphics.cpp:1231:            if (info->bufferPtr_)
OpenGL\OGLGraphics.cpp:1233:                ConstantBuffer* buffer = info->bufferPtr_;
OpenGL\OGLGraphics.cpp:1234:                if (!buffer->IsDirty())
OpenGL\OGLGraphics.cpp:1236:                buffer->SetParameter(info->location_, sizeof(Matrix4), &matrix);
OpenGL\OGLGraphics.cpp:1240:            glUniformMatrix4fv(info->location_, 1, GL_FALSE, matrix.Data());
OpenGL\OGLGraphics.cpp:1249:        const ShaderParameter* info = shaderProgram_->GetParameter(param);
OpenGL\OGLGraphics.cpp:1252:            if (info->bufferPtr_)
OpenGL\OGLGraphics.cpp:1254:                ConstantBuffer* buffer = info->bufferPtr_;
OpenGL\OGLGraphics.cpp:1255:                if (!buffer->IsDirty())
OpenGL\OGLGraphics.cpp:1257:                buffer->SetParameter(info->location_, sizeof(Vector4), &vector);
OpenGL\OGLGraphics.cpp:1262:            switch (info->type_)
OpenGL\OGLGraphics.cpp:1265:                glUniform1fv(info->location_, 1, vector.Data());
OpenGL\OGLGraphics.cpp:1269:                glUniform2fv(info->location_, 1, vector.Data());
OpenGL\OGLGraphics.cpp:1273:                glUniform3fv(info->location_, 1, vector.Data());
OpenGL\OGLGraphics.cpp:1277:                glUniform4fv(info->location_, 1, vector.Data());
OpenGL\OGLGraphics.cpp:1288:        const ShaderParameter* info = shaderProgram_->GetParameter(param);
OpenGL\OGLGraphics.cpp:1306:            if (info->bufferPtr_)
OpenGL\OGLGraphics.cpp:1308:                ConstantBuffer* buffer = info->bufferPtr_;
OpenGL\OGLGraphics.cpp:1309:                if (!buffer->IsDirty())
OpenGL\OGLGraphics.cpp:1311:                buffer->SetParameter(info->location_, sizeof(Matrix4), &fullMatrix);
OpenGL\OGLGraphics.cpp:1315:            glUniformMatrix4fv(info->location_, 1, GL_FALSE, fullMatrix.Data());
OpenGL\OGLGraphics.cpp:1368:    return shaderProgram_ ? shaderProgram_->NeedParameterUpdate(group, source) : false;
OpenGL\OGLGraphics.cpp:1373:    return shaderProgram_ && shaderProgram_->HasParameter(param);
OpenGL\OGLGraphics.cpp:1378:    return shaderProgram_ && shaderProgram_->HasTextureUnit(unit);
OpenGL\OGLGraphics.cpp:1384:        shaderProgram_->ClearParameterSource(group);
OpenGL\OGLGraphics.cpp:1396:        shaderProgram_->ClearParameterSource(SP_CAMERA);
OpenGL\OGLGraphics.cpp:1397:        shaderProgram_->ClearParameterSource(SP_OBJECT);
OpenGL\OGLGraphics.cpp:1409:        if (renderTargets_[0] && renderTargets_[0]->GetParentTexture() == texture)
OpenGL\OGLGraphics.cpp:1410:            texture = texture->GetBackupTexture();
OpenGL\OGLGraphics.cpp:1415:        if (impl_->activeTexture_ != index)
OpenGL\OGLGraphics.cpp:1418:            impl_->activeTexture_ = index;
OpenGL\OGLGraphics.cpp:1423:            unsigned glType = texture->GetTarget();
OpenGL\OGLGraphics.cpp:1439:            glBindTexture(glType, texture->GetGPUObject());
OpenGL\OGLGraphics.cpp:1441:            if (texture->GetParametersDirty())
OpenGL\OGLGraphics.cpp:1442:                texture->UpdateParameters();
OpenGL\OGLGraphics.cpp:1454:        if (texture && texture->GetParametersDirty())
OpenGL\OGLGraphics.cpp:1456:            if (impl_->activeTexture_ != index)
OpenGL\OGLGraphics.cpp:1459:                impl_->activeTexture_ = index;
OpenGL\OGLGraphics.cpp:1462:            glBindTexture(texture->GetTarget(), texture->GetGPUObject());
OpenGL\OGLGraphics.cpp:1463:            texture->UpdateParameters();
OpenGL\OGLGraphics.cpp:1470:    if (impl_->activeTexture_ != 0)
OpenGL\OGLGraphics.cpp:1473:        impl_->activeTexture_ = 0;
OpenGL\OGLGraphics.cpp:1476:    glBindTexture(texture->GetTarget(), texture->GetGPUObject());
OpenGL\OGLGraphics.cpp:1506:            texture->SetParametersDirty();
OpenGL\OGLGraphics.cpp:1540:            Texture* parentTexture = renderTarget->GetParentTexture();
OpenGL\OGLGraphics.cpp:1545:                    SetTexture(i, textures_[i]->GetBackupTexture());
OpenGL\OGLGraphics.cpp:1549:        impl_->fboDirty_ = true;
OpenGL\OGLGraphics.cpp:1557:        renderTarget = texture->GetRenderSurface();
OpenGL\OGLGraphics.cpp:1564:    // If we are using a rendertarget texture, it is required in OpenGL to also have an own depth-stencil
OpenGL\OGLGraphics.cpp:1565:    // Create a new depth-stencil texture as necessary to be able to provide similar behaviour as Direct3D9
OpenGL\OGLGraphics.cpp:1568:        int width = renderTargets_[0]->GetWidth();
OpenGL\OGLGraphics.cpp:1569:        int height = renderTargets_[0]->GetHeight();
OpenGL\OGLGraphics.cpp:1571:        // Direct3D9 default depth-stencil can not be used when rendertarget is larger than the window.
OpenGL\OGLGraphics.cpp:1578:                depthStencil = i->second_->GetRenderSurface();
OpenGL\OGLGraphics.cpp:1582:                newDepthTexture->SetSize(width, height, GetDepthStencilFormat(), TEXTURE_DEPTHSTENCIL);
OpenGL\OGLGraphics.cpp:1584:                depthStencil = newDepthTexture->GetRenderSurface();
OpenGL\OGLGraphics.cpp:1592:        impl_->fboDirty_ = true;
OpenGL\OGLGraphics.cpp:1600:        depthStencil = texture->GetRenderSurface();
OpenGL\OGLGraphics.cpp:1623:    glViewport(rectCopy.left_, rtSize.y_ - rectCopy.bottom_, rectCopy.Width(), rectCopy.Height());
OpenGL\OGLGraphics.cpp:1626:    // Disable scissor test, needs to be re-enabled by the user
OpenGL\OGLGraphics.cpp:1744:        intRect.left_ = Clamp((int)((rect.min_.x_ + 1.0f) * 0.5f * viewSize.x_) + viewPos.x_, 0, rtSize.x_ - 1);
OpenGL\OGLGraphics.cpp:1745:        intRect.top_ = Clamp((int)((-rect.max_.y_ + 1.0f) * 0.5f * viewSize.y_) + viewPos.y_, 0, rtSize.y_ - 1);
OpenGL\OGLGraphics.cpp:1747:        intRect.bottom_ = Clamp((int)((-rect.min_.y_ + 1.0f) * 0.5f * viewSize.y_) + viewPos.y_ + expand, 0, rtSize.y_);
OpenGL\OGLGraphics.cpp:1760:            glScissor(intRect.left_, rtSize.y_ - intRect.bottom_, intRect.Width(), intRect.Height());
OpenGL\OGLGraphics.cpp:1785:        intRect.left_ = Clamp(rect.left_ + viewPos.x_, 0, rtSize.x_ - 1);
OpenGL\OGLGraphics.cpp:1786:        intRect.top_ = Clamp(rect.top_ + viewPos.y_, 0, rtSize.y_ - 1);
OpenGL\OGLGraphics.cpp:1801:            glScissor(intRect.left_, rtSize.y_ - intRect.bottom_, intRect.Width(), intRect.Height());
OpenGL\OGLGraphics.cpp:1906:    return impl_->window_ != 0;
OpenGL\OGLGraphics.cpp:1913:    if (impl_->window_ && (SDL_GetWindowFlags(impl_->window_) & SDL_WINDOW_MINIMIZED) != 0)
OpenGL\OGLGraphics.cpp:1917:    return impl_->context_ == 0;
OpenGL\OGLGraphics.cpp:1922:    if (impl_->window_)
OpenGL\OGLGraphics.cpp:2040:        if (lastShaderName_ == name && !cache->Exists(fullShaderName))
OpenGL\OGLGraphics.cpp:2043:        lastShader_ = cache->GetResource<Shader>(fullShaderName);
OpenGL\OGLGraphics.cpp:2047:    return lastShader_ ? lastShader_->GetVariation(type, defines) : (ShaderVariation*)0;
OpenGL\OGLGraphics.cpp:2059:        return i->second_;
OpenGL\OGLGraphics.cpp:2068:        if (i->second_ == unit)
OpenGL\OGLGraphics.cpp:2069:            return i->first_;
OpenGL\OGLGraphics.cpp:2090:        width = renderTargets_[0]->GetWidth();
OpenGL\OGLGraphics.cpp:2091:        height = renderTargets_[0]->GetHeight();
OpenGL\OGLGraphics.cpp:2095:        width = depthStencil_->GetWidth();
OpenGL\OGLGraphics.cpp:2096:        height = depthStencil_->GetHeight();
OpenGL\OGLGraphics.cpp:2109:    if (!impl_->window_)
OpenGL\OGLGraphics.cpp:2114:    SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
OpenGL\OGLGraphics.cpp:2140:    if (!impl_->window_ || fullscreen_)
OpenGL\OGLGraphics.cpp:2145:    SDL_GetWindowPosition(impl_->window_, &newX, &newY);
OpenGL\OGLGraphics.cpp:2187:        if (!i->reserved_ && i->size_ >= size)
OpenGL\OGLGraphics.cpp:2189:            i->reserved_ = true;
OpenGL\OGLGraphics.cpp:2190:            return i->data_.Get();
OpenGL\OGLGraphics.cpp:2197:        if (!i->reserved_)
OpenGL\OGLGraphics.cpp:2199:            i->data_ = new unsigned char[size];
OpenGL\OGLGraphics.cpp:2200:            i->size_ = size;
OpenGL\OGLGraphics.cpp:2201:            i->reserved_ = true;
OpenGL\OGLGraphics.cpp:2202:            return i->data_.Get();
OpenGL\OGLGraphics.cpp:2222:        if (i->reserved_ && i->data_.Get() == buffer)
OpenGL\OGLGraphics.cpp:2224:            i->reserved_ = false;
OpenGL\OGLGraphics.cpp:2236:        if (!i->reserved_ && i->size_ > maxScratchBufferRequest_ * 2)
OpenGL\OGLGraphics.cpp:2238:            i->data_ = maxScratchBufferRequest_ > 0 ? new unsigned char[maxScratchBufferRequest_] : 0;
OpenGL\OGLGraphics.cpp:2239:            i->size_ = maxScratchBufferRequest_;
OpenGL\OGLGraphics.cpp:2254:    unsigned currentFBO = impl_->boundFBO_;
OpenGL\OGLGraphics.cpp:2257:    for (HashMap<unsigned long long, FrameBufferObject>::Iterator i = impl_->frameBuffers_.Begin();
OpenGL\OGLGraphics.cpp:2258:        i != impl_->frameBuffers_.End(); ++i)
OpenGL\OGLGraphics.cpp:2262:            if (i->second_.colorAttachments_[j] == surface)
OpenGL\OGLGraphics.cpp:2264:                if (currentFBO != i->second_.fbo_)
OpenGL\OGLGraphics.cpp:2266:                    BindFramebuffer(i->second_.fbo_);
OpenGL\OGLGraphics.cpp:2267:                    currentFBO = i->second_.fbo_;
OpenGL\OGLGraphics.cpp:2270:                i->second_.colorAttachments_[j] = 0;
OpenGL\OGLGraphics.cpp:2272:                i->second_.drawBuffers_ = M_MAX_UNSIGNED;
OpenGL\OGLGraphics.cpp:2275:        if (i->second_.depthAttachment_ == surface)
OpenGL\OGLGraphics.cpp:2277:            if (currentFBO != i->second_.fbo_)
OpenGL\OGLGraphics.cpp:2279:                BindFramebuffer(i->second_.fbo_);
OpenGL\OGLGraphics.cpp:2280:                currentFBO = i->second_.fbo_;
OpenGL\OGLGraphics.cpp:2284:            i->second_.depthAttachment_ = 0;
OpenGL\OGLGraphics.cpp:2289:    if (currentFBO != impl_->boundFBO_)
OpenGL\OGLGraphics.cpp:2290:        BindFramebuffer(impl_->boundFBO_);
OpenGL\OGLGraphics.cpp:2297:        if (i->second_->GetVertexShader() == variation || i->second_->GetPixelShader() == variation)
OpenGL\OGLGraphics.cpp:2314:        i->second_->SetSize(size);
OpenGL\OGLGraphics.cpp:2316:    return i->second_.Get();
OpenGL\OGLGraphics.cpp:2321:    if (!impl_->window_)
OpenGL\OGLGraphics.cpp:2334:                (*i)->Release();
OpenGL\OGLGraphics.cpp:2341:                (*i)->OnDeviceLost();
OpenGL\OGLGraphics.cpp:2357:        SDL_SetWindowFullscreen(impl_->window_, SDL_FALSE);
OpenGL\OGLGraphics.cpp:2360:    if (impl_->context_)
OpenGL\OGLGraphics.cpp:2366:        SDL_GL_DeleteContext(impl_->context_);
OpenGL\OGLGraphics.cpp:2367:        impl_->context_ = 0;
OpenGL\OGLGraphics.cpp:2377:            SDL_DestroyWindow(impl_->window_);
OpenGL\OGLGraphics.cpp:2378:            impl_->window_ = 0;
OpenGL\OGLGraphics.cpp:2385:    if (!impl_->window_)
OpenGL\OGLGraphics.cpp:2390:    if (impl_->context_ && !SDL_GL_GetCurrentContext())
OpenGL\OGLGraphics.cpp:2392:        impl_->context_ = 0;
OpenGL\OGLGraphics.cpp:2400:    if (!impl_->context_)
OpenGL\OGLGraphics.cpp:2402:        impl_->context_ = SDL_GL_CreateContext(impl_->window_);
OpenGL\OGLGraphics.cpp:2406:        if (!forceGL2_ && !impl_->context_)
OpenGL\OGLGraphics.cpp:2412:            impl_->context_ = SDL_GL_CreateContext(impl_->window_);
OpenGL\OGLGraphics.cpp:2417:        glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint*)&impl_->systemFBO_);
OpenGL\OGLGraphics.cpp:2420:        if (!impl_->context_)
OpenGL\OGLGraphics.cpp:2476:            (*i)->OnDeviceReset();
OpenGL\OGLGraphics.cpp:2484:    if (!impl_->window_)
OpenGL\OGLGraphics.cpp:2487:    SDL_MaximizeWindow(impl_->window_);
OpenGL\OGLGraphics.cpp:2492:    if (!impl_->window_)
OpenGL\OGLGraphics.cpp:2495:    SDL_MinimizeWindow(impl_->window_);
OpenGL\OGLGraphics.cpp:2500:    impl_->fboDirty_ = true;
OpenGL\OGLGraphics.cpp:2505:    if (impl_->boundVBO_ != object)
OpenGL\OGLGraphics.cpp:2509:        impl_->boundVBO_ = object;
OpenGL\OGLGraphics.cpp:2516:    if (impl_->boundUBO_ != object)
OpenGL\OGLGraphics.cpp:2520:        impl_->boundUBO_ = object;
OpenGL\OGLGraphics.cpp:2711:        SDL_Surface* surface = windowIcon_->GetSDLSurface();
OpenGL\OGLGraphics.cpp:2714:            SDL_SetWindowIcon(impl_->window_, surface);
OpenGL\OGLGraphics.cpp:2722:    // Check supported features: light pre-pass, deferred rendering and hardware depth texture
OpenGL\OGLGraphics.cpp:2762:    // Must support 2 rendertargets for light pre-pass, and 4 for deferred
OpenGL\OGLGraphics.cpp:2770:    // depth-only FBO rendering and backbuffer rendering will bug, resulting in a black screen in full
OpenGL\OGLGraphics.cpp:2825:            (*i)->Apply();
OpenGL\OGLGraphics.cpp:2830:    if (impl_->fboDirty_)
OpenGL\OGLGraphics.cpp:2832:        impl_->fboDirty_ = false;
OpenGL\OGLGraphics.cpp:2850:            if (impl_->boundFBO_ != impl_->systemFBO_)
OpenGL\OGLGraphics.cpp:2852:                BindFramebuffer(impl_->systemFBO_);
OpenGL\OGLGraphics.cpp:2853:                impl_->boundFBO_ = impl_->systemFBO_;
OpenGL\OGLGraphics.cpp:2861:                if (sRGBWrite != impl_->sRGBWrite_)
OpenGL\OGLGraphics.cpp:2867:                    impl_->sRGBWrite_ = sRGBWrite;
OpenGL\OGLGraphics.cpp:2879:            format = renderTargets_[0]->GetParentTexture()->GetFormat();
OpenGL\OGLGraphics.cpp:2881:            format = depthStencil_->GetParentTexture()->GetFormat();
OpenGL\OGLGraphics.cpp:2885:        HashMap<unsigned long long, FrameBufferObject>::Iterator i = impl_->frameBuffers_.Find(fboKey);
OpenGL\OGLGraphics.cpp:2886:        if (i == impl_->frameBuffers_.End())
OpenGL\OGLGraphics.cpp:2890:            i = impl_->frameBuffers_.Insert(MakePair(fboKey, newFbo));
OpenGL\OGLGraphics.cpp:2893:        if (impl_->boundFBO_ != i->second_.fbo_)
OpenGL\OGLGraphics.cpp:2895:            BindFramebuffer(i->second_.fbo_);
OpenGL\OGLGraphics.cpp:2896:            impl_->boundFBO_ = i->second_.fbo_;
OpenGL\OGLGraphics.cpp:2901:        if (i->second_.readBuffers_ != GL_NONE)
OpenGL\OGLGraphics.cpp:2904:            i->second_.readBuffers_ = GL_NONE;
OpenGL\OGLGraphics.cpp:2907:        // Calculate the bit combination of non-zero color rendertargets to first check if the combination changed
OpenGL\OGLGraphics.cpp:2915:        if (newDrawBuffers != i->second_.drawBuffers_)
OpenGL\OGLGraphics.cpp:2938:            i->second_.drawBuffers_ = newDrawBuffers;
OpenGL\OGLGraphics.cpp:2946:                Texture* texture = renderTargets_[j]->GetParentTexture();
OpenGL\OGLGraphics.cpp:2949:                if (texture->GetParametersDirty())
OpenGL\OGLGraphics.cpp:2952:                    texture->UpdateParameters();
OpenGL\OGLGraphics.cpp:2956:                if (i->second_.colorAttachments_[j] != renderTargets_[j])
OpenGL\OGLGraphics.cpp:2958:                    BindColorAttachment(j, renderTargets_[j]->GetTarget(), texture->GetGPUObject());
OpenGL\OGLGraphics.cpp:2959:                    i->second_.colorAttachments_[j] = renderTargets_[j];
OpenGL\OGLGraphics.cpp:2964:                if (i->second_.colorAttachments_[j])
OpenGL\OGLGraphics.cpp:2967:                    i->second_.colorAttachments_[j] = 0;
OpenGL\OGLGraphics.cpp:2975:            Texture* texture = depthStencil_->GetParentTexture();
OpenGL\OGLGraphics.cpp:2977:            bool hasStencil = texture->GetFormat() == GL_DEPTH24_STENCIL8_EXT;
OpenGL\OGLGraphics.cpp:2979:            bool hasStencil = texture->GetFormat() == GL_DEPTH24_STENCIL8_OES;
OpenGL\OGLGraphics.cpp:2981:            unsigned renderBufferID = depthStencil_->GetRenderBuffer();
OpenGL\OGLGraphics.cpp:2985:                if (texture->GetParametersDirty())
OpenGL\OGLGraphics.cpp:2988:                    texture->UpdateParameters();
OpenGL\OGLGraphics.cpp:2992:                if (i->second_.depthAttachment_ != depthStencil_)
OpenGL\OGLGraphics.cpp:2994:                    BindDepthAttachment(texture->GetGPUObject(), false);
OpenGL\OGLGraphics.cpp:2995:                    BindStencilAttachment(hasStencil ? texture->GetGPUObject() : 0, false);
OpenGL\OGLGraphics.cpp:2996:                    i->second_.depthAttachment_ = depthStencil_;
OpenGL\OGLGraphics.cpp:3001:                if (i->second_.depthAttachment_ != depthStencil_)
OpenGL\OGLGraphics.cpp:3005:                    i->second_.depthAttachment_ = depthStencil_;
OpenGL\OGLGraphics.cpp:3011:            if (i->second_.depthAttachment_)
OpenGL\OGLGraphics.cpp:3015:                i->second_.depthAttachment_ = 0;
OpenGL\OGLGraphics.cpp:3023:            bool sRGBWrite = renderTargets_[0] ? renderTargets_[0]->GetParentTexture()->GetSRGB() : sRGB_;
OpenGL\OGLGraphics.cpp:3024:            if (sRGBWrite != impl_->sRGBWrite_)
OpenGL\OGLGraphics.cpp:3030:                impl_->sRGBWrite_ = sRGBWrite;
OpenGL\OGLGraphics.cpp:3041:        BindFramebuffer(impl_->systemFBO_);
OpenGL\OGLGraphics.cpp:3042:        impl_->boundFBO_ = impl_->systemFBO_;
OpenGL\OGLGraphics.cpp:3043:        impl_->fboDirty_ = true;
OpenGL\OGLGraphics.cpp:3045:        for (HashMap<unsigned long long, FrameBufferObject>::Iterator i = impl_->frameBuffers_.Begin(); i !=
OpenGL\OGLGraphics.cpp:3046:            impl_->frameBuffers_.End(); ++i)
OpenGL\OGLGraphics.cpp:3047:            DeleteFramebuffer(i->second_.fbo_);
OpenGL\OGLGraphics.cpp:3050:        impl_->boundFBO_ = 0;
OpenGL\OGLGraphics.cpp:3052:    impl_->frameBuffers_.Clear();
OpenGL\OGLGraphics.cpp:3099:    impl_->activeTexture_ = 0;
OpenGL\OGLGraphics.cpp:3100:    impl_->enabledAttributes_ = 0;
OpenGL\OGLGraphics.cpp:3101:    impl_->boundFBO_ = impl_->systemFBO_;
OpenGL\OGLGraphics.cpp:3102:    impl_->boundVBO_ = 0;
OpenGL\OGLGraphics.cpp:3103:    impl_->boundUBO_ = 0;
OpenGL\OGLGraphics.cpp:3104:    impl_->sRGBWrite_ = false;
OpenGL\OGLGraphics.cpp:3107:    if (impl_->context_)
OpenGL\OGLShaderProgram.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLShaderProgram.cpp:69:    if (graphics_ && graphics_->GetShaderProgram() == this)
OpenGL\OGLShaderProgram.cpp:70:        graphics_->SetShaders(0, 0);
OpenGL\OGLShaderProgram.cpp:82:        if (!graphics_->IsDeviceLost())
OpenGL\OGLShaderProgram.cpp:84:            if (graphics_->GetShaderProgram() == this)
OpenGL\OGLShaderProgram.cpp:85:                graphics_->SetShaders(0, 0);
OpenGL\OGLShaderProgram.cpp:105:    if (!vertexShader_ || !pixelShader_ || !vertexShader_->GetGPUObject() || !pixelShader_->GetGPUObject())
OpenGL\OGLShaderProgram.cpp:134:    glAttachShader(object_, vertexShader_->GetGPUObject());
OpenGL\OGLShaderProgram.cpp:135:    glAttachShader(object_, pixelShader_->GetGPUObject());
OpenGL\OGLShaderProgram.cpp:198:                        group = name[j] - '0';
OpenGL\OGLShaderProgram.cpp:206:                LOGWARNING("Skipping unrecognized uniform block " + name + " in shader program " + vertexShader_->GetFullName() +
OpenGL\OGLShaderProgram.cpp:207:                    " " + pixelShader_->GetFullName());
OpenGL\OGLShaderProgram.cpp:226:            constantBuffers_[bindingIndex] = graphics_->GetOrCreateConstantBuffer(bindingIndex, dataSize);
OpenGL\OGLShaderProgram.cpp:281:            int unit = graphics_->GetTextureUnit(name.Substring(1));
OpenGL\OGLShaderProgram.cpp:289:                        unit = name[j] - '0';
OpenGL\OGLShaderProgram.cpp:328:        return &i->second_;
OpenGL\OGLShaderProgram.cpp:335:    // If global framenumber has changed, invalidate all per-program parameter sources now
OpenGL\OGLShaderProgram.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLShaderVariation.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLShaderVariation.cpp:36:    GPUObject(owner->GetSubsystem<Graphics>()),
OpenGL\OGLShaderVariation.cpp:61:        if (!graphics_->IsDeviceLost())
OpenGL\OGLShaderVariation.cpp:65:                if (graphics_->GetVertexShader() == this)
OpenGL\OGLShaderVariation.cpp:66:                    graphics_->SetShaders(0, 0);
OpenGL\OGLShaderVariation.cpp:70:                if (graphics_->GetPixelShader() == this)
OpenGL\OGLShaderVariation.cpp:71:                    graphics_->SetShaders(0, 0);
OpenGL\OGLShaderVariation.cpp:78:        graphics_->CleanupShaderPrograms(this);
OpenGL\OGLShaderVariation.cpp:101:    const String& originalShaderCode = owner_->GetSourceCode(type_);
OpenGL\OGLShaderVariation.cpp:120:            String versionDefine = originalShaderCode.Substring(verStart, verEnd - verStart);
OpenGL\OGLShaderVariation.cpp:144:        String defineCheck = defineString.Substring(8, defineString.Find(' ', 8) - 8);
OpenGL\OGLShaderVariation.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLTexture.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLTexture.cpp:107:        mipsToSkip_[i] = MAX_TEXTURE_QUALITY_LEVELS - 1 - i;
OpenGL\OGLTexture.cpp:146:        enable &= graphics_->GetSRGBSupport();
OpenGL\OGLTexture.cpp:156:        if (graphics_ && graphics_->GetRenderTarget(0) && graphics_->GetRenderTarget(0)->GetParentTexture() == this)
OpenGL\OGLTexture.cpp:157:            graphics_->MarkFBODirty();
OpenGL\OGLTexture.cpp:175:            if (mipsToSkip_[i] > mipsToSkip_[i - 1])
OpenGL\OGLTexture.cpp:176:                mipsToSkip_[i] = mipsToSkip_[i - 1];
OpenGL\OGLTexture.cpp:200:        filterMode = graphics_->GetDefaultTextureFilterMode();
OpenGL\OGLTexture.cpp:233:    if (graphics_->GetAnisotropySupport())
OpenGL\OGLTexture.cpp:236:            (float)graphics_->GetTextureAnisotropy() : 1.0f);
OpenGL\OGLTexture.cpp:423:    XMLElement rootElem = file->GetRoot();
OpenGL\OGLTexture.cpp:439:                TextureCoordinate coordIndex = (TextureCoordinate)(coord[0] - 'u');
OpenGL\OGLTexture.cpp:479:    if (!graphics_ || !graphics_->GetSRGBSupport())
OpenGL\OGLTexture.cpp:509:    unsigned textureBudget = cache->GetMemoryBudget(type);
OpenGL\OGLTexture.cpp:510:    unsigned textureUse = cache->GetMemoryUse(type);
OpenGL\OGLTexture.cpp:517:        cache->ReleaseResources(Material::GetTypeStatic());
Draw:1:AnimatedModel.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2:AnimatedModel.h:60:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
Draw:3:AnimatedModel.h:147:    /// Return per-geometry bone mappings.
Draw:4:AnimatedModel.h:149:    /// Return per-geometry skin matrices. If empty, uses global skinning
Draw:5:AnimatedModel.h:157:    /// Recalculate the world-space bounding box.
Draw:6:Animation.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:7:Animation.cpp:49:        index = keyFrames_.Size() - 1;
Draw:8:Animation.cpp:53:        --index;
Draw:9:Animation.cpp:56:    while (index < keyFrames_.Size() - 1 && time >= keyFrames_[index + 1].time_)
Draw:10:Animation.cpp:72:    context->RegisterFactory<Animation>();
Draw:11:Animation.cpp:126:    SharedPtr<XMLFile> file(cache->GetTempResource<XMLFile>(xmlName, false));
Draw:12:Animation.cpp:129:        XMLElement rootElem = file->GetRoot();
Draw:13:Animation.cpp:184:            String xmlName = ReplaceExtension(destFile->GetName(), ".xml");
Draw:14:Animation.cpp:187:            XMLElement rootElem = xml->CreateRoot("animation");
Draw:15:Animation.cpp:197:            xml->Save(xmlFile);
Draw:16:Animation.cpp:257:        if (i->name_ == name)
Draw:17:Animation.cpp:268:        if (i->nameHash_ == nameHash)
Draw:18:Animation.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:19:AnimatedModel.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:20:AnimatedModel.cpp:53:    return lhs->GetLayer() < rhs->GetLayer();
Draw:21:AnimatedModel.cpp:63:    animationLodTimer_(-1.0f),
Draw:22:AnimatedModel.cpp:81:    if (rootBone && rootBone->node_)
Draw:23:AnimatedModel.cpp:83:        Node* parent = rootBone->node_->GetParent();
Draw:24:AnimatedModel.cpp:84:        if (parent && !parent->GetComponent<AnimatedModel>())
Draw:25:AnimatedModel.cpp:91:    context->RegisterFactory<AnimatedModel>(GEOMETRY_CATEGORY);
Draw:26:AnimatedModel.cpp:136:    // If no bones or no bone-level testing, use the StaticModel test
Draw:27:AnimatedModel.cpp:144:    // Check ray hit distance to AABB before proceeding with bone-level tests
Draw:28:AnimatedModel.cpp:164:            const Matrix3x4& transform = bone.node_->GetWorldTransform();
Draw:29:AnimatedModel.cpp:180:            boneSphere.center_ = bone.node_->GetWorldPosition();
Draw:30:AnimatedModel.cpp:192:        result.normal_ = -query.ray_.direction_;
Draw:31:AnimatedModel.cpp:205:    if (frame.camera_ && abs((int)frame.frameNumber_ - (int)viewFrameNumber_) > 1)
Draw:32:AnimatedModel.cpp:210:        float distance = frame.camera_->GetDistance(node_->GetWorldPosition());
Draw:33:AnimatedModel.cpp:215:        animationLodDistance_ = frame.camera_->GetLodDistance(distance, scale, lodBias_);
Draw:34:AnimatedModel.cpp:226:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
Draw:35:AnimatedModel.cpp:228:    distance_ = frame.camera_->GetDistance(worldBoundingBox.Center());
Draw:36:AnimatedModel.cpp:230:    // Note: per-geometry distances do not take skinning into account. Especially in case of a ragdoll they may be
Draw:37:AnimatedModel.cpp:237:            batches_[i].distance_ = frame.camera_->GetDistance(worldTransform * geometryData_[i].center_);
Draw:38:AnimatedModel.cpp:244:    float newLodDistance = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
Draw:39:AnimatedModel.cpp:285:        debug->AddBoundingBox(GetWorldBoundingBox(), Color::GREEN, depthTest);
Draw:40:AnimatedModel.cpp:286:        debug->AddSkeleton(skeleton_, Color(0.75f, 0.75f, 0.75f), depthTest);
Draw:41:AnimatedModel.cpp:306:        SetNumGeometries(model->GetNumGeometries());
Draw:42:AnimatedModel.cpp:307:        const Vector<Vector<SharedPtr<Geometry> > >& geometries = model->GetGeometries();
Draw:43:AnimatedModel.cpp:308:        const PODVector<Vector3>& geometryCenters = model->GetGeometryCenters();
Draw:44:AnimatedModel.cpp:316:        const Vector<PODVector<unsigned> >& geometryBoneMappings = model->GetGeometryBoneMappings();
Draw:45:AnimatedModel.cpp:322:        // Copy morphs. Note: morph vertex buffers will be created later on-demand
Draw:46:AnimatedModel.cpp:325:        const Vector<ModelMorph>& morphs = model->GetMorphs();
Draw:47:AnimatedModel.cpp:336:                morphElementMask_ |= j->second_.elementMask_;
Draw:48:AnimatedModel.cpp:341:        SetBoundingBox(model->GetBoundingBox());
Draw:49:AnimatedModel.cpp:345:        SetSkeleton(model->GetSkeleton(), createBones);
Draw:50:AnimatedModel.cpp:354:                // Check if model has per-geometry bone mappings
Draw:51:AnimatedModel.cpp:370:                batches_[i].worldTransform_ = &node_->GetWorldTransform();
Draw:52:AnimatedModel.cpp:394:        LOGERROR("Can not add animation state to non-master model");
Draw:53:AnimatedModel.cpp:415:        RemoveAnimationState(animation->GetNameHash());
Draw:54:AnimatedModel.cpp:421:            if (!state->GetAnimation())
Draw:55:AnimatedModel.cpp:441:        Animation* animation = state->GetAnimation();
Draw:56:AnimatedModel.cpp:445:            if (animation->GetNameHash() == animationNameHash || animation->GetAnimationNameHash() == animationNameHash)
Draw:57:AnimatedModel.cpp:514:        // For a master model, set the same morph weight on non-master models
Draw:58:AnimatedModel.cpp:523:                if (!models[i]->isMaster_)
Draw:59:AnimatedModel.cpp:524:                    models[i]->SetMorphWeight(morphs_[index].nameHash_, weight);
Draw:60:AnimatedModel.cpp:560:        i->weight_ = 0.0f;
Draw:61:AnimatedModel.cpp:562:    // For a master model, reset weights on non-master models
Draw:62:AnimatedModel.cpp:570:            if (!models[i]->isMaster_)
Draw:63:AnimatedModel.cpp:571:                models[i]->ResetMorphWeights();
Draw:64:AnimatedModel.cpp:588:        if (i->name_ == name)
Draw:65:AnimatedModel.cpp:589:            return i->weight_;
Draw:66:AnimatedModel.cpp:599:        if (i->nameHash_ == nameHash)
Draw:67:AnimatedModel.cpp:600:            return i->weight_;
Draw:68:AnimatedModel.cpp:610:        if ((*i)->GetAnimation() == animation)
Draw:69:AnimatedModel.cpp:626:        Animation* animation = (*i)->GetAnimation();
Draw:70:AnimatedModel.cpp:630:            if (animation->GetNameHash() == animationNameHash || animation->GetAnimationNameHash() == animationNameHash)
Draw:71:AnimatedModel.cpp:695:            if (i->collisionMask_ & BONECOLLISION_BOX && i->boundingBox_.Size().Length() < M_EPSILON)
Draw:72:AnimatedModel.cpp:696:                i->collisionMask_ &= ~BONECOLLISION_BOX;
Draw:73:AnimatedModel.cpp:697:            if (i->collisionMask_ & BONECOLLISION_SPHERE && i->radius_ < M_EPSILON)
Draw:74:AnimatedModel.cpp:698:                i->collisionMask_ &= ~BONECOLLISION_SPHERE;
Draw:75:AnimatedModel.cpp:707:                Node* boneNode = node_->CreateChild(i->name_, LOCAL);
Draw:76:AnimatedModel.cpp:708:                boneNode->AddListener(this);
Draw:77:AnimatedModel.cpp:709:                boneNode->SetTransform(i->initialPosition_, i->initialRotation_, i->initialScale_);
Draw:78:AnimatedModel.cpp:710:                i->node_ = boneNode;
Draw:79:AnimatedModel.cpp:717:                    bones[parentIndex].node_->AddChild(bones[i].node_);
Draw:80:AnimatedModel.cpp:725:        node_->SendEvent(E_BONEHIERARCHYCREATED, eventData);
Draw:81:AnimatedModel.cpp:729:        // For non-master models: use the bone nodes of the master model
Draw:82:AnimatedModel.cpp:737:                Node* boneNode = node_->GetChild(i->name_, true);
Draw:83:AnimatedModel.cpp:739:                    boneNode->AddListener(this);
Draw:84:AnimatedModel.cpp:740:                i->node_ = boneNode;
Draw:85:AnimatedModel.cpp:755:    // When loading a scene, set model without creating the bone nodes (will be assigned later during post-load)
Draw:86:AnimatedModel.cpp:756:    SetModel(cache->GetResource<Model>(value.name_), !loading_);
Draw:87:AnimatedModel.cpp:779:    while (numStates--)
Draw:88:AnimatedModel.cpp:785:            SharedPtr<AnimationState> newState(new AnimationState(this, cache->GetResource<Animation>(animRef.name_)));
Draw:89:AnimatedModel.cpp:788:            newState->SetStartBone(skeleton_.GetBone(value[index++].GetString()));
Draw:90:AnimatedModel.cpp:789:            newState->SetLooped(value[index++].GetBool());
Draw:91:AnimatedModel.cpp:790:            newState->SetWeight(value[index++].GetFloat());
Draw:92:AnimatedModel.cpp:791:            newState->SetTime(value[index++].GetFloat());
Draw:93:AnimatedModel.cpp:792:            newState->SetLayer(value[index++].GetInt());
Draw:94:AnimatedModel.cpp:826:        ret.Push(i->animated_);
Draw:95:AnimatedModel.cpp:838:        Animation* animation = state->GetAnimation();
Draw:96:AnimatedModel.cpp:839:        Bone* startBone = state->GetStartBone();
Draw:97:AnimatedModel.cpp:841:        ret.Push(startBone ? startBone->name_ : String::EMPTY);
Draw:98:AnimatedModel.cpp:842:        ret.Push(state->IsLooped());
Draw:99:AnimatedModel.cpp:843:        ret.Push(state->GetWeight());
Draw:100:AnimatedModel.cpp:844:        ret.Push(state->GetTime());
Draw:101:AnimatedModel.cpp:845:        ret.Push((int)state->GetLayer());
Draw:102:AnimatedModel.cpp:854:        attrBuffer_.WriteUByte((unsigned char)(i->weight_ * 255.0f));
Draw:103:AnimatedModel.cpp:887:        worldBoundingBox_ = boneBoundingBox_.Transformed(node_->GetWorldTransform());
Draw:104:AnimatedModel.cpp:891:        // Non-master animated models get the bounding box from the master
Draw:105:AnimatedModel.cpp:893:        AnimatedModel* master = node_->GetComponent<AnimatedModel>();
Draw:106:AnimatedModel.cpp:898:            worldBoundingBox_ = master->GetWorldBoundingBox();
Draw:107:AnimatedModel.cpp:914:        Node* boneNode = node_->GetChild(i->name_, true);
Draw:108:AnimatedModel.cpp:918:            boneNode->AddListener(this);
Draw:109:AnimatedModel.cpp:920:        i->node_ = boneNode;
Draw:110:AnimatedModel.cpp:926:        SetSkeleton(model_->GetSkeleton(), true);
Draw:111:AnimatedModel.cpp:928:    // Re-assign the same start bone to animations to get the proper bone node this time
Draw:112:AnimatedModel.cpp:932:        state->SetStartBone(state->GetStartBone());
Draw:113:AnimatedModel.cpp:939:    if (rootBone && rootBone->node_)
Draw:114:AnimatedModel.cpp:940:        rootBone->node_->Remove();
Draw:115:AnimatedModel.cpp:968:    const Vector<SharedPtr<VertexBuffer> >& originalVertexBuffers = model_->GetVertexBuffers();
Draw:116:AnimatedModel.cpp:975:        if (model_->GetMorphRangeCount(i))
Draw:117:AnimatedModel.cpp:978:            clone->SetShadowed(true);
Draw:118:AnimatedModel.cpp:979:            clone->SetSize(original->GetVertexCount(), morphElementMask_ & original->GetElementMask(), true);
Draw:119:AnimatedModel.cpp:980:            void* dest = clone->Lock(0, original->GetVertexCount());
Draw:120:AnimatedModel.cpp:983:                CopyMorphVertices(dest, original->GetShadowData(), original->GetVertexCount(), clone, original);
Draw:121:AnimatedModel.cpp:984:                clone->Unlock();
Draw:122:AnimatedModel.cpp:1003:            const Vector<SharedPtr<VertexBuffer> >& originalBuffers = original->GetVertexBuffers();
Draw:123:AnimatedModel.cpp:1011:            clone->SetNumVertexBuffers(totalBuf);
Draw:124:AnimatedModel.cpp:1017:                unsigned originalMask = original->GetVertexElementMask(k);
Draw:125:AnimatedModel.cpp:1022:                    clone->SetVertexBuffer(l++, originalBuffer, originalMask & ~clonedBuffer->GetElementMask());
Draw:126:AnimatedModel.cpp:1023:                    clone->SetVertexBuffer(l++, clonedBuffer, originalMask & clonedBuffer->GetElementMask());
Draw:127:AnimatedModel.cpp:1026:                    clone->SetVertexBuffer(l++, originalBuffer, originalMask);
Draw:128:AnimatedModel.cpp:1029:            clone->SetIndexBuffer(original->GetIndexBuffer());
Draw:129:AnimatedModel.cpp:1030:            clone->SetDrawRange(original->GetPrimitiveType(), original->GetIndexStart(), original->GetIndexCount());
Draw:130:AnimatedModel.cpp:1031:            clone->SetLodDistance(original->GetLodDistance());
Draw:131:AnimatedModel.cpp:1044:    unsigned mask = destBuffer->GetElementMask() & srcBuffer->GetElementMask();
Draw:132:AnimatedModel.cpp:1045:    unsigned normalOffset = srcBuffer->GetElementOffset(ELEMENT_NORMAL);
Draw:133:AnimatedModel.cpp:1046:    unsigned tangentOffset = srcBuffer->GetElementOffset(ELEMENT_TANGENT);
Draw:134:AnimatedModel.cpp:1047:    unsigned vertexSize = srcBuffer->GetVertexSize();
Draw:135:AnimatedModel.cpp:1051:    while (vertexCount--)
Draw:136:AnimatedModel.cpp:1100:    // Reserve space for per-geometry skinning matrices
Draw:137:AnimatedModel.cpp:1105:    // Build original-to-skinindex matrix pointer mapping for fast copying
Draw:138:AnimatedModel.cpp:1146:            (*i)->Apply();
Draw:139:AnimatedModel.cpp:1149:        node_->MarkDirty();
Draw:140:AnimatedModel.cpp:1164:        Matrix3x4 inverseNodeTransform = node_->GetWorldTransform().Inverse();
Draw:141:AnimatedModel.cpp:1169:            Node* boneNode = i->node_;
Draw:142:AnimatedModel.cpp:1175:            if (i->collisionMask_ & BONECOLLISION_BOX)
Draw:143:AnimatedModel.cpp:1176:                boneBoundingBox_.Merge(i->boundingBox_.Transformed(inverseNodeTransform * boneNode->GetWorldTransform()));
Draw:144:AnimatedModel.cpp:1177:            else if (i->collisionMask_ & BONECOLLISION_SPHERE)
Draw:145:AnimatedModel.cpp:1178:                boneBoundingBox_.Merge(Sphere(inverseNodeTransform * boneNode->GetWorldPosition(), i->radius_ * 0.5f));
Draw:146:AnimatedModel.cpp:1191:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
Draw:147:AnimatedModel.cpp:1200:                skinMatrices_[i] = bone.node_->GetWorldTransform() * bone.offsetMatrix_;
Draw:148:AnimatedModel.cpp:1205:    // Skinning with per-geometry matrices
Draw:149:AnimatedModel.cpp:1212:                skinMatrices_[i] = bone.node_->GetWorldTransform() * bone.offsetMatrix_;
Draw:150:AnimatedModel.cpp:1216:            // Copy the skin matrix to per-geometry matrices as needed
Draw:151:AnimatedModel.cpp:1239:                VertexBuffer* originalBuffer = model_->GetVertexBuffers()[i];
Draw:152:AnimatedModel.cpp:1240:                unsigned morphStart = model_->GetMorphRangeStart(i);
Draw:153:AnimatedModel.cpp:1241:                unsigned morphCount = model_->GetMorphRangeCount(i);
Draw:154:AnimatedModel.cpp:1243:                void* dest = buffer->Lock(morphStart, morphCount);
Draw:155:AnimatedModel.cpp:1247:                    CopyMorphVertices(dest, originalBuffer->GetShadowData() + morphStart * originalBuffer->GetVertexSize(),
Draw:156:AnimatedModel.cpp:1256:                                ApplyMorph(buffer, dest, morphStart, k->second_, morphs_[j].weight_);
Draw:157:AnimatedModel.cpp:1260:                    buffer->Unlock();
Draw:158:AnimatedModel.cpp:1271:    unsigned elementMask = morph.elementMask_ & buffer->GetElementMask();
Draw:159:AnimatedModel.cpp:1273:    unsigned normalOffset = buffer->GetElementOffset(ELEMENT_NORMAL);
Draw:160:AnimatedModel.cpp:1274:    unsigned tangentOffset = buffer->GetElementOffset(ELEMENT_TANGENT);
Draw:161:AnimatedModel.cpp:1275:    unsigned vertexSize = buffer->GetVertexSize();
Draw:162:AnimatedModel.cpp:1280:    while (vertexCount--)
Draw:163:AnimatedModel.cpp:1282:        unsigned vertexIndex = *((unsigned*)srcData) - morphRangeStart;
Draw:164:AnimatedModel.cpp:1318:    model_.Reset(); // Set null to allow to be re-set
Draw:165:AnimationController.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:166:AnimationController.h:64:    /// Animation autofade on stop -time, 0 if disabled.
Draw:167:AnimationController.h:66:    /// Set time command time-to-live.
Draw:168:AnimationController.h:68:    /// Set weight command time-to-live.
Draw:169:AnimationController.h:125:    /// Set animation autofade on stop (non-looped animations only.) Zero time disables. Return true on success.
Draw:170:AnimationController.h:185:    /// Handle scene post-update event.
Draw:171:AnimationController.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:172:AnimationController.cpp:62:    context->RegisterFactory<AnimationController>(LOGIC_CATEGORY);
Draw:173:AnimationController.cpp:88:        AnimationState* state = GetAnimationState(i->hash_);
Draw:174:AnimationController.cpp:94:            if (i->speed_ != 0.0f)
Draw:175:AnimationController.cpp:95:                state->AddTime(i->speed_ * timeStep);
Draw:176:AnimationController.cpp:97:            float targetWeight = i->targetWeight_;
Draw:177:AnimationController.cpp:98:            float fadeTime = i->fadeTime_;
Draw:178:AnimationController.cpp:100:            // If non-looped animation at the end, activate autofade as applicable
Draw:179:AnimationController.cpp:101:            if (!state->IsLooped() && state->GetTime() >= state->GetLength() && i->autoFadeTime_ > 0.0f)
Draw:180:AnimationController.cpp:104:                fadeTime = i->autoFadeTime_;
Draw:181:AnimationController.cpp:108:            float currentWeight = state->GetWeight();
Draw:182:AnimationController.cpp:117:                        currentWeight = Max(currentWeight - weightDelta, targetWeight);
Draw:183:AnimationController.cpp:118:                    state->SetWeight(currentWeight);
Draw:184:AnimationController.cpp:121:                    state->SetWeight(targetWeight);
Draw:185:AnimationController.cpp:125:            if (state->GetWeight() == 0.0f && (targetWeight == 0.0f || fadeTime == 0.0f))
Draw:186:AnimationController.cpp:129:        // Decrement the command time-to-live values
Draw:187:AnimationController.cpp:130:        if (i->setTimeTtl_ > 0.0f)
Draw:188:AnimationController.cpp:131:            i->setTimeTtl_ = Max(i->setTimeTtl_ - timeStep, 0.0f);
Draw:189:AnimationController.cpp:132:        if (i->setWeightTtl_ > 0.0f)
Draw:190:AnimationController.cpp:133:            i->setWeightTtl_ = Max(i->setWeightTtl_ - timeStep, 0.0f);
Draw:191:AnimationController.cpp:148:        (*i)->Apply();
Draw:192:AnimationController.cpp:160:        Animation* newAnimation = GetSubsystem<ResourceCache>()->GetResource<Animation>(name);
Draw:193:AnimationController.cpp:169:        Animation* animation = state->GetAnimation();
Draw:194:AnimationController.cpp:170:        newControl.name_ = animation->GetName();
Draw:195:AnimationController.cpp:171:        newControl.hash_ = animation->GetNameHash();
Draw:196:AnimationController.cpp:173:        index = animations_.Size() - 1;
Draw:197:AnimationController.cpp:176:    state->SetLayer(layer);
Draw:198:AnimationController.cpp:177:    state->SetLooped(looped);
Draw:199:AnimationController.cpp:211:        AnimationState* state = GetAnimationState(i->hash_);
Draw:200:AnimationController.cpp:212:        if (state && state->GetLayer() == layer)
Draw:201:AnimationController.cpp:214:            i->targetWeight_ = 0.0f;
Draw:202:AnimationController.cpp:215:            i->fadeTime_ = fadeOutTime;
Draw:203:AnimationController.cpp:230:            i->targetWeight_ = 0.0f;
Draw:204:AnimationController.cpp:231:            i->fadeTime_ = fadeOutTime;
Draw:205:AnimationController.cpp:260:    unsigned char layer = state->GetLayer();
Draw:206:AnimationController.cpp:269:            if (otherState && otherState->GetLayer() == layer)
Draw:207:AnimationController.cpp:289:    state->SetLayer(layer);
Draw:208:AnimationController.cpp:301:    AnimationState* state = model->GetAnimationState(name);
Draw:209:AnimationController.cpp:305:    Bone* bone = model->GetSkeleton().GetBone(startBoneName);
Draw:210:AnimationController.cpp:306:    state->SetStartBone(bone);
Draw:211:AnimationController.cpp:319:    time = Clamp(time, 0.0f, state->GetLength());
Draw:212:AnimationController.cpp:320:    state->SetTime(time);
Draw:213:AnimationController.cpp:322:    animations_[index].setTime_ = (unsigned short)(time / state->GetLength() * 65535.0f);
Draw:214:AnimationController.cpp:351:    state->SetWeight(weight);
Draw:215:AnimationController.cpp:366:    state->SetLooped(enable);
Draw:216:AnimationController.cpp:400:    return animations_[index].fadeTime_ && animations_[index].targetWeight_ > state->GetWeight();
Draw:217:AnimationController.cpp:411:    return (animations_[index].fadeTime_ && animations_[index].targetWeight_ < state->GetWeight())
Draw:218:AnimationController.cpp:412:        || (!state->IsLooped() && state->GetTime() >= state->GetLength() && animations_[index].autoFadeTime_);
Draw:219:AnimationController.cpp:418:    return state ? state->GetLayer() : 0;
Draw:220:AnimationController.cpp:424:    return state ? state->GetStartBone() : 0;
Draw:221:AnimationController.cpp:430:    return bone ? bone->name_ : String::EMPTY;
Draw:222:AnimationController.cpp:436:    return state ? state->GetTime() : 0.0f;
Draw:223:AnimationController.cpp:442:    return state ? state->GetWeight() : 0.0f;
Draw:224:AnimationController.cpp:448:    return state ? state->IsLooped() : false;
Draw:225:AnimationController.cpp:454:    return state ? state->GetLength() : 0.0f;
Draw:226:AnimationController.cpp:499:        return model->GetAnimationState(nameHash);
Draw:227:AnimationController.cpp:504:        Animation* animation = (*i)->GetAnimation();
Draw:228:AnimationController.cpp:505:        if (animation->GetNameHash() == nameHash || animation->GetAnimationNameHash() == nameHash)
Draw:229:AnimationController.cpp:517:    while (index + 4 < value.Size())    // Prevent out-of-bound index access
Draw:230:AnimationController.cpp:540:    while (numAnimations--)
Draw:231:AnimationController.cpp:550:            Animation* newAnimation = GetSubsystem<ResourceCache>()->GetResource<Animation>(animName);
Draw:232:AnimationController.cpp:574:        state->SetLayer(buf.ReadUByte());
Draw:233:AnimationController.cpp:575:        state->SetLooped((ctrl & CTRL_LOOPED) != 0);
Draw:234:AnimationController.cpp:583:                state->SetStartBone(model->GetSkeleton().GetBone(boneHash));
Draw:235:AnimationController.cpp:586:            state->SetStartBone(0);
Draw:236:AnimationController.cpp:598:                state->SetTime(((float)setTime / 65535.0f) * state->GetLength());
Draw:237:AnimationController.cpp:609:                state->SetWeight((float)setWeight / 255.0f);
Draw:238:AnimationController.cpp:618:        if (!processedAnimations.Contains(i->hash_))
Draw:239:AnimationController.cpp:620:            i->targetWeight_ = 0.0f;
Draw:240:AnimationController.cpp:621:            i->fadeTime_ = EXTRA_ANIM_FADEOUT_TIME;
Draw:241:AnimationController.cpp:639:    while (numStates--)
Draw:242:AnimationController.cpp:645:            SharedPtr<AnimationState> newState(new AnimationState(GetNode(), cache->GetResource<Animation>(animRef.name_)));
Draw:243:AnimationController.cpp:648:            newState->SetLooped(value[index++].GetBool());
Draw:244:AnimationController.cpp:649:            newState->SetTime(value[index++].GetFloat());
Draw:245:AnimationController.cpp:666:        ret.Push(i->name_);
Draw:246:AnimationController.cpp:667:        ret.Push(i->speed_);
Draw:247:AnimationController.cpp:668:        ret.Push(i->targetWeight_);
Draw:248:AnimationController.cpp:669:        ret.Push(i->fadeTime_);
Draw:249:AnimationController.cpp:670:        ret.Push(i->autoFadeTime_);
Draw:250:AnimationController.cpp:684:        if (GetAnimationState(i->hash_))
Draw:251:AnimationController.cpp:691:        AnimationState* state = GetAnimationState(i->hash_);
Draw:252:AnimationController.cpp:696:        Bone* startBone = state->GetStartBone();
Draw:253:AnimationController.cpp:697:        if (state->IsLooped())
Draw:254:AnimationController.cpp:699:        if (startBone && model && startBone != model->GetSkeleton().GetRootBone())
Draw:255:AnimationController.cpp:701:        if (i->autoFadeTime_ > 0.0f)
Draw:256:AnimationController.cpp:703:        if (i->setTimeTtl_ > 0.0f)
Draw:257:AnimationController.cpp:705:        if (i->setWeightTtl_ > 0.0f)
Draw:258:AnimationController.cpp:708:        attrBuffer_.WriteString(i->name_);
Draw:259:AnimationController.cpp:710:        attrBuffer_.WriteUByte(state->GetLayer());
Draw:260:AnimationController.cpp:711:        attrBuffer_.WriteShort((short)Clamp(i->speed_ * 2048.0f, -32767.0f, 32767.0f));
Draw:261:AnimationController.cpp:712:        attrBuffer_.WriteUByte((unsigned char)(i->targetWeight_ * 255.0f));
Draw:262:AnimationController.cpp:713:        attrBuffer_.WriteUByte((unsigned char)Clamp(i->fadeTime_ * 64.0f, 0.0f, 255.0f));
Draw:263:AnimationController.cpp:715:            attrBuffer_.WriteStringHash(startBone->nameHash_);
Draw:264:AnimationController.cpp:717:            attrBuffer_.WriteUByte((unsigned char)Clamp(i->autoFadeTime_ * 64.0f, 0.0f, 255.0f));
Draw:265:AnimationController.cpp:720:            attrBuffer_.WriteUByte(i->setTimeRev_);
Draw:266:AnimationController.cpp:721:            attrBuffer_.WriteUShort(i->setTime_);
Draw:267:AnimationController.cpp:725:            attrBuffer_.WriteUByte(i->setWeightRev_);
Draw:268:AnimationController.cpp:726:            attrBuffer_.WriteUByte(i->setWeight_);
Draw:269:AnimationController.cpp:741:        Animation* animation = state->GetAnimation();
Draw:270:AnimationController.cpp:743:        ret.Push(state->IsLooped());
Draw:271:AnimationController.cpp:744:        ret.Push(state->GetTime());
Draw:272:AnimationController.cpp:767:        return model->AddAnimationState(animation);
Draw:273:AnimationController.cpp:784:        model->RemoveAnimationState(state);
Draw:274:AnimationController.cpp:808:        nameHash = state->GetAnimation()->GetNameHash();
Draw:275:AnimationState.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:276:AnimationState.h:39:/// %Animation instance per-track data.
Draw:277:AnimationState.h:70:    /// Set start bone. Not supported in node animation mode. Resets any assigned per-bone weights.
Draw:278:AnimationState.h:78:    /// Set per-bone blending weight by track index. Default is 1.0 (full), is multiplied  with the state's blending weight when applying the animation. Optionally recurses to child bones.
Draw:279:AnimationState.h:80:    /// Set per-bone blending weight by name.
Draw:280:AnimationState.h:82:    /// Set per-bone blending weight by name hash.
Draw:281:AnimationState.h:99:    /// Return per-bone blending weight by track index.
Draw:282:AnimationState.h:101:    /// Return per-bone blending weight by name.
Draw:283:AnimationState.h:103:    /// Return per-bone blending weight by name.
Draw:284:AnimationState.h:147:    /// Per-track data.
Draw:285:AnimationState.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:286:AnimationState.cpp:75:            const Vector<AnimationTrack>& tracks = animation_->GetTracks();
Draw:287:AnimationState.cpp:84:                if (node_->GetNameHash() == nameHash || tracks.Size() == 1)
Draw:288:AnimationState.cpp:88:                    Node* targetNode = node_->GetChild(nameHash, true);
Draw:289:AnimationState.cpp:92:                        LOGWARNING("Node " + tracks[i].name_ + " not found for node animation " + animation_->GetName());
Draw:290:AnimationState.cpp:112:    Skeleton& skeleton = model_->GetSkeleton();
Draw:291:AnimationState.cpp:127:    const Vector<AnimationTrack>& tracks = animation_->GetTracks();
Draw:292:AnimationState.cpp:130:    if (!startBone->node_)
Draw:293:AnimationState.cpp:142:        if (nameHash == startBone->nameHash_)
Draw:294:AnimationState.cpp:146:            Node* trackBoneNode = startBone->node_->GetChild(nameHash, true);
Draw:295:AnimationState.cpp:151:        if (trackBone && trackBone->node_)
Draw:296:AnimationState.cpp:154:            stateTrack.node_ = trackBone->node_;
Draw:297:AnimationState.cpp:159:    model_->MarkAnimationDirty();
Draw:298:AnimationState.cpp:176:            model_->MarkAnimationDirty();
Draw:299:AnimationState.cpp:186:    time = Clamp(time, 0.0f, animation_->GetLength());
Draw:300:AnimationState.cpp:191:            model_->MarkAnimationDirty();
Draw:301:AnimationState.cpp:206:            model_->MarkAnimationDirty();
Draw:302:AnimationState.cpp:214:            const Vector<SharedPtr<Node> >& children = boneNode->GetChildren();
Draw:303:AnimationState.cpp:248:    float length = animation_->GetLength();
Draw:304:AnimationState.cpp:257:            time -= length;
Draw:305:AnimationState.cpp:265:    if (animation_->GetNumTriggers())
Draw:306:AnimationState.cpp:273:                oldTime -= length;
Draw:307:AnimationState.cpp:281:                time -= length;
Draw:308:AnimationState.cpp:288:        const Vector<AnimationTriggerPoint>& triggers = animation_->GetTriggers();
Draw:309:AnimationState.cpp:291:            float frameTime = i->time_;
Draw:310:AnimationState.cpp:299:                Node* senderNode = model_ ? model_->GetNode() : node_;
Draw:311:AnimationState.cpp:301:                VariantMap& eventData = senderNode->GetEventDataMap();
Draw:312:AnimationState.cpp:303:                eventData[P_NAME] = animation_->GetAnimationName();
Draw:313:AnimationState.cpp:304:                eventData[P_TIME] = i->time_;
Draw:314:AnimationState.cpp:305:                eventData[P_DATA] = i->data_;
Draw:315:AnimationState.cpp:306:                senderNode->SendEvent(E_ANIMATIONTRIGGER, eventData);
Draw:316:AnimationState.cpp:318:            model_->MarkAnimationOrderDirty();
Draw:317:AnimationState.cpp:357:        if (node && node->GetName() == name)
Draw:318:AnimationState.cpp:380:        if (node && node->GetNameHash() == nameHash)
Draw:319:AnimationState.cpp:389:    return animation_ ? animation_->GetLength() : 0.0f;
Draw:320:AnimationState.cpp:411:        if (Equals(finalWeight, 0.0f) || !stateTrack.bone_->animated_)
Draw:321:AnimationState.cpp:433:    if (track->keyFrames_.Empty() || !node)
Draw:322:AnimationState.cpp:437:    track->GetKeyFrameIndex(time_, frame);
Draw:323:AnimationState.cpp:442:    if (nextFrame >= track->keyFrames_.Size())
Draw:324:AnimationState.cpp:453:    const AnimationKeyFrame* keyFrame = &track->keyFrames_[frame];
Draw:325:AnimationState.cpp:454:    unsigned char channelMask = track->channelMask_;
Draw:326:AnimationState.cpp:460:            node->SetPosition(keyFrame->position_);
Draw:327:AnimationState.cpp:462:            node->SetRotation(keyFrame->rotation_);
Draw:328:AnimationState.cpp:464:            node->SetScale(keyFrame->scale_);
Draw:329:AnimationState.cpp:468:        const AnimationKeyFrame* nextKeyFrame = &track->keyFrames_[nextFrame];
Draw:330:AnimationState.cpp:469:        float timeInterval = nextKeyFrame->time_ - keyFrame->time_;
Draw:331:AnimationState.cpp:471:            timeInterval += animation_->GetLength();
Draw:332:AnimationState.cpp:472:        float t = timeInterval > 0.0f ? (time_ - keyFrame->time_) / timeInterval : 1.0f;
Draw:333:AnimationState.cpp:476:            node->SetPosition(keyFrame->position_.Lerp(nextKeyFrame->position_, t));
Draw:334:AnimationState.cpp:478:            node->SetRotation(keyFrame->rotation_.Slerp(nextKeyFrame->rotation_, t));
Draw:335:AnimationState.cpp:480:            node->SetScale(keyFrame->scale_.Lerp(nextKeyFrame->scale_, t));
Draw:336:AnimationState.cpp:489:    if (track->keyFrames_.Empty() || !node)
Draw:337:AnimationState.cpp:493:    track->GetKeyFrameIndex(time_, frame);
Draw:338:AnimationState.cpp:498:    if (nextFrame >= track->keyFrames_.Size())
Draw:339:AnimationState.cpp:509:    const AnimationKeyFrame* keyFrame = &track->keyFrames_[frame];
Draw:340:AnimationState.cpp:510:    unsigned char channelMask = track->channelMask_;
Draw:341:AnimationState.cpp:516:            node->SetPositionSilent(keyFrame->position_);
Draw:342:AnimationState.cpp:518:            node->SetRotationSilent(keyFrame->rotation_);
Draw:343:AnimationState.cpp:520:            node->SetScaleSilent(keyFrame->scale_);
Draw:344:AnimationState.cpp:524:        const AnimationKeyFrame* nextKeyFrame = &track->keyFrames_[nextFrame];
Draw:345:AnimationState.cpp:525:        float timeInterval = nextKeyFrame->time_ - keyFrame->time_;
Draw:346:AnimationState.cpp:527:            timeInterval += animation_->GetLength();
Draw:347:AnimationState.cpp:528:        float t = timeInterval > 0.0f ? (time_ - keyFrame->time_) / timeInterval : 1.0f;
Draw:348:AnimationState.cpp:532:            node->SetPositionSilent(keyFrame->position_.Lerp(nextKeyFrame->position_, t));
Draw:349:AnimationState.cpp:534:            node->SetRotationSilent(keyFrame->rotation_.Slerp(nextKeyFrame->rotation_, t));
Draw:350:AnimationState.cpp:536:            node->SetScaleSilent(keyFrame->scale_.Lerp(nextKeyFrame->scale_, t));
Draw:351:AnimationState.cpp:545:    if (track->keyFrames_.Empty() || !node)
Draw:352:AnimationState.cpp:549:    track->GetKeyFrameIndex(time_, frame);
Draw:353:AnimationState.cpp:554:    if (nextFrame >= track->keyFrames_.Size())
Draw:354:AnimationState.cpp:565:    const AnimationKeyFrame* keyFrame = &track->keyFrames_[frame];
Draw:355:AnimationState.cpp:566:    unsigned char channelMask = track->channelMask_;
Draw:356:AnimationState.cpp:572:            node->SetPositionSilent(node->GetPosition().Lerp(keyFrame->position_, weight));
Draw:357:AnimationState.cpp:574:            node->SetRotationSilent(node->GetRotation().Slerp(keyFrame->rotation_, weight));
Draw:358:AnimationState.cpp:576:            node->SetScaleSilent(node->GetScale().Lerp(keyFrame->scale_, weight));
Draw:359:AnimationState.cpp:580:        const AnimationKeyFrame* nextKeyFrame = &track->keyFrames_[nextFrame];
Draw:360:AnimationState.cpp:581:        float timeInterval = nextKeyFrame->time_ - keyFrame->time_;
Draw:361:AnimationState.cpp:583:            timeInterval += animation_->GetLength();
Draw:362:AnimationState.cpp:584:        float t = timeInterval > 0.0f ? (time_ - keyFrame->time_) / timeInterval : 1.0f;
Draw:363:AnimationState.cpp:589:            node->SetPositionSilent(node->GetPosition().Lerp(
Draw:364:AnimationState.cpp:590:                keyFrame->position_.Lerp(nextKeyFrame->position_, t), weight));
Draw:365:AnimationState.cpp:594:            node->SetRotationSilent(node->GetRotation().Slerp(
Draw:366:AnimationState.cpp:595:                keyFrame->rotation_.Slerp(nextKeyFrame->rotation_, t), weight));
Draw:367:AnimationState.cpp:599:            node->SetScaleSilent(node->GetScale().Lerp(
Draw:368:AnimationState.cpp:600:                keyFrame->scale_.Lerp(nextKeyFrame->scale_, t), weight));
Draw:369:Batch.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:370:Batch.h:106:    /// 8-bit light mask for stencil marking in deferred rendering.
Draw:371:Batch.h:165:    /// Pre-set the instance transforms. Buffer must be big enough to hold all transforms.
Draw:372:Batch.h:172:    /// Instance stream start index, or M_MAX_UNSIGNED if transforms not pre-set.
Draw:373:Batch.h:214:/// Queue that contains both instanced and non-instanced draw calls.
Draw:374:Batch.h:220:    /// Sort non-instanced draw calls back to front.
Draw:375:Batch.h:222:    /// Sort instanced and non-instanced draw calls front to back.
Draw:376:Batch.h:226:    /// Pre-set instance transforms of all groups. The vertex buffer must be big enough to hold all transforms.
Draw:377:Batch.h:237:    /// Shader remapping table for 2-pass state and distance sort.
Draw:378:Batch.h:239:    /// Material remapping table for 2-pass state and distance sort.
Draw:379:Batch.h:241:    /// Geometry remapping table for 2-pass state and distance sort.
Draw:380:Batch.h:244:    /// Unsorted non-instanced draw calls.
Draw:381:Batch.h:246:    /// Sorted non-instanced draw calls.
Draw:382:Batch.h:272:    /// Per-pixel light.
Draw:383:Batch.h:280:    /// Lit geometry draw calls, non-base (additive)
Draw:384:Batch.h:284:    /// Per-vertex lights.
Draw:385:Batch.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:386:Batch.cpp:47:    if (lhs->sortKey_ != rhs->sortKey_)
Draw:387:Batch.cpp:48:        return lhs->sortKey_ < rhs->sortKey_;
Draw:388:Batch.cpp:50:        return lhs->distance_ < rhs->distance_;
Draw:389:Batch.cpp:55:    if (lhs->distance_ != rhs->distance_)
Draw:390:Batch.cpp:56:        return lhs->distance_ < rhs->distance_;
Draw:391:Batch.cpp:58:        return lhs->sortKey_ < rhs->sortKey_;
Draw:392:Batch.cpp:63:    if (lhs->distance_ != rhs->distance_)
Draw:393:Batch.cpp:64:        return lhs->distance_ > rhs->distance_;
Draw:394:Batch.cpp:66:        return lhs->sortKey_ < rhs->sortKey_;
Draw:395:Batch.cpp:76:    Camera* shadowCamera = queue->shadowSplits_[split].shadowCamera_;
Draw:396:Batch.cpp:77:    const IntRect& viewport = queue->shadowSplits_[split].shadowViewport_;
Draw:397:Batch.cpp:80:    Matrix3x4 shadowView(shadowCamera->GetView());
Draw:398:Batch.cpp:81:    Matrix4 shadowProj(shadowCamera->GetProjection());
Draw:399:Batch.cpp:84:    Texture2D* shadowMap = queue->shadowMap_;
Draw:400:Batch.cpp:88:    float width = (float)shadowMap->GetWidth();
Draw:401:Batch.cpp:89:    float height = (float)shadowMap->GetHeight();
Draw:402:Batch.cpp:103:    // Add pixel-perfect offset if needed by the graphics API
Draw:403:Batch.cpp:111:    offset.y_ = 1.0f - offset.y_;
Draw:404:Batch.cpp:113:    scale.y_ = -scale.y_;
Draw:405:Batch.cpp:117:    if (renderer->GetShadowQuality() & SHADOWQUALITY_HIGH_16BIT)
Draw:406:Batch.cpp:119:        offset.x_ -= 0.5f / width;
Draw:407:Batch.cpp:120:        offset.y_ -= 0.5f / height;
Draw:408:Batch.cpp:130:    Node* lightNode = light->GetNode();
Draw:409:Batch.cpp:132:    Matrix3x4 spotView = Matrix3x4(lightNode->GetWorldPosition(), lightNode->GetWorldRotation(), 1.0f).Inverse();
Draw:410:Batch.cpp:137:    float h = 1.005f / tanf(light->GetFov() * M_DEGTORAD * 0.5f);
Draw:411:Batch.cpp:138:    float w = h / light->GetAspectRatio();
Draw:412:Batch.cpp:141:    spotProj.m22_ = 1.0f / Max(light->GetRange(), M_EPSILON);
Draw:413:Batch.cpp:146:    texAdjust.SetScale(Vector3(0.5f, -0.5f, 0.5f));
Draw:414:Batch.cpp:149:    texAdjust.SetScale(Vector3(0.5f, -0.5f, 1.0f));
Draw:415:Batch.cpp:160:    if (pass_ && pass_->GetAlphaMask())
Draw:416:Batch.cpp:176:    Graphics* graphics = view->GetGraphics();
Draw:417:Batch.cpp:177:    Renderer* renderer = view->GetRenderer();
Draw:418:Batch.cpp:178:    Node* cameraNode = camera_ ? camera_->GetNode() : 0;
Draw:419:Batch.cpp:179:    Light* light = lightQueue_ ? lightQueue_->light_ : 0;
Draw:420:Batch.cpp:180:    Texture2D* shadowMap = lightQueue_ ? lightQueue_->shadowMap_ : 0;
Draw:421:Batch.cpp:183:    graphics->SetShaders(vertexShader_, pixelShader_);
Draw:422:Batch.cpp:185:    // Set pass / material-specific renderstates
Draw:423:Batch.cpp:188:        BlendMode blend = pass_->GetBlendMode();
Draw:424:Batch.cpp:190:        if (light && light->IsNegative())
Draw:425:Batch.cpp:197:        graphics->SetBlendMode(blend);
Draw:426:Batch.cpp:199:        bool isShadowPass = pass_->GetIndex() == Technique::shadowPassIndex;
Draw:427:Batch.cpp:200:        renderer->SetCullMode(isShadowPass ? material_->GetShadowCullMode() : material_->GetCullMode(), camera_);
Draw:428:Batch.cpp:203:            const BiasParameters& depthBias = material_->GetDepthBias();
Draw:429:Batch.cpp:204:            graphics->SetDepthBias(depthBias.constantBias_, depthBias.slopeScaledBias_);
Draw:430:Batch.cpp:208:        graphics->SetFillMode((FillMode)(Max(camera_->GetFillMode(), material_->GetFillMode())));
Draw:431:Batch.cpp:209:        graphics->SetDepthTest(pass_->GetDepthTestMode());
Draw:432:Batch.cpp:210:        graphics->SetDepthWrite(pass_->GetDepthWrite() && allowDepthWrite);
Draw:433:Batch.cpp:213:    // Set global (per-frame) shader parameters
Draw:434:Batch.cpp:214:    if (graphics->NeedParameterUpdate(SP_FRAME, (void*)0))
Draw:435:Batch.cpp:215:        view->SetGlobalShaderParameters();
Draw:436:Batch.cpp:219:    IntRect viewport = graphics->GetViewport();
Draw:437:Batch.cpp:222:    if (graphics->NeedParameterUpdate(SP_CAMERA, reinterpret_cast<const void*>(cameraHash + viewportHash)))
Draw:438:Batch.cpp:224:        view->SetCameraShaderParameters(camera_, true);
Draw:439:Batch.cpp:225:        // During renderpath commands the G-Buffer or viewport texture is assumed to always be viewport-sized
Draw:440:Batch.cpp:226:        view->SetGBufferShaderParameters(viewSize, IntRect(0, 0, viewSize.x_, viewSize.y_));
Draw:441:Batch.cpp:230:    if (setModelTransform && graphics->NeedParameterUpdate(SP_OBJECT, worldTransform_))
Draw:442:Batch.cpp:234:            graphics->SetShaderParameter(VSP_SKINMATRICES, reinterpret_cast<const float*>(worldTransform_), 
Draw:443:Batch.cpp:238:            graphics->SetShaderParameter(VSP_MODEL, *worldTransform_);
Draw:444:Batch.cpp:244:                graphics->SetShaderParameter(VSP_BILLBOARDROT, worldTransform_[1].RotationMatrix());
Draw:445:Batch.cpp:246:                graphics->SetShaderParameter(VSP_BILLBOARDROT, cameraNode->GetWorldRotation().RotationMatrix());
Draw:446:Batch.cpp:250:    // Set zone-related shader parameters
Draw:447:Batch.cpp:251:    BlendMode blend = graphics->GetBlendMode();
Draw:448:Batch.cpp:257:    if (zone_ && graphics->NeedParameterUpdate(SP_ZONE, reinterpret_cast<const void*>(zoneHash)))
Draw:449:Batch.cpp:259:        graphics->SetShaderParameter(VSP_AMBIENTSTARTCOLOR, zone_->GetAmbientStartColor());
Draw:450:Batch.cpp:260:        graphics->SetShaderParameter(VSP_AMBIENTENDCOLOR, zone_->GetAmbientEndColor().ToVector4() - zone_->GetAmbientStartColor().ToVector4());
Draw:451:Batch.cpp:262:        const BoundingBox& box = zone_->GetBoundingBox();
Draw:452:Batch.cpp:267:        Matrix3x4 zoneTransform = adjust * zone_->GetInverseWorldTransform();
Draw:453:Batch.cpp:268:        graphics->SetShaderParameter(VSP_ZONE, zoneTransform);
Draw:454:Batch.cpp:270:        graphics->SetShaderParameter(PSP_AMBIENTCOLOR, zone_->GetAmbientColor());
Draw:455:Batch.cpp:271:        graphics->SetShaderParameter(PSP_FOGCOLOR, overrideFogColorToBlack ? Color::BLACK : zone_->GetFogColor());
Draw:456:Batch.cpp:273:        float farClip = camera_->GetFarClip();
Draw:457:Batch.cpp:274:        float fogStart = Min(zone_->GetFogStart(), farClip);
Draw:458:Batch.cpp:275:        float fogEnd = Min(zone_->GetFogEnd(), farClip);
Draw:459:Batch.cpp:276:        if (fogStart >= fogEnd * (1.0f - M_LARGE_EPSILON))
Draw:460:Batch.cpp:277:            fogStart = fogEnd * (1.0f - M_LARGE_EPSILON);
Draw:461:Batch.cpp:278:        float fogRange = Max(fogEnd - fogStart, M_EPSILON);
Draw:462:Batch.cpp:281:        Node* zoneNode = zone_->GetNode();
Draw:463:Batch.cpp:282:        if (zone_->GetHeightFog() && zoneNode)
Draw:464:Batch.cpp:284:            Vector3 worldFogHeightVec = zoneNode->GetWorldTransform() * Vector3(0.0f, zone_->GetFogHeight(), 0.0f);
Draw:465:Batch.cpp:286:            fogParams.w_ = zone_->GetFogHeightScale() / Max(zoneNode->GetWorldScale().y_, M_EPSILON);
Draw:466:Batch.cpp:289:        graphics->SetShaderParameter(PSP_FOGPARAMS, fogParams);
Draw:467:Batch.cpp:292:    // Set light-related shader parameters
Draw:468:Batch.cpp:295:        if (light && graphics->NeedParameterUpdate(SP_LIGHT, lightQueue_))
Draw:469:Batch.cpp:297:            // Deferred light volume batches operate in a camera-centered space. Detect from material, zone & pass all being null
Draw:470:Batch.cpp:300:            Matrix3x4 cameraEffectiveTransform = camera_->GetEffectiveWorldTransform();
Draw:471:Batch.cpp:303:            Node* lightNode = light->GetNode();
Draw:472:Batch.cpp:304:            Matrix3 lightWorldRotation = lightNode->GetWorldRotation().RotationMatrix();
Draw:473:Batch.cpp:306:            graphics->SetShaderParameter(VSP_LIGHTDIR, lightWorldRotation * Vector3::BACK);
Draw:474:Batch.cpp:308:            float atten = 1.0f / Max(light->GetRange(), M_EPSILON);
Draw:475:Batch.cpp:309:            graphics->SetShaderParameter(VSP_LIGHTPOS, Vector4(lightNode->GetWorldPosition(), atten));
Draw:476:Batch.cpp:311:            if (graphics->HasShaderParameter(VSP_LIGHTMATRICES))
Draw:477:Batch.cpp:313:                switch (light->GetLightType())
Draw:478:Batch.cpp:318:                    unsigned numSplits = Min(MAX_CASCADE_SPLITS, (int)lightQueue_->shadowSplits_.Size());
Draw:479:Batch.cpp:323:                    graphics->SetShaderParameter(VSP_LIGHTMATRICES, shadowMatrices[0].Data(), 16 * numSplits);
Draw:480:Batch.cpp:332:                    bool isShadowed = shadowMap && graphics->HasTextureUnit(TU_SHADOWMAP);
Draw:481:Batch.cpp:336:                    graphics->SetShaderParameter(VSP_LIGHTMATRICES, shadowMatrices[0].Data(), isShadowed ? 32 : 16);
Draw:482:Batch.cpp:342:                    Matrix4 lightVecRot(lightNode->GetWorldRotation().RotationMatrix());
Draw:483:Batch.cpp:346:                    graphics->SetShaderParameter(VSP_LIGHTMATRICES, lightVecRot.Data(), 16);
Draw:484:Batch.cpp:348:                    graphics->SetShaderParameter(VSP_LIGHTMATRICES, lightVecRot.Data(), 12);
Draw:485:Batch.cpp:356:            float fadeEnd = light->GetDrawDistance();
Draw:486:Batch.cpp:357:            float fadeStart = light->GetFadeDistance();
Draw:487:Batch.cpp:360:            if (light->GetLightType() != LIGHT_DIRECTIONAL && fadeEnd > 0.0f && fadeStart > 0.0f && fadeStart < fadeEnd)
Draw:488:Batch.cpp:361:                fade = Min(1.0f - (light->GetDistance() - fadeStart) / (fadeEnd - fadeStart), 1.0f);
Draw:489:Batch.cpp:364:            graphics->SetShaderParameter(PSP_LIGHTCOLOR, Color(light->GetEffectiveColor().Abs(),
Draw:490:Batch.cpp:365:                light->GetEffectiveSpecularIntensity()) * fade);
Draw:491:Batch.cpp:366:            graphics->SetShaderParameter(PSP_LIGHTDIR, lightWorldRotation * Vector3::BACK);
Draw:492:Batch.cpp:367:            graphics->SetShaderParameter(PSP_LIGHTPOS, Vector4((isLightVolume ? (lightNode->GetWorldPosition() -
Draw:493:Batch.cpp:368:                cameraEffectivePos) : lightNode->GetWorldPosition()), atten));
Draw:494:Batch.cpp:370:            if (graphics->HasShaderParameter(PSP_LIGHTMATRICES))
Draw:495:Batch.cpp:372:                switch (light->GetLightType())
Draw:496:Batch.cpp:377:                    unsigned numSplits = Min(MAX_CASCADE_SPLITS, (int)lightQueue_->shadowSplits_.Size());
Draw:497:Batch.cpp:384:                    graphics->SetShaderParameter(PSP_LIGHTMATRICES, shadowMatrices[0].Data(), 16 * numSplits);
Draw:498:Batch.cpp:393:                    bool isShadowed = lightQueue_->shadowMap_ != 0;
Draw:499:Batch.cpp:400:                    graphics->SetShaderParameter(PSP_LIGHTMATRICES, shadowMatrices[0].Data(), isShadowed ? 32 : 16);
Draw:500:Batch.cpp:406:                    Matrix4 lightVecRot(lightNode->GetWorldRotation().RotationMatrix());
Draw:501:Batch.cpp:410:                    graphics->SetShaderParameter(PSP_LIGHTMATRICES, lightVecRot.Data(), 16);
Draw:502:Batch.cpp:412:                    graphics->SetShaderParameter(PSP_LIGHTMATRICES, lightVecRot.Data(), 12);
Draw:503:Batch.cpp:424:                    unsigned faceWidth = shadowMap->GetWidth() / 2;
Draw:504:Batch.cpp:425:                    unsigned faceHeight = shadowMap->GetHeight() / 3;
Draw:505:Batch.cpp:426:                    float width = (float)shadowMap->GetWidth();
Draw:506:Batch.cpp:427:                    float height = (float)shadowMap->GetHeight();
Draw:507:Batch.cpp:429:                    float mulX = (float)(faceWidth - 3) / width;
Draw:508:Batch.cpp:430:                    float mulY = (float)(faceHeight - 3) / height;
Draw:509:Batch.cpp:434:                    float mulX = (float)(faceWidth - 4) / width;
Draw:510:Batch.cpp:435:                    float mulY = (float)(faceHeight - 4) / height;
Draw:511:Batch.cpp:440:                    if (renderer->GetShadowQuality() & SHADOWQUALITY_HIGH_16BIT)
Draw:512:Batch.cpp:442:                        addX -= 0.5f / width;
Draw:513:Batch.cpp:443:                        addY -= 0.5f / height;
Draw:514:Batch.cpp:445:                    graphics->SetShaderParameter(PSP_SHADOWCUBEADJUST, Vector4(mulX, mulY, addX, addY));
Draw:515:Batch.cpp:451:                    Camera* shadowCamera = lightQueue_->shadowSplits_[0].shadowCamera_;
Draw:516:Batch.cpp:452:                    float nearClip = shadowCamera->GetNearClip();
Draw:517:Batch.cpp:453:                    float farClip = shadowCamera->GetFarClip();
Draw:518:Batch.cpp:454:                    float q = farClip / (farClip - nearClip);
Draw:519:Batch.cpp:455:                    float r = -q * nearClip;
Draw:520:Batch.cpp:457:                    const CascadeParameters& parameters = light->GetShadowCascade();
Draw:521:Batch.cpp:458:                    float viewFarClip = camera_->GetFarClip();
Draw:522:Batch.cpp:462:                    float fadeRange = fadeEnd - fadeStart;
Draw:523:Batch.cpp:464:                    graphics->SetShaderParameter(PSP_SHADOWDEPTHFADE, Vector4(q, r, fadeStart, 1.0f / fadeRange));
Draw:524:Batch.cpp:468:                    float intensity = light->GetShadowIntensity();
Draw:525:Batch.cpp:469:                    float fadeStart = light->GetShadowFadeDistance();
Draw:526:Batch.cpp:470:                    float fadeEnd = light->GetShadowDistance();
Draw:527:Batch.cpp:472:                        intensity = Lerp(intensity, 1.0f, Clamp((light->GetDistance() - fadeStart) / (fadeEnd - fadeStart), 0.0f, 1.0f));
Draw:528:Batch.cpp:473:                    float pcfValues = (1.0f - intensity);
Draw:529:Batch.cpp:474:                    float samples = renderer->GetShadowQuality() >= SHADOWQUALITY_HIGH_16BIT ? 4.0f : 1.0f;
Draw:530:Batch.cpp:476:                    graphics->SetShaderParameter(PSP_SHADOWINTENSITY, Vector4(pcfValues / samples, intensity, 0.0f, 0.0f));
Draw:531:Batch.cpp:479:                float sizeX = 1.0f / (float)shadowMap->GetWidth();
Draw:532:Batch.cpp:480:                float sizeY = 1.0f / (float)shadowMap->GetHeight();
Draw:533:Batch.cpp:481:                graphics->SetShaderParameter(PSP_SHADOWMAPINVSIZE, Vector4(sizeX, sizeY, 0.0f, 0.0f));
Draw:534:Batch.cpp:484:                if (lightQueue_->shadowSplits_.Size() > 1)
Draw:535:Batch.cpp:485:                    lightSplits.x_ = lightQueue_->shadowSplits_[0].farSplit_ / camera_->GetFarClip();
Draw:536:Batch.cpp:486:                if (lightQueue_->shadowSplits_.Size() > 2)
Draw:537:Batch.cpp:487:                    lightSplits.y_ = lightQueue_->shadowSplits_[1].farSplit_ / camera_->GetFarClip();
Draw:538:Batch.cpp:488:                if (lightQueue_->shadowSplits_.Size() > 3)
Draw:539:Batch.cpp:489:                    lightSplits.z_ = lightQueue_->shadowSplits_[2].farSplit_ / camera_->GetFarClip();
Draw:540:Batch.cpp:491:                graphics->SetShaderParameter(PSP_SHADOWSPLITS, lightSplits);
Draw:541:Batch.cpp:494:        else if (lightQueue_->vertexLights_.Size() && graphics->HasShaderParameter(VSP_VERTEXLIGHTS) &&
Draw:542:Batch.cpp:495:            graphics->NeedParameterUpdate(SP_LIGHT, lightQueue_))
Draw:543:Batch.cpp:498:            const PODVector<Light*>& lights = lightQueue_->vertexLights_;
Draw:544:Batch.cpp:503:                Node* vertexLightNode = vertexLight->GetNode();
Draw:545:Batch.cpp:504:                LightType type = vertexLight->GetLightType();
Draw:546:Batch.cpp:511:                    invRange = 1.0f / Max(vertexLight->GetRange(), M_EPSILON);
Draw:547:Batch.cpp:514:                    cutoff = Cos(vertexLight->GetFov() * 0.5f);
Draw:548:Batch.cpp:515:                    invCutoff = 1.0f / (1.0f - cutoff);
Draw:549:Batch.cpp:519:                    cutoff = -1.0f;
Draw:550:Batch.cpp:525:                float fadeEnd = vertexLight->GetDrawDistance();
Draw:551:Batch.cpp:526:                float fadeStart = vertexLight->GetFadeDistance();
Draw:552:Batch.cpp:529:                if (vertexLight->GetLightType() != LIGHT_DIRECTIONAL && fadeEnd > 0.0f && fadeStart > 0.0f && fadeStart < fadeEnd)
Draw:553:Batch.cpp:530:                    fade = Min(1.0f - (vertexLight->GetDistance() - fadeStart) / (fadeEnd - fadeStart), 1.0f);
Draw:554:Batch.cpp:532:                Color color = vertexLight->GetEffectiveColor() * fade;
Draw:555:Batch.cpp:536:                vertexLights[i * 3 + 1] = Vector4(-(vertexLightNode->GetWorldDirection()), cutoff);
Draw:556:Batch.cpp:539:                vertexLights[i * 3 + 2] = Vector4(vertexLightNode->GetWorldPosition(), invCutoff);
Draw:557:Batch.cpp:542:            graphics->SetShaderParameter(VSP_VERTEXLIGHTS, vertexLights[0].Data(), lights.Size() * 3 * 4);
Draw:558:Batch.cpp:546:    // Set material-specific shader parameters and textures
Draw:559:Batch.cpp:549:        if (graphics->NeedParameterUpdate(SP_MATERIAL, reinterpret_cast<const void*>(material_->GetShaderParameterHash())))
Draw:560:Batch.cpp:551:            const HashMap<StringHash, MaterialShaderParameter>& parameters = material_->GetShaderParameters();
Draw:561:Batch.cpp:553:                graphics->SetShaderParameter(i->first_, i->second_.value_);
Draw:562:Batch.cpp:556:        const HashMap<TextureUnit, SharedPtr<Texture> >& textures = material_->GetTextures();
Draw:563:Batch.cpp:559:            if (graphics->HasTextureUnit(i->first_))
Draw:564:Batch.cpp:560:                graphics->SetTexture(i->first_, i->second_.Get());
Draw:565:Batch.cpp:564:    // Set light-related textures
Draw:566:Batch.cpp:567:        if (shadowMap && graphics->HasTextureUnit(TU_SHADOWMAP))
Draw:567:Batch.cpp:568:            graphics->SetTexture(TU_SHADOWMAP, shadowMap);
Draw:568:Batch.cpp:569:        if (graphics->HasTextureUnit(TU_LIGHTRAMP))
Draw:569:Batch.cpp:571:            Texture* rampTexture = light->GetRampTexture();
Draw:570:Batch.cpp:573:                rampTexture = renderer->GetDefaultLightRamp();
Draw:571:Batch.cpp:574:            graphics->SetTexture(TU_LIGHTRAMP, rampTexture);
Draw:572:Batch.cpp:576:        if (graphics->HasTextureUnit(TU_LIGHTSHAPE))
Draw:573:Batch.cpp:578:            Texture* shapeTexture = light->GetShapeTexture();
Draw:574:Batch.cpp:579:            if (!shapeTexture && light->GetLightType() == LIGHT_SPOT)
Draw:575:Batch.cpp:580:                shapeTexture = renderer->GetDefaultLightSpot();
Draw:576:Batch.cpp:581:            graphics->SetTexture(TU_LIGHTSHAPE, shapeTexture);
Draw:577:Batch.cpp:587:    if (zone_ && graphics->HasTextureUnit(TU_ZONE))
Draw:578:Batch.cpp:588:        graphics->SetTexture(TU_ZONE, zone_->GetZoneTexture());
Draw:579:Batch.cpp:594:    if (!geometry_->IsEmpty())
Draw:580:Batch.cpp:597:        geometry_->Draw(view->GetGraphics());
Draw:581:Batch.cpp:619:    Graphics* graphics = view->GetGraphics();
Draw:582:Batch.cpp:620:    Renderer* renderer = view->GetRenderer();
Draw:583:Batch.cpp:622:    if (instances_.Size() && !geometry_->IsEmpty())
Draw:584:Batch.cpp:625:        VertexBuffer* instanceBuffer = renderer->GetInstancingBuffer();
Draw:585:Batch.cpp:630:            graphics->SetIndexBuffer(geometry_->GetIndexBuffer());
Draw:586:Batch.cpp:631:            graphics->SetVertexBuffers(geometry_->GetVertexBuffers(), geometry_->GetVertexElementMasks());
Draw:587:Batch.cpp:635:                if (graphics->NeedParameterUpdate(SP_OBJECT, instances_[i].worldTransform_))
Draw:588:Batch.cpp:636:                    graphics->SetShaderParameter(VSP_MODEL, *instances_[i].worldTransform_);
Draw:589:Batch.cpp:638:                graphics->Draw(geometry_->GetPrimitiveType(), geometry_->GetIndexStart(), geometry_->GetIndexCount(),
Draw:590:Batch.cpp:639:                    geometry_->GetVertexStart(), geometry_->GetVertexCount());
Draw:591:Batch.cpp:649:                (geometry_->GetVertexBuffers());
Draw:592:Batch.cpp:650:            PODVector<unsigned>& elementMasks = const_cast<PODVector<unsigned>&>(geometry_->GetVertexElementMasks());
Draw:593:Batch.cpp:652:            elementMasks.Push(instanceBuffer->GetElementMask());
Draw:594:Batch.cpp:654:            graphics->SetIndexBuffer(geometry_->GetIndexBuffer());
Draw:595:Batch.cpp:655:            graphics->SetVertexBuffers(vertexBuffers, elementMasks, startIndex_);
Draw:596:Batch.cpp:656:            graphics->DrawInstanced(geometry_->GetPrimitiveType(), geometry_->GetIndexStart(), geometry_->GetIndexCount(),
Draw:597:Batch.cpp:657:                geometry_->GetVertexStart(), geometry_->GetVertexCount(), instances_.Size());
Draw:598:Batch.cpp:697:        sortedBatchGroups_[index++] = &i->second_;
Draw:599:Batch.cpp:712:        if (i->second_.instances_.Size() <= maxSortedInstances_)
Draw:600:Batch.cpp:714:            Sort(i->second_.instances_.Begin(), i->second_.instances_.End(), CompareInstancesFrontToBack);
Draw:601:Batch.cpp:715:            if (i->second_.instances_.Size())
Draw:602:Batch.cpp:716:                i->second_.distance_ = i->second_.instances_[0].distance_;
Draw:603:Batch.cpp:721:            for (PODVector<InstanceData>::ConstIterator j = i->second_.instances_.Begin(); j != i->second_.instances_.End(); ++j)
Draw:604:Batch.cpp:722:                minDistance = Min(minDistance, j->distance_);
Draw:605:Batch.cpp:723:            i->second_.distance_ = minDistance;
Draw:606:Batch.cpp:731:        sortedBatchGroups_[index++] = &i->second_;
Draw:607:Batch.cpp:738:    // Mobile devices likely use a tiled deferred approach, with which front-to-back sorting is irrelevant. The 2-pass
Draw:608:Batch.cpp:754:        unsigned shaderID = (batch->sortKey_ >> 32);
Draw:609:Batch.cpp:757:            shaderID = j->second_;
Draw:610:Batch.cpp:764:        unsigned short materialID = (unsigned short)(batch->sortKey_ & 0xffff0000);
Draw:611:Batch.cpp:767:            materialID = k->second_;
Draw:612:Batch.cpp:774:        unsigned short geometryID = (unsigned short)(batch->sortKey_ & 0xffff);
Draw:613:Batch.cpp:777:            geometryID = l->second_;
Draw:614:Batch.cpp:784:        batch->sortKey_ = (((unsigned long long)shaderID) << 32) || (((unsigned long long)materialID) << 16) | geometryID;
Draw:615:Batch.cpp:799:        i->second_.SetTransforms(lockedData, freeIndex);
Draw:616:Batch.cpp:804:    Graphics* graphics = view->GetGraphics();
Draw:617:Batch.cpp:805:    Renderer* renderer = view->GetRenderer();
Draw:618:Batch.cpp:810:        graphics->SetScissorTest(false);
Draw:619:Batch.cpp:812:        // During G-buffer rendering, mark opaque pixels' lightmask to stencil buffer if requested
Draw:620:Batch.cpp:814:            graphics->SetStencilTest(false);
Draw:621:Batch.cpp:822:            graphics->SetStencilTest(true, CMP_ALWAYS, OP_REF, OP_KEEP, OP_KEEP, group->lightMask_);
Draw:622:Batch.cpp:824:        group->Draw(view, allowDepthWrite);
Draw:623:Batch.cpp:826:    // Non-instanced
Draw:624:Batch.cpp:831:            graphics->SetStencilTest(true, CMP_ALWAYS, OP_REF, OP_KEEP, OP_KEEP, batch->lightMask_);
Draw:625:Batch.cpp:835:            if (!batch->isBase_ && batch->lightQueue_)
Draw:626:Batch.cpp:836:                renderer->OptimizeLightByScissor(batch->lightQueue_->light_, batch->camera_);
Draw:627:Batch.cpp:838:                graphics->SetScissorTest(false);
Draw:628:Batch.cpp:841:        batch->Draw(view, allowDepthWrite);
Draw:629:Batch.cpp:851:       if (i->second_.geometryType_ == GEOM_INSTANCED)
Draw:630:Batch.cpp:852:            total += i->second_.instances_.Size();
Draw:631:BillboardSet.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:632:BillboardSet.h:42:    /// Two-dimensional size.
Draw:633:BillboardSet.h:73:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
Draw:634:BillboardSet.h:130:    /// Recalculate the world-space bounding box.
Draw:635:BillboardSet.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:636:BillboardSet.cpp:60:    return lhs->sortDistance_ > rhs->sortDistance_;
Draw:637:BillboardSet.cpp:81:    geometry_->SetVertexBuffer(0, vertexBuffer_, MASK_POSITION | MASK_COLOR | MASK_TEXCOORD1 | MASK_TEXCOORD2);
Draw:638:BillboardSet.cpp:82:    geometry_->SetIndexBuffer(indexBuffer_);
Draw:639:BillboardSet.cpp:96:    context->RegisterFactory<BillboardSet>(GEOMETRY_CATEGORY);
Draw:640:BillboardSet.cpp:116:    // If no billboard-level testing, use the Drawable test
Draw:641:BillboardSet.cpp:123:    // Check ray hit distance to AABB before proceeding with billboard-level tests
Draw:642:BillboardSet.cpp:127:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
Draw:643:BillboardSet.cpp:147:            result.normal_ = -query.ray_.direction_;
Draw:644:BillboardSet.cpp:166:    Vector3 worldPos = node_->GetWorldPosition();
Draw:645:BillboardSet.cpp:167:    Vector3 offset = (worldPos - frame.camera_->GetNode()->GetWorldPosition());
Draw:646:BillboardSet.cpp:172:    distance_ = frame.camera_->GetDistance(GetWorldBoundingBox().Center());
Draw:647:BillboardSet.cpp:178:        lodDistance_ = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
Draw:648:BillboardSet.cpp:185:    transforms_[0] = relative_ ? node_->GetWorldTransform() : Matrix3x4::IDENTITY;
Draw:649:BillboardSet.cpp:187:    transforms_[1] = Matrix3x4(Vector3::ZERO, faceCameraMode_ != FC_NONE ? frame.camera_->GetFaceCameraRotation(
Draw:650:BillboardSet.cpp:188:        node_->GetWorldPosition(), node_->GetWorldRotation(), faceCameraMode_) : node_->GetWorldRotation(), Vector3::ONE);
Draw:651:BillboardSet.cpp:193:    if (bufferSizeDirty_ || indexBuffer_->IsDataLost())
Draw:652:BillboardSet.cpp:196:    if (bufferDirty_ || sortThisFrame_ || vertexBuffer_->IsDataLost())
Draw:653:BillboardSet.cpp:199:    // If using camera facing, re-update the rotation for the current view now
Draw:654:BillboardSet.cpp:202:        transforms_[1] = Matrix3x4(Vector3::ZERO, frame.camera_->GetFaceCameraRotation(node_->GetWorldPosition(),
Draw:655:BillboardSet.cpp:203:            node_->GetWorldRotation(), faceCameraMode_), Vector3::ONE);
Draw:656:BillboardSet.cpp:210:    if (bufferDirty_ || bufferSizeDirty_ || vertexBuffer_->IsDataLost() || indexBuffer_->IsDataLost() || sortThisFrame_)
Draw:657:BillboardSet.cpp:300:    SetMaterial(cache->GetResource<Material>(value.name_));
Draw:658:BillboardSet.cpp:311:        i->position_ = value[index++].GetVector3();
Draw:659:BillboardSet.cpp:312:        i->size_ = value[index++].GetVector2();
Draw:660:BillboardSet.cpp:314:        i->uv_ = Rect(uv.x_, uv.y_, uv.z_, uv.w_);
Draw:661:BillboardSet.cpp:315:        i->color_ = value[index++].GetColor();
Draw:662:BillboardSet.cpp:316:        i->rotation_ = value[index++].GetFloat();
Draw:663:BillboardSet.cpp:317:        i->enabled_ = value[index++].GetBool();
Draw:664:BillboardSet.cpp:331:        i->position_ = buf.ReadVector3();
Draw:665:BillboardSet.cpp:332:        i->size_ = buf.ReadVector2();
Draw:666:BillboardSet.cpp:333:        i->uv_ = buf.ReadRect();
Draw:667:BillboardSet.cpp:334:        i->color_ = buf.ReadColor();
Draw:668:BillboardSet.cpp:335:        i->rotation_ = buf.ReadFloat();
Draw:669:BillboardSet.cpp:336:        i->enabled_ = buf.ReadBool();
Draw:670:BillboardSet.cpp:355:        ret.Push(i->position_);
Draw:671:BillboardSet.cpp:356:        ret.Push(i->size_);
Draw:672:BillboardSet.cpp:357:        ret.Push(Vector4(i->uv_.min_.x_, i->uv_.min_.y_, i->uv_.max_.x_, i->uv_.max_.y_));
Draw:673:BillboardSet.cpp:358:        ret.Push(i->color_);
Draw:674:BillboardSet.cpp:359:        ret.Push(i->rotation_);
Draw:675:BillboardSet.cpp:360:        ret.Push(i->enabled_);
Draw:676:BillboardSet.cpp:373:        attrBuffer_.WriteVector3(i->position_);
Draw:677:BillboardSet.cpp:374:        attrBuffer_.WriteVector2(i->size_);
Draw:678:BillboardSet.cpp:375:        attrBuffer_.WriteRect(i->uv_);
Draw:679:BillboardSet.cpp:376:        attrBuffer_.WriteColor(i->color_);
Draw:680:BillboardSet.cpp:377:        attrBuffer_.WriteFloat(i->rotation_);
Draw:681:BillboardSet.cpp:378:        attrBuffer_.WriteBool(i->enabled_);
Draw:682:BillboardSet.cpp:387:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
Draw:683:BillboardSet.cpp:400:        worldBox.Merge(BoundingBox(center - edge, center + edge));
Draw:684:BillboardSet.cpp:406:    worldBox.Merge(node_->GetWorldPosition());
Draw:685:BillboardSet.cpp:415:    if (vertexBuffer_->GetVertexCount() != numBillboards * 4)
Draw:686:BillboardSet.cpp:416:        vertexBuffer_->SetSize(numBillboards * 4, MASK_POSITION | MASK_COLOR | MASK_TEXCOORD1 | MASK_TEXCOORD2, true);
Draw:687:BillboardSet.cpp:417:    if (indexBuffer_->GetIndexCount() != numBillboards * 6)
Draw:688:BillboardSet.cpp:418:        indexBuffer_->SetSize(numBillboards * 6, false);
Draw:689:BillboardSet.cpp:428:    unsigned short* dest = (unsigned short*)indexBuffer_->Lock(0, numBillboards * 6, true);
Draw:690:BillboardSet.cpp:433:    while (numBillboards--)
Draw:691:BillboardSet.cpp:442:    indexBuffer_->Unlock();
Draw:692:BillboardSet.cpp:443:    indexBuffer_->ClearDataLost();
Draw:693:BillboardSet.cpp:464:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
Draw:694:BillboardSet.cpp:486:                billboard.sortDistance_ = frame.camera_->GetDistanceSquared(billboardTransform * billboards_[i].position_);
Draw:695:BillboardSet.cpp:490:    batches_[0].geometry_->SetDrawRange(TRIANGLE_LIST, 0, enabledBillboards * 6, false);
Draw:696:BillboardSet.cpp:500:        Vector3 worldPos = node_->GetWorldPosition();
Draw:697:BillboardSet.cpp:502:        previousOffset_ = (worldPos - frame.camera_->GetNode()->GetWorldPosition());
Draw:698:BillboardSet.cpp:505:    float* dest = (float*)vertexBuffer_->Lock(0, enabledBillboards * 4, true);
Draw:699:BillboardSet.cpp:519:        rotationMatrix[1][0] = -rotationMatrix[0][1];
Draw:700:BillboardSet.cpp:525:        dest[6] = -size.x_ * rotationMatrix[0][0] + size.y_ * rotationMatrix[0][1];
Draw:701:BillboardSet.cpp:526:        dest[7] = -size.x_ * rotationMatrix[1][0] + size.y_ * rotationMatrix[1][1];
Draw:702:BillboardSet.cpp:537:        dest[22] = size.x_ * rotationMatrix[0][0] - size.y_ * rotationMatrix[0][1];
Draw:703:BillboardSet.cpp:538:        dest[23] = size.x_ * rotationMatrix[1][0] - size.y_ * rotationMatrix[1][1];
Draw:704:BillboardSet.cpp:543:        dest[30] = -size.x_ * rotationMatrix[0][0] - size.y_ * rotationMatrix[0][1];
Draw:705:BillboardSet.cpp:544:        dest[31] = -size.x_ * rotationMatrix[1][0] - size.y_ * rotationMatrix[1][1];
Draw:706:BillboardSet.cpp:549:    vertexBuffer_->Unlock();
Draw:707:BillboardSet.cpp:550:    vertexBuffer_->ClearDataLost();
Draw:708:Camera.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:709:Camera.cpp:46:    0.0f, -1.0f, 0.0f, 0.0f,
Draw:710:Camera.cpp:84:    context->RegisterFactory<Camera>(SCENE_CATEGORY);
Draw:711:Camera.cpp:108:    debug->AddFrustum(GetFrustum(), Color::WHITE, depthTest);
Draw:712:Camera.cpp:316:        ret.origin_ = node_ ? node_->GetWorldPosition() : Vector3::ZERO;
Draw:713:Camera.cpp:317:        ret.direction_ = node_ ? node_->GetWorldDirection() : Vector3::FORWARD;
Draw:714:Camera.cpp:323:    // The parameters range from 0.0 to 1.0. Expand to normalized device coordinates (-1.0 to 1.0) & flip Y axis
Draw:715:Camera.cpp:324:    x = 2.0f * x - 1.0f;
Draw:716:Camera.cpp:325:    y = 1.0f - 2.0f * y;
Draw:717:Camera.cpp:330:    ret.direction_ = ((viewProjInverse * far) - ret.origin_).Normalized();
Draw:718:Camera.cpp:347:        ret.x_ = (-eyeSpacePos.x_ > 0.0f) ? -1.0f : 1.0f;
Draw:719:Camera.cpp:348:        ret.y_ = (-eyeSpacePos.y_ > 0.0f) ? -1.0f : 1.0f;
Draw:720:Camera.cpp:352:    ret.y_ = 1.0f - ((ret.y_ / 2.0f) + 0.5f);
Draw:721:Camera.cpp:410:            q = (farClip_ + nearClip) / (farClip_ - nearClip);
Draw:722:Camera.cpp:411:            r = -2.0f * farClip_ * nearClip / (farClip_ - nearClip);
Draw:723:Camera.cpp:415:            q = farClip_ / (farClip_ - nearClip);
Draw:724:Camera.cpp:416:            r = -q * nearClip;
Draw:725:Camera.cpp:437:            r = -1.0f;
Draw:726:Camera.cpp:482:        near.y_ = -near.y_;
Draw:727:Camera.cpp:483:        far.y_ = -far.y_;
Draw:728:Camera.cpp:499:        const Vector3& cameraPos = node_ ? node_->GetWorldPosition() : Vector3::ZERO;
Draw:729:Camera.cpp:500:        return (worldPos - cameraPos).Length();
Draw:730:Camera.cpp:510:        const Vector3& cameraPos = node_ ? node_->GetWorldPosition() : Vector3::ZERO;
Draw:731:Camera.cpp:511:        return (worldPos - cameraPos).LengthSquared();
Draw:732:Camera.cpp:540:        return node_->GetWorldRotation();
Draw:733:Camera.cpp:545:            euler.y_ = node_->GetWorldRotation().EulerAngles().y_;
Draw:734:Camera.cpp:552:            lookAt.FromLookRotation(position - node_->GetWorldPosition());
Draw:735:Camera.cpp:558:            // Make the Y-only lookat happen on an XZ plane to make sure there are no unwanted transitions
Draw:736:Camera.cpp:560:            Vector3 lookAtVec(position - node_->GetWorldPosition());
Draw:737:Camera.cpp:575:    Matrix3x4 worldTransform = node_ ? Matrix3x4(node_->GetWorldPosition(), node_->GetWorldRotation(), 1.0f) : Matrix3x4::IDENTITY;
Draw:738:Camera.cpp:635:        node->AddListener(this);
Draw:739:Camera.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:740:Camera.h:67:    /// Set orthographic mode view non-uniform size. Disables the auto aspect ratio -mode.
Draw:741:Camera.h:69:    /// Set aspect ratio manually. Disables the auto aspect ratio -mode.
Draw:742:Camera.h:124:    /// Return API-specific projection matrix.
Draw:743:Camera.h:126:    /// Return either API-specific or API-independent (D3D convention) projection matrix.
Draw:744:Camera.h:140:    /// Return ray corresponding to normalized screen coordinates (0.0 - 1.0).
Draw:745:Camera.h:142:    // Convert a world space point to normalized screen coordinates (0.0 - 1.0).
Draw:746:Camera.h:144:    // Convert normalized screen coordinates (0.0 - 1.0) and depth to a world space point.
Draw:747:ConstantBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:748:CustomGeometry.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:749:CustomGeometry.cpp:54:    vertexBuffer_->SetShadowed(true);
Draw:750:CustomGeometry.cpp:64:    context->RegisterFactory<CustomGeometry>(GEOMETRY_CATEGORY);
Draw:751:CustomGeometry.cpp:91:        Matrix3x4 inverse(node_->GetWorldTransform().Inverse());
Draw:752:CustomGeometry.cpp:94:        Vector3 normal = -query.ray_.direction_;
Draw:753:CustomGeometry.cpp:106:                    float geometryDistance = geometry->GetHitDistance(localRay, &geometryNormal);
Draw:754:CustomGeometry.cpp:110:                        normal = (node_->GetWorldTransform() * Vector4(geometryNormal, 0.0f)).Normalized();
Draw:755:CustomGeometry.cpp:148:        if (mat && !mat->GetOcclusion())
Draw:756:CustomGeometry.cpp:151:        triangles += geometry->GetVertexCount() / 3;
Draw:757:CustomGeometry.cpp:171:            if (!material->GetOcclusion())
Draw:758:CustomGeometry.cpp:173:            buffer->SetCullMode(material->GetCullMode());
Draw:759:CustomGeometry.cpp:176:            buffer->SetCullMode(CULL_CCW);
Draw:760:CustomGeometry.cpp:184:        geometry->GetRawData(vertexData, vertexSize, indexData, indexSize, elementMask);
Draw:761:CustomGeometry.cpp:190:        success = buffer->Draw(node_->GetWorldTransform(), vertexData, vertexSize, geometry->GetVertexStart(), geometry->GetVertexCount());
Draw:762:CustomGeometry.cpp:334:    if (vertexBuffer_->GetVertexCount() != totalVertices || vertexBuffer_->GetElementMask() != elementMask_ ||
Draw:763:CustomGeometry.cpp:335:        vertexBuffer_->IsDynamic() != dynamic_)
Draw:764:CustomGeometry.cpp:336:        vertexBuffer_->SetSize(totalVertices, elementMask_, dynamic_);
Draw:765:CustomGeometry.cpp:340:        unsigned char* dest = (unsigned char*)vertexBuffer_->Lock(0, totalVertices, true);
Draw:766:CustomGeometry.cpp:378:                geometries_[i]->SetVertexBuffer(0, vertexBuffer_, elementMask_);
Draw:767:CustomGeometry.cpp:379:                geometries_[i]->SetDrawRange(primitiveTypes_[i], 0, 0, vertexStart, vertexCount);
Draw:768:CustomGeometry.cpp:383:            vertexBuffer_->Unlock();
Draw:769:CustomGeometry.cpp:392:            geometries_[i]->SetVertexBuffer(0, vertexBuffer_, elementMask_);
Draw:770:CustomGeometry.cpp:393:            geometries_[i]->SetDrawRange(primitiveTypes_[i], 0, 0, 0, 0);
Draw:771:CustomGeometry.cpp:397:    vertexBuffer_->ClearDataLost();
Draw:772:CustomGeometry.cpp:475:        SetMaterial(i, cache->GetResource<Material>(value.names_[i]));
Draw:773:CustomGeometry.cpp:520:    worldBoundingBox_ = boundingBox_.Transformed(node_->GetWorldTransform());
Draw:774:CustomGeometry.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:775:CustomGeometry.h:119:    /// Recalculate the world-space bounding box.
Draw:776:DebugRenderer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:777:DebugRenderer.cpp:63:    context->RegisterFactory<DebugRenderer>(SUBSYSTEM_CATEGORY);
Draw:778:DebugRenderer.cpp:71:    view_ = camera->GetView();
Draw:779:DebugRenderer.cpp:72:    projection_ = camera->GetProjection();
Draw:780:DebugRenderer.cpp:73:    frustum_ = camera->GetFrustum();
Draw:781:DebugRenderer.cpp:113:    Vector3 start = node->GetWorldPosition();
Draw:782:DebugRenderer.cpp:114:    Quaternion rotation = node->GetWorldRotation();
Draw:783:DebugRenderer.cpp:258:    AddLine(position - offsetXVec, position + heightVec - offsetXVec, color, depthTest);
Draw:784:DebugRenderer.cpp:260:    AddLine(position - offsetZVec, position + heightVec - offsetZVec, color, depthTest);
Draw:785:DebugRenderer.cpp:281:        Vector3 start = boneNode->GetWorldPosition();
Draw:786:DebugRenderer.cpp:285:        Node* parentNode = boneNode->GetParent();
Draw:787:DebugRenderer.cpp:289:            end = parentNode->GetWorldPosition();
Draw:788:DebugRenderer.cpp:303:    // 16-bit indices
Draw:789:DebugRenderer.cpp:349:    assert(graphics && graphics->IsInitialized() && !graphics->IsDeviceLost());
Draw:790:DebugRenderer.cpp:353:    ShaderVariation* vs = graphics->GetShader(VS, "Basic", "VERTEXCOLOR");
Draw:791:DebugRenderer.cpp:354:    ShaderVariation* ps = graphics->GetShader(PS, "Basic", "VERTEXCOLOR");
Draw:792:DebugRenderer.cpp:358:    if (vertexBuffer_->GetVertexCount() < numVertices || vertexBuffer_->GetVertexCount() > numVertices * 2)
Draw:793:DebugRenderer.cpp:359:        vertexBuffer_->SetSize(numVertices, MASK_POSITION | MASK_COLOR, true);
Draw:794:DebugRenderer.cpp:361:    float* dest = (float*)vertexBuffer_->Lock(0, numVertices, true);
Draw:795:DebugRenderer.cpp:421:    vertexBuffer_->Unlock();
Draw:796:DebugRenderer.cpp:423:    graphics->SetBlendMode(BLEND_REPLACE);
Draw:797:DebugRenderer.cpp:424:    graphics->SetColorWrite(true);
Draw:798:DebugRenderer.cpp:425:    graphics->SetCullMode(CULL_NONE);
Draw:799:DebugRenderer.cpp:426:    graphics->SetDepthWrite(true);
Draw:800:DebugRenderer.cpp:427:    graphics->SetScissorTest(false);
Draw:801:DebugRenderer.cpp:428:    graphics->SetStencilTest(false);
Draw:802:DebugRenderer.cpp:429:    graphics->SetShaders(vs, ps);
Draw:803:DebugRenderer.cpp:430:    graphics->SetShaderParameter(VSP_MODEL, Matrix3x4::IDENTITY);
Draw:804:DebugRenderer.cpp:431:    graphics->SetShaderParameter(VSP_VIEWPROJ, projection_ * view_);
Draw:805:DebugRenderer.cpp:432:    graphics->SetShaderParameter(PSP_MATDIFFCOLOR, Color(1.0f, 1.0f, 1.0f, 1.0f));
Draw:806:DebugRenderer.cpp:433:    graphics->SetVertexBuffer(vertexBuffer_);
Draw:807:DebugRenderer.cpp:440:        graphics->SetDepthTest(CMP_LESSEQUAL);
Draw:808:DebugRenderer.cpp:441:        graphics->Draw(LINE_LIST, start, count);
Draw:809:DebugRenderer.cpp:447:        graphics->SetDepthTest(CMP_ALWAYS);
Draw:810:DebugRenderer.cpp:448:        graphics->Draw(LINE_LIST, start, count);
Draw:811:DebugRenderer.cpp:452:    graphics->SetBlendMode(BLEND_ALPHA);
Draw:812:DebugRenderer.cpp:457:        graphics->SetDepthTest(CMP_LESSEQUAL);
Draw:813:DebugRenderer.cpp:458:        graphics->Draw(TRIANGLE_LIST, start, count);
Draw:814:DebugRenderer.cpp:464:        graphics->SetDepthTest(CMP_ALWAYS);
Draw:815:DebugRenderer.cpp:465:        graphics->Draw(TRIANGLE_LIST, start, count);
Draw:816:DebugRenderer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:817:Direct3D11\D3D11ConstantBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:818:Direct3D11\D3D11ConstantBuffer.cpp:52:        ((ID3D11Buffer*)object_)->Release();
Draw:819:Direct3D11\D3D11ConstantBuffer.cpp:66:        LOGERROR("Can not create zero-sized constant buffer");
Draw:820:Direct3D11\D3D11ConstantBuffer.cpp:89:        graphics_->GetImpl()->GetDevice()->CreateBuffer(&bufferDesc, 0, (ID3D11Buffer**)&object_);
Draw:821:Direct3D11\D3D11ConstantBuffer.cpp:118:    while (rows--)
Draw:822:Direct3D11\D3D11ConstantBuffer.cpp:133:        graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Buffer*)object_, 0, 0, shadowData_.Get(), 0, 0);
Draw:823:Direct3D11\D3D11GPUObject.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:824:Direct3D11\D3D11GPUObject.h:44:    /// Clear the data lost flag. No-op on D3D11.
Draw:825:DecalSet.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:826:DecalSet.cpp:62:    float t = d0 / (d0 - d1);
Draw:827:DecalSet.cpp:64:    ret.position_ = v0.position_ + t * (v1.position_ - v0.position_);
Draw:828:DecalSet.cpp:65:    ret.normal_ = v0.normal_ + t * (v1.normal_ - v0.normal_);
Draw:829:DecalSet.cpp:83:                ret.blendWeights_[i] = v0.blendWeights_[i] + t * (v1.blendWeights_[i] - v0.blendWeights_[i]);
Draw:830:DecalSet.cpp:167:    geometry_->SetIndexBuffer(indexBuffer_);
Draw:831:DecalSet.cpp:180:    context->RegisterFactory<DecalSet>(GEOMETRY_CATEGORY);
Draw:832:DecalSet.cpp:213:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
Draw:833:DecalSet.cpp:214:    distance_ = frame.camera_->GetDistance(worldBoundingBox.Center());
Draw:834:DecalSet.cpp:217:    lodDistance_ = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
Draw:835:DecalSet.cpp:229:    if (bufferDirty_ || vertexBuffer_->IsDataLost() || indexBuffer_->IsDataLost())
Draw:836:DecalSet.cpp:238:    if (bufferDirty_ || bufferSizeDirty_ || vertexBuffer_->IsDataLost() || indexBuffer_->IsDataLost())
Draw:837:DecalSet.cpp:296:    if (!target || !target->GetNode())
Draw:838:DecalSet.cpp:312:    Vector3 adjustedWorldPosition = worldPosition - 0.5f * depth * (worldRotation * Vector3::FORWARD);
Draw:839:DecalSet.cpp:314:    Matrix3x4 targetTransform = target->GetNode()->GetWorldTransform().Inverse();
Draw:840:DecalSet.cpp:320:        Skeleton& skeleton = animatedModel->GetSkeleton();
Draw:841:DecalSet.cpp:328:            if (!bone->node_ || !bone->collisionMask_)
Draw:842:DecalSet.cpp:332:            Sphere decalSphere(bone->node_->GetWorldTransform().Inverse() * worldPosition, 0.5f * size /
Draw:843:DecalSet.cpp:333:                bone->node_->GetWorldScale().Length());
Draw:844:DecalSet.cpp:335:            if (bone->collisionMask_ & BONECOLLISION_BOX)
Draw:845:DecalSet.cpp:337:                float size = bone->boundingBox_.HalfSize().Length();
Draw:846:DecalSet.cpp:338:                if (bone->boundingBox_.IsInside(decalSphere) && size > bestSize)
Draw:847:DecalSet.cpp:344:            else if (bone->collisionMask_ & BONECOLLISION_SPHERE)
Draw:848:DecalSet.cpp:346:                Sphere boneSphere(Vector3::ZERO, bone->radius_);
Draw:849:DecalSet.cpp:347:                float size = bone->radius_;
Draw:850:DecalSet.cpp:357:            targetTransform = (bestBone->node_->GetWorldTransform() * bestBone->offsetMatrix_).Inverse();
Draw:851:DecalSet.cpp:374:    unsigned numBatches = target->GetBatches().Size();
Draw:852:DecalSet.cpp:409:            newDecal.AddVertex(face[j - 1]);
Draw:853:DecalSet.cpp:446:    Matrix3x4 decalTransform = node_->GetWorldTransform().Inverse() * target->GetNode()->GetWorldTransform();
Draw:854:DecalSet.cpp:462:    // If new decal is time limited, subscribe to scene post-update
Draw:855:DecalSet.cpp:472:    while (num-- && decals_.Size())
Draw:856:DecalSet.cpp:489:        if (i->node_)
Draw:857:DecalSet.cpp:490:            i->node_->RemoveListener(this);
Draw:858:DecalSet.cpp:506:    SetMaterial(cache->GetResource<Material>(value.name_));
Draw:859:DecalSet.cpp:521:    while (numDecals--)
Draw:860:DecalSet.cpp:533:            i->position_ = buffer.ReadVector3();
Draw:861:DecalSet.cpp:534:            i->normal_ = buffer.ReadVector3();
Draw:862:DecalSet.cpp:535:            i->texCoord_ = buffer.ReadVector2();
Draw:863:DecalSet.cpp:536:            i->tangent_ = buffer.ReadVector4();
Draw:864:DecalSet.cpp:540:                    i->blendWeights_[j] = buffer.ReadFloat();
Draw:865:DecalSet.cpp:542:                    i->blendIndices_[j] = buffer.ReadUByte();
Draw:866:DecalSet.cpp:597:        ret.WriteFloat(i->timer_);
Draw:867:DecalSet.cpp:598:        ret.WriteFloat(i->timeToLive_);
Draw:868:DecalSet.cpp:599:        ret.WriteVLE(i->vertices_.Size());
Draw:869:DecalSet.cpp:600:        ret.WriteVLE(i->indices_.Size());
Draw:870:DecalSet.cpp:602:        for (PODVector<DecalVertex>::ConstIterator j = i->vertices_.Begin(); j != i->vertices_.End(); ++j)
Draw:871:DecalSet.cpp:604:            ret.WriteVector3(j->position_);
Draw:872:DecalSet.cpp:605:            ret.WriteVector3(j->normal_);
Draw:873:DecalSet.cpp:606:            ret.WriteVector2(j->texCoord_);
Draw:874:DecalSet.cpp:607:            ret.WriteVector4(j->tangent_);
Draw:875:DecalSet.cpp:611:                    ret.WriteFloat(j->blendWeights_[k]);
Draw:876:DecalSet.cpp:613:                    ret.WriteUByte(j->blendIndices_[k]);
Draw:877:DecalSet.cpp:617:        for (PODVector<unsigned short>::ConstIterator j = i->indices_.Begin(); j != i->indices_.End(); ++j)
Draw:878:DecalSet.cpp:627:            ret.WriteString(i->name_);
Draw:879:DecalSet.cpp:628:            ret.WriteUByte(i->collisionMask_);
Draw:880:DecalSet.cpp:629:            if (i->collisionMask_ & BONECOLLISION_SPHERE)
Draw:881:DecalSet.cpp:630:                ret.WriteFloat(i->radius_);
Draw:882:DecalSet.cpp:631:            if (i->collisionMask_ & BONECOLLISION_BOX)
Draw:883:DecalSet.cpp:632:                ret.WriteBoundingBox(i->boundingBox_);
Draw:884:DecalSet.cpp:633:            ret.Write(i->offsetMatrix_.Data(), sizeof(Matrix3x4));
Draw:885:DecalSet.cpp:658:        worldBoundingBox_ = boundingBox_.Transformed(node_->GetWorldTransform());
Draw:886:DecalSet.cpp:667:            Node* boneNode = i->node_;
Draw:887:DecalSet.cpp:673:            if (i->collisionMask_ & BONECOLLISION_BOX)
Draw:888:DecalSet.cpp:674:                worldBox.Merge(i->boundingBox_.Transformed(boneNode->GetWorldTransform()));
Draw:889:DecalSet.cpp:675:            else if (i->collisionMask_ & BONECOLLISION_SPHERE)
Draw:890:DecalSet.cpp:676:                worldBox.Merge(Sphere(boneNode->GetWorldPosition(), i->radius_ * 0.5f));
Draw:891:DecalSet.cpp:687:    Geometry* geometry = target->GetLodGeometry(batchIndex, 0);
Draw:892:DecalSet.cpp:688:    if (!geometry || geometry->GetPrimitiveType() != TRIANGLE_LIST)
Draw:893:DecalSet.cpp:700:    IndexBuffer* ib = geometry->GetIndexBuffer();
Draw:894:DecalSet.cpp:703:        indexData = ib->GetShadowData();
Draw:895:DecalSet.cpp:704:        indexStride = ib->GetIndexSize();
Draw:896:DecalSet.cpp:708:    for (unsigned i = 0; i < geometry->GetNumVertexBuffers(); ++i)
Draw:897:DecalSet.cpp:710:        VertexBuffer* vb = geometry->GetVertexBuffer(i);
Draw:898:DecalSet.cpp:714:        unsigned elementMask = geometry->GetVertexElementMask(i);
Draw:899:DecalSet.cpp:715:        unsigned char* data = vb->GetShadowData();
Draw:900:DecalSet.cpp:722:            positionStride = vb->GetVertexSize();
Draw:901:DecalSet.cpp:726:            normalData = data + vb->GetElementOffset(ELEMENT_NORMAL);
Draw:902:DecalSet.cpp:727:            normalStride = vb->GetVertexSize();
Draw:903:DecalSet.cpp:731:            skinningData = data + vb->GetElementOffset(ELEMENT_BLENDWEIGHTS);
Draw:904:DecalSet.cpp:732:            skinningStride = vb->GetVertexSize();
Draw:905:DecalSet.cpp:741:        geometry->GetRawData(positionData, positionStride, indexData, indexStride, elementMask);
Draw:906:DecalSet.cpp:744:            LOGWARNING("Can not add decal, target drawable has no CPU-side geometry data");
Draw:907:DecalSet.cpp:751:        unsigned indexStart = geometry->GetIndexStart();
Draw:908:DecalSet.cpp:752:        unsigned indexCount = geometry->GetIndexCount();
Draw:909:DecalSet.cpp:754:        // 16-bit indices
Draw:910:DecalSet.cpp:768:        // 32-bit indices
Draw:911:DecalSet.cpp:783:        // Non-indexed geometry
Draw:912:DecalSet.cpp:784:        unsigned indices = geometry->GetVertexStart();
Draw:913:DecalSet.cpp:785:        unsigned indicesEnd = indices + geometry->GetVertexCount();
Draw:914:DecalSet.cpp:812:        Vector3 dist1 = v1 - v0;
Draw:915:DecalSet.cpp:813:        Vector3 dist2 = v2 - v0;
Draw:916:DecalSet.cpp:830:    for (unsigned i = PLANE_FAR; i < NUM_FRUSTUM_PLANES; --i)
Draw:917:DecalSet.cpp:877:    // Check whether target is using global or per-geometry skinning
Draw:918:DecalSet.cpp:878:    const Vector<PODVector<Matrix3x4> >& geometrySkinMatrices = animatedModel->GetGeometrySkinMatrices();
Draw:919:DecalSet.cpp:879:    const Vector<PODVector<unsigned> >& geometryBoneMappings = animatedModel->GetGeometryBoneMappings();
Draw:920:DecalSet.cpp:887:                bone = animatedModel->GetSkeleton().GetBone(blendIndices[i]);
Draw:921:DecalSet.cpp:889:                bone = animatedModel->GetSkeleton().GetBone(geometryBoneMappings[batchIndex][blendIndices[i]]);
Draw:922:DecalSet.cpp:902:                if (bones_[index].node_ == bone->node_)
Draw:923:DecalSet.cpp:906:                    if (bones_[index].offsetMatrix_.Equals(bone->offsetMatrix_))
Draw:924:DecalSet.cpp:931:                    bone->node_->AddListener(this);
Draw:925:DecalSet.cpp:953:        Vector3 projected = viewProj * i->position_;
Draw:926:DecalSet.cpp:954:        i->texCoord_ = Vector2(
Draw:927:DecalSet.cpp:965:        i->position_ = transform * i->position_;
Draw:928:DecalSet.cpp:966:        i->normal_ = (transform * i->normal_).Normalized();
Draw:929:DecalSet.cpp:972:    numVertices_ -= i->vertices_.Size();
Draw:930:DecalSet.cpp:973:    numIndices_ -= i->indices_.Size();
Draw:931:DecalSet.cpp:992:        boundingBox_.Merge(i->boundingBox_);
Draw:932:DecalSet.cpp:999:    vertexBuffer_->SetSize(maxVertices_, skinned_ ? SKINNED_ELEMENT_MASK : STATIC_ELEMENT_MASK);
Draw:933:DecalSet.cpp:1000:    indexBuffer_->SetSize(maxIndices_, false);
Draw:934:DecalSet.cpp:1001:    geometry_->SetVertexBuffer(0, vertexBuffer_);
Draw:935:DecalSet.cpp:1009:    geometry_->SetDrawRange(TRIANGLE_LIST, 0, numIndices_, 0, numVertices_);
Draw:936:DecalSet.cpp:1011:    float* vertices = (float*)vertexBuffer_->Lock(0, numVertices_);
Draw:937:DecalSet.cpp:1012:    unsigned short* indices = (unsigned short*)indexBuffer_->Lock(0, numIndices_);
Draw:938:DecalSet.cpp:1020:            for (unsigned j = 0; j < i->vertices_.Size(); ++j)
Draw:939:DecalSet.cpp:1022:                const DecalVertex& vertex = i->vertices_[j];
Draw:940:DecalSet.cpp:1045:            for (unsigned j = 0; j < i->indices_.Size(); ++j)
Draw:941:DecalSet.cpp:1046:                *indices++ = i->indices_[j] + indexStart;
Draw:942:DecalSet.cpp:1048:            indexStart += i->vertices_.Size();
Draw:943:DecalSet.cpp:1052:    vertexBuffer_->Unlock();
Draw:944:DecalSet.cpp:1053:    vertexBuffer_->ClearDataLost();
Draw:945:DecalSet.cpp:1054:    indexBuffer_->Unlock();
Draw:946:DecalSet.cpp:1055:    indexBuffer_->ClearDataLost();
Draw:947:DecalSet.cpp:1062:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
Draw:948:DecalSet.cpp:1068:            skinMatrices_[i] = bone.node_->GetWorldTransform() * bone.offsetMatrix_;
Draw:949:DecalSet.cpp:1087:        batches_[0].worldTransform_ = &node_->GetWorldTransform();
Draw:950:DecalSet.cpp:1102:        Node* boneNode = node_->GetChild(i->name_, true);
Draw:951:DecalSet.cpp:1104:            boneNode->AddListener(this);
Draw:952:DecalSet.cpp:1105:        i->node_ = boneNode;
Draw:953:DecalSet.cpp:1123:            if (i->timeToLive_ > 0.0f)
Draw:954:DecalSet.cpp:1154:        i->timer_ += timeStep;
Draw:955:DecalSet.cpp:1157:        if (i->timeToLive_ > 0.0f && i->timer_ > i->timeToLive_)
Draw:956:Direct3D11\D3D11ConstantBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:957:Direct3D11\D3D11ConstantBuffer.h:47:    /// Set size and create GPU-side buffer. Return true on success.
Draw:958:Direct3D11\D3D11GPUObject.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:959:Direct3D11\D3D11GPUObject.cpp:37:        graphics->AddGPUObject(this);
Draw:960:Direct3D11\D3D11GPUObject.cpp:43:        graphics_->RemoveGPUObject(this);
Draw:961:DecalSet.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:962:DecalSet.h:89:    /// Calculate local-space bounding box.
Draw:963:DecalSet.h:96:    /// Local-space bounding box.
Draw:964:DecalSet.h:123:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
Draw:965:DecalSet.h:130:    /// Set material. The material should use a small negative depth bias to avoid Z-fighting.
Draw:966:DecalSet.h:166:    /// Recalculate the world-space bounding box.
Draw:967:DecalSet.h:186:    /// Recalculate the local-space bounding box.
Draw:968:DecalSet.h:198:    /// Subscribe/unsubscribe from scene post-update as necessary.
Draw:969:DecalSet.h:200:    /// Handle scene post-update event.
Draw:970:Direct3D11\D3D11GraphicsImpl.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:971:Direct3D11\D3D11Graphics.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:972:Direct3D11\D3D11Graphics.h:60:/// CPU-side scratch buffer for vertex data updates.
Draw:973:Direct3D11\D3D11Graphics.h:108:    /// Set allowed screen orientations as a space-separated list of "LandscapeLeft", "LandscapeRight", "Portrait" and "PortraitUpsideDown". Affects currently only iOS platform.
Draw:974:Direct3D11\D3D11Graphics.h:124:    /// Draw non-indexed geometry.
Draw:975:Direct3D11\D3D11Graphics.h:182:    /// Reset all rendertargets, depth-stencil surface and viewport.
Draw:976:Direct3D11\D3D11Graphics.h:186:    /// Reset depth-stencil surface.
Draw:977:Direct3D11\D3D11Graphics.h:192:    /// Set depth-stencil surface.
Draw:978:Direct3D11\D3D11Graphics.h:194:    /// Set depth-stencil surface.
Draw:979:Direct3D11\D3D11Graphics.h:229:    /// Return graphics implementation, which holds the actual API-specific resources.
Draw:980:Direct3D11\D3D11Graphics.h:231:    /// Return OS-specific external window handle. Null if not in use.
Draw:981:Direct3D11\D3D11Graphics.h:271:    /// Return 24-bit shadow map depth texture format, or 0 if not supported.
Draw:982:Direct3D11\D3D11Graphics.h:275:    /// Return whether light pre-pass rendering is supported.
Draw:983:Direct3D11\D3D11Graphics.h:317:    /// Return current depth-stencil surface.
Draw:984:Direct3D11\D3D11Graphics.h:376:    /// Reserve a CPU-side scratch buffer.
Draw:985:Direct3D11\D3D11Graphics.h:378:    /// Free a CPU-side scratch buffer.
Draw:986:Direct3D11\D3D11Graphics.h:387:    /// Return the API-specific alpha texture format.
Draw:987:Direct3D11\D3D11Graphics.h:389:    /// Return the API-specific luminance texture format.
Draw:988:Direct3D11\D3D11Graphics.h:391:    /// Return the API-specific luminance alpha texture format.
Draw:989:Direct3D11\D3D11Graphics.h:393:    /// Return the API-specific RGB texture format.
Draw:990:Direct3D11\D3D11Graphics.h:395:    /// Return the API-specific RGBA texture format.
Draw:991:Direct3D11\D3D11Graphics.h:397:    /// Return the API-specific RGBA 16-bit texture format.
Draw:992:Direct3D11\D3D11Graphics.h:399:    /// Return the API-specific RGBA 16-bit float texture format.
Draw:993:Direct3D11\D3D11Graphics.h:401:    /// Return the API-specific RGBA 32-bit float texture format.
Draw:994:Direct3D11\D3D11Graphics.h:403:    /// Return the API-specific RG 16-bit texture format.
Draw:995:Direct3D11\D3D11Graphics.h:405:    /// Return the API-specific RG 16-bit float texture format.
Draw:996:Direct3D11\D3D11Graphics.h:407:    /// Return the API-specific RG 32-bit float texture format.
Draw:997:Direct3D11\D3D11Graphics.h:409:    /// Return the API-specific single channel 16-bit float texture format.
Draw:998:Direct3D11\D3D11Graphics.h:411:    /// Return the API-specific single channel 32-bit float texture format.
Draw:999:Direct3D11\D3D11Graphics.h:413:    /// Return the API-specific linear depth texture format.
Draw:1000:Direct3D11\D3D11Graphics.h:415:    /// Return the API-specific hardware depth-stencil texture format.
Draw:1001:Direct3D11\D3D11Graphics.h:417:    /// Return the API-specific readable hardware depth format, or 0 if not supported.
Draw:1002:Direct3D11\D3D11Graphics.h:419:    /// Return the API-specific texture format from a textual description, for example "rgb".
Draw:1003:Direct3D11\D3D11Graphics.h:478:    /// Light pre-pass rendering support flag.
Draw:1004:Direct3D11\D3D11Graphics.h:504:    /// Shadow map 24-bit depth texture format.
Draw:1005:Direct3D11\D3D11Graphics.h:526:    /// Depth-stencil surface in use.
Draw:1006:Direct3D11\D3D11Graphics.h:566:    /// Current custom clip plane in post-projection space.
Draw:1007:Direct3D11\D3D11Graphics.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1008:Direct3D11\D3D11Graphics.cpp:194:        primitiveCount = elementCount - 2;
Draw:1009:Direct3D11\D3D11Graphics.cpp:199:        primitiveCount = elementCount - 1;
Draw:1010:Direct3D11\D3D11Graphics.cpp:258:    // Initialize SDL now. Graphics should be the first SDL-using subsystem to be created
Draw:1011:Direct3D11\D3D11Graphics.cpp:272:            (*i)->Release();
Draw:1012:Direct3D11\D3D11Graphics.cpp:279:    for (HashMap<unsigned, ID3D11BlendState*>::Iterator i = impl_->blendStates_.Begin(); i != impl_->blendStates_.End(); ++i)
Draw:1013:Direct3D11\D3D11Graphics.cpp:281:        if (i->second_)
Draw:1014:Direct3D11\D3D11Graphics.cpp:282:            i->second_->Release();
Draw:1015:Direct3D11\D3D11Graphics.cpp:284:    impl_->blendStates_.Clear();
Draw:1016:Direct3D11\D3D11Graphics.cpp:286:    for (HashMap<unsigned, ID3D11DepthStencilState*>::Iterator i = impl_->depthStates_.Begin(); i != impl_->depthStates_.End(); ++i)
Draw:1017:Direct3D11\D3D11Graphics.cpp:288:        if (i->second_)
Draw:1018:Direct3D11\D3D11Graphics.cpp:289:            i->second_->Release();
Draw:1019:Direct3D11\D3D11Graphics.cpp:291:    impl_->depthStates_.Clear();
Draw:1020:Direct3D11\D3D11Graphics.cpp:293:    for (HashMap<unsigned, ID3D11RasterizerState*>::Iterator i = impl_->rasterizerStates_.Begin(); i != impl_->rasterizerStates_.End(); ++i)
Draw:1021:Direct3D11\D3D11Graphics.cpp:295:        if (i->second_)
Draw:1022:Direct3D11\D3D11Graphics.cpp:296:            i->second_->Release();
Draw:1023:Direct3D11\D3D11Graphics.cpp:298:    impl_->rasterizerStates_.Clear();
Draw:1024:Direct3D11\D3D11Graphics.cpp:300:    if (impl_->defaultRenderTargetView_)
Draw:1025:Direct3D11\D3D11Graphics.cpp:302:        impl_->defaultRenderTargetView_->Release();
Draw:1026:Direct3D11\D3D11Graphics.cpp:303:        impl_->defaultRenderTargetView_ = 0;
Draw:1027:Direct3D11\D3D11Graphics.cpp:305:    if (impl_->defaultDepthStencilView_)
Draw:1028:Direct3D11\D3D11Graphics.cpp:307:        impl_->defaultDepthStencilView_->Release();
Draw:1029:Direct3D11\D3D11Graphics.cpp:308:        impl_->defaultDepthStencilView_ = 0;
Draw:1030:Direct3D11\D3D11Graphics.cpp:310:    if (impl_->defaultDepthTexture_)
Draw:1031:Direct3D11\D3D11Graphics.cpp:312:        impl_->defaultDepthTexture_->Release();
Draw:1032:Direct3D11\D3D11Graphics.cpp:313:        impl_->defaultDepthTexture_ = 0;
Draw:1033:Direct3D11\D3D11Graphics.cpp:315:    if (impl_->swapChain_)
Draw:1034:Direct3D11\D3D11Graphics.cpp:317:        impl_->swapChain_->Release();
Draw:1035:Direct3D11\D3D11Graphics.cpp:318:        impl_->swapChain_ = 0;
Draw:1036:Direct3D11\D3D11Graphics.cpp:320:    if (impl_->deviceContext_)
Draw:1037:Direct3D11\D3D11Graphics.cpp:322:        impl_->deviceContext_->Release();
Draw:1038:Direct3D11\D3D11Graphics.cpp:323:        impl_->deviceContext_ = 0;
Draw:1039:Direct3D11\D3D11Graphics.cpp:325:    if (impl_->device_)
Draw:1040:Direct3D11\D3D11Graphics.cpp:327:        impl_->device_->Release();
Draw:1041:Direct3D11\D3D11Graphics.cpp:328:        impl_->device_ = 0;
Draw:1042:Direct3D11\D3D11Graphics.cpp:330:    if (impl_->window_)
Draw:1043:Direct3D11\D3D11Graphics.cpp:333:        SDL_DestroyWindow(impl_->window_);
Draw:1044:Direct3D11\D3D11Graphics.cpp:334:        impl_->window_ = 0;
Draw:1045:Direct3D11\D3D11Graphics.cpp:340:    // Shut down SDL now. Graphics should be the last SDL-using subsystem to be destroyed
Draw:1046:Direct3D11\D3D11Graphics.cpp:346:    if (!impl_->window_)
Draw:1047:Direct3D11\D3D11Graphics.cpp:355:    if (impl_->window_)
Draw:1048:Direct3D11\D3D11Graphics.cpp:356:        SDL_SetWindowTitle(impl_->window_, windowTitle_.CString());
Draw:1049:Direct3D11\D3D11Graphics.cpp:362:    if (impl_->window_)
Draw:1050:Direct3D11\D3D11Graphics.cpp:368:    if (impl_->window_)
Draw:1051:Direct3D11\D3D11Graphics.cpp:369:        SDL_SetWindowPosition(impl_->window_, position.x_, position.y_);
Draw:1052:Direct3D11\D3D11Graphics.cpp:421:    if (!impl_->window_)
Draw:1053:Direct3D11\D3D11Graphics.cpp:440:                unsigned error = Abs(resolutions[i].x_ - width) + Abs(resolutions[i].y_ - height);
Draw:1054:Direct3D11\D3D11Graphics.cpp:458:        SDL_GetWindowSize(impl_->window_, &width, &height);
Draw:1055:Direct3D11\D3D11Graphics.cpp:461:    if (!impl_->device_ || multiSample_ != multiSample)
Draw:1056:Direct3D11\D3D11Graphics.cpp:473:    impl_->swapChain_->Present(0, 0);
Draw:1057:Direct3D11\D3D11Graphics.cpp:511:        if (impl_->swapChain_)
Draw:1058:Direct3D11\D3D11Graphics.cpp:524:    if (impl_->device_)
Draw:1059:Direct3D11\D3D11Graphics.cpp:527:        impl_->device_->QueryInterface(IID_IDXGIDevice1, (void **)&dxgiDevice);
Draw:1060:Direct3D11\D3D11Graphics.cpp:530:            dxgiDevice->SetMaximumFrameLatency(enable ? 1 : 3);
Draw:1061:Direct3D11\D3D11Graphics.cpp:531:            dxgiDevice->Release();
Draw:1062:Direct3D11\D3D11Graphics.cpp:549:    if (impl_->window_)
Draw:1063:Direct3D11\D3D11Graphics.cpp:552:        SDL_DestroyWindow(impl_->window_);
Draw:1064:Direct3D11\D3D11Graphics.cpp:553:        impl_->window_ = 0;
Draw:1065:Direct3D11\D3D11Graphics.cpp:561:    if (!impl_->device_)
Draw:1066:Direct3D11\D3D11Graphics.cpp:577:    impl_->device_->CreateTexture2D(&textureDesc, 0, &stagingTexture);
Draw:1067:Direct3D11\D3D11Graphics.cpp:585:    impl_->defaultRenderTargetView_->GetResource(&source);
Draw:1068:Direct3D11\D3D11Graphics.cpp:594:        impl_->device_->CreateTexture2D(&textureDesc, 0, &resolveTexture);
Draw:1069:Direct3D11\D3D11Graphics.cpp:598:            stagingTexture->Release();
Draw:1070:Direct3D11\D3D11Graphics.cpp:602:        impl_->deviceContext_->ResolveSubresource(resolveTexture, 0, source, 0, DXGI_FORMAT_R8G8B8A8_UNORM);
Draw:1071:Direct3D11\D3D11Graphics.cpp:603:        impl_->deviceContext_->CopyResource(stagingTexture, resolveTexture);
Draw:1072:Direct3D11\D3D11Graphics.cpp:604:        resolveTexture->Release();
Draw:1073:Direct3D11\D3D11Graphics.cpp:607:        impl_->deviceContext_->CopyResource(stagingTexture, source);
Draw:1074:Direct3D11\D3D11Graphics.cpp:609:    source->Release();
Draw:1075:Direct3D11\D3D11Graphics.cpp:613:    impl_->deviceContext_->Map(stagingTexture, 0, D3D11_MAP_READ, 0, &mappedData);
Draw:1076:Direct3D11\D3D11Graphics.cpp:630:        impl_->deviceContext_->Unmap(stagingTexture, 0);
Draw:1077:Direct3D11\D3D11Graphics.cpp:631:        stagingTexture->Release();
Draw:1078:Direct3D11\D3D11Graphics.cpp:637:        stagingTexture->Release();
Draw:1079:Direct3D11\D3D11Graphics.cpp:652:        SDL_GetWindowSize(impl_->window_, &width, &height);
Draw:1080:Direct3D11\D3D11Graphics.cpp:660:        if (fullscreen_ && (SDL_GetWindowFlags(impl_->window_) & SDL_WINDOW_MINIMIZED))
Draw:1081:Direct3D11\D3D11Graphics.cpp:689:        impl_->swapChain_->Present(vsync_ ? 1 : 0, 0);
Draw:1082:Direct3D11\D3D11Graphics.cpp:706:        if ((flags & CLEAR_COLOR) && impl_->renderTargetViews_[0])
Draw:1083:Direct3D11\D3D11Graphics.cpp:707:            impl_->deviceContext_->ClearRenderTargetView(impl_->renderTargetViews_[0], color.Data());
Draw:1084:Direct3D11\D3D11Graphics.cpp:709:        if ((flags & (CLEAR_DEPTH | CLEAR_STENCIL)) && impl_->depthStencilView_)
Draw:1085:Direct3D11\D3D11Graphics.cpp:716:            impl_->deviceContext_->ClearDepthStencilView(impl_->depthStencilView_, depthClearFlags, depth, stencil);
Draw:1086:Direct3D11\D3D11Graphics.cpp:725:        Geometry* geometry = renderer->GetQuadGeometry();
Draw:1087:Direct3D11\D3D11Graphics.cpp:743:        geometry->Draw(this);
Draw:1088:Direct3D11\D3D11Graphics.cpp:754:    if (!destination || !destination->GetRenderSurface())
Draw:1089:Direct3D11\D3D11Graphics.cpp:774:    destRect.right = destination->GetWidth();
Draw:1090:Direct3D11\D3D11Graphics.cpp:775:    destRect.bottom = destination->GetHeight();
Draw:1091:Direct3D11\D3D11Graphics.cpp:782:        source = (ID3D11Resource*)renderTargets_[0]->GetParentTexture()->GetGPUObject();
Draw:1092:Direct3D11\D3D11Graphics.cpp:785:        impl_->defaultRenderTargetView_->GetResource(&source);
Draw:1093:Direct3D11\D3D11Graphics.cpp:791:        impl_->deviceContext_->CopyResource((ID3D11Resource*)destination->GetGPUObject(), source);
Draw:1094:Direct3D11\D3D11Graphics.cpp:794:        impl_->deviceContext_->ResolveSubresource((ID3D11Resource*)destination->GetGPUObject(), 0, source, 0, (DXGI_FORMAT)
Draw:1095:Direct3D11\D3D11Graphics.cpp:795:            destination->GetFormat());
Draw:1096:Direct3D11\D3D11Graphics.cpp:799:        source->Release();
Draw:1097:Direct3D11\D3D11Graphics.cpp:817:        impl_->deviceContext_->IASetPrimitiveTopology(d3dPrimitiveType);
Draw:1098:Direct3D11\D3D11Graphics.cpp:820:    impl_->deviceContext_->Draw(vertexCount, vertexStart);
Draw:1099:Direct3D11\D3D11Graphics.cpp:839:        impl_->deviceContext_->IASetPrimitiveTopology(d3dPrimitiveType);
Draw:1100:Direct3D11\D3D11Graphics.cpp:842:    impl_->deviceContext_->DrawIndexed(indexCount, indexStart, 0);
Draw:1101:Direct3D11\D3D11Graphics.cpp:862:        impl_->deviceContext_->IASetPrimitiveTopology(d3dPrimitiveType);
Draw:1102:Direct3D11\D3D11Graphics.cpp:865:    impl_->deviceContext_->DrawIndexedInstanced(indexCount, instanceCount, indexStart, 0, 0);
Draw:1103:Direct3D11\D3D11Graphics.cpp:873:    // Note: this is not multi-instance safe
Draw:1104:Direct3D11\D3D11Graphics.cpp:903:            unsigned elementMask = buffer->GetElementMask() & elementMasks[i];
Draw:1105:Direct3D11\D3D11Graphics.cpp:904:            unsigned offset = (elementMask & MASK_INSTANCEMATRIX1) ? instanceOffset * buffer->GetVertexSize() : 0;
Draw:1106:Direct3D11\D3D11Graphics.cpp:906:            if (buffer != vertexBuffers_[i] || elementMask != elementMasks_[i] || offset != impl_->vertexOffsets_[i])
Draw:1107:Direct3D11\D3D11Graphics.cpp:910:                impl_->vertexBuffers_[i] = (ID3D11Buffer*)buffer->GetGPUObject();
Draw:1108:Direct3D11\D3D11Graphics.cpp:911:                impl_->vertexSizes_[i] = buffer->GetVertexSize();
Draw:1109:Direct3D11\D3D11Graphics.cpp:912:                impl_->vertexOffsets_[i] = offset;
Draw:1110:Direct3D11\D3D11Graphics.cpp:920:            impl_->vertexBuffers_[i] = 0;
Draw:1111:Direct3D11\D3D11Graphics.cpp:921:            impl_->vertexSizes_[i] = 0;
Draw:1112:Direct3D11\D3D11Graphics.cpp:922:            impl_->vertexOffsets_[i] = 0;
Draw:1113:Direct3D11\D3D11Graphics.cpp:957:            impl_->deviceContext_->IASetIndexBuffer((ID3D11Buffer*)buffer->GetGPUObject(), buffer->GetIndexSize() ==
Draw:1114:Direct3D11\D3D11Graphics.cpp:961:            impl_->deviceContext_->IASetIndexBuffer(0, DXGI_FORMAT_UNKNOWN, 0);
Draw:1115:Direct3D11\D3D11Graphics.cpp:974:            vs = vs->GetOwner()->GetVariation(VS, vs->GetDefines() + " CLIPPLANE");
Draw:1116:Direct3D11\D3D11Graphics.cpp:976:            ps = ps->GetOwner()->GetVariation(PS, ps->GetDefines() + " CLIPPLANE");
Draw:1117:Direct3D11\D3D11Graphics.cpp:985:        if (vs && !vs->GetGPUObject())
Draw:1118:Direct3D11\D3D11Graphics.cpp:987:            if (vs->GetCompilerOutput().Empty())
Draw:1119:Direct3D11\D3D11Graphics.cpp:991:                bool success = vs->Create();
Draw:1120:Direct3D11\D3D11Graphics.cpp:994:                    LOGERROR("Failed to compile vertex shader " + vs->GetFullName() + ":\n" + vs->GetCompilerOutput());
Draw:1121:Direct3D11\D3D11Graphics.cpp:1002:        impl_->deviceContext_->VSSetShader((ID3D11VertexShader*)(vs ? vs->GetGPUObject() : 0), 0, 0);
Draw:1122:Direct3D11\D3D11Graphics.cpp:1009:        if (ps && !ps->GetGPUObject())
Draw:1123:Direct3D11\D3D11Graphics.cpp:1011:            if (ps->GetCompilerOutput().Empty())
Draw:1124:Direct3D11\D3D11Graphics.cpp:1015:                bool success = ps->Create();
Draw:1125:Direct3D11\D3D11Graphics.cpp:1018:                    LOGERROR("Failed to compile pixel shader " + ps->GetFullName() + ":\n" + ps->GetCompilerOutput());
Draw:1126:Direct3D11\D3D11Graphics.cpp:1026:        impl_->deviceContext_->PSSetShader((ID3D11PixelShader*)(ps ? ps->GetGPUObject() : 0), 0, 0);
Draw:1127:Direct3D11\D3D11Graphics.cpp:1036:            shaderProgram_ = i->second_.Get();
Draw:1128:Direct3D11\D3D11Graphics.cpp:1048:            ID3D11Buffer* vsBuffer = shaderProgram_->vsConstantBuffers_[i] ? (ID3D11Buffer*)shaderProgram_->vsConstantBuffers_[i]->
Draw:1129:Direct3D11\D3D11Graphics.cpp:1050:            if (vsBuffer != impl_->constantBuffers_[VS][i])
Draw:1130:Direct3D11\D3D11Graphics.cpp:1052:                impl_->constantBuffers_[VS][i] = vsBuffer;
Draw:1131:Direct3D11\D3D11Graphics.cpp:1057:            ID3D11Buffer* psBuffer = shaderProgram_->psConstantBuffers_[i] ? (ID3D11Buffer*)shaderProgram_->psConstantBuffers_[i]->
Draw:1132:Direct3D11\D3D11Graphics.cpp:1059:            if (psBuffer != impl_->constantBuffers_[PS][i])
Draw:1133:Direct3D11\D3D11Graphics.cpp:1061:                impl_->constantBuffers_[PS][i] = psBuffer;
Draw:1134:Direct3D11\D3D11Graphics.cpp:1068:            impl_->deviceContext_->VSSetConstantBuffers(0, MAX_SHADER_PARAMETER_GROUPS, &impl_->constantBuffers_[VS][0]);
Draw:1135:Direct3D11\D3D11Graphics.cpp:1070:            impl_->deviceContext_->PSSetConstantBuffers(0, MAX_SHADER_PARAMETER_GROUPS, &impl_->constantBuffers_[PS][0]);
Draw:1136:Direct3D11\D3D11Graphics.cpp:1077:        shaderPrecache_->StoreShaders(vertexShader_, pixelShader_);
Draw:1137:Direct3D11\D3D11Graphics.cpp:1087:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1138:Direct3D11\D3D11Graphics.cpp:1090:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Draw:1139:Direct3D11\D3D11Graphics.cpp:1091:    if (!buffer->IsDirty())
Draw:1140:Direct3D11\D3D11Graphics.cpp:1093:    buffer->SetParameter(i->second_.offset_, count * sizeof(float), data);
Draw:1141:Direct3D11\D3D11Graphics.cpp:1099:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1142:Direct3D11\D3D11Graphics.cpp:1102:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Draw:1143:Direct3D11\D3D11Graphics.cpp:1103:    if (!buffer->IsDirty())
Draw:1144:Direct3D11\D3D11Graphics.cpp:1105:    buffer->SetParameter(i->second_.offset_, sizeof(float), &value);
Draw:1145:Direct3D11\D3D11Graphics.cpp:1111:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1146:Direct3D11\D3D11Graphics.cpp:1114:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Draw:1147:Direct3D11\D3D11Graphics.cpp:1115:    if (!buffer->IsDirty())
Draw:1148:Direct3D11\D3D11Graphics.cpp:1117:    buffer->SetParameter(i->second_.offset_, sizeof(bool), &value);
Draw:1149:Direct3D11\D3D11Graphics.cpp:1123:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1150:Direct3D11\D3D11Graphics.cpp:1126:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Draw:1151:Direct3D11\D3D11Graphics.cpp:1127:    if (!buffer->IsDirty())
Draw:1152:Direct3D11\D3D11Graphics.cpp:1129:    buffer->SetParameter(i->second_.offset_, sizeof(Color), &color);
Draw:1153:Direct3D11\D3D11Graphics.cpp:1135:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1154:Direct3D11\D3D11Graphics.cpp:1138:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Draw:1155:Direct3D11\D3D11Graphics.cpp:1139:    if (!buffer->IsDirty())
Draw:1156:Direct3D11\D3D11Graphics.cpp:1141:    buffer->SetParameter(i->second_.offset_, sizeof(Vector2), &vector);
Draw:1157:Direct3D11\D3D11Graphics.cpp:1147:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1158:Direct3D11\D3D11Graphics.cpp:1150:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Draw:1159:Direct3D11\D3D11Graphics.cpp:1151:    if (!buffer->IsDirty())
Draw:1160:Direct3D11\D3D11Graphics.cpp:1153:    buffer->SetVector3ArrayParameter(i->second_.offset_, 3, &matrix);
Draw:1161:Direct3D11\D3D11Graphics.cpp:1159:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1162:Direct3D11\D3D11Graphics.cpp:1162:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Draw:1163:Direct3D11\D3D11Graphics.cpp:1163:    if (!buffer->IsDirty())
Draw:1164:Direct3D11\D3D11Graphics.cpp:1165:    buffer->SetParameter(i->second_.offset_, sizeof(Vector3), &vector);
Draw:1165:Direct3D11\D3D11Graphics.cpp:1171:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1166:Direct3D11\D3D11Graphics.cpp:1174:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Draw:1167:Direct3D11\D3D11Graphics.cpp:1175:    if (!buffer->IsDirty())
Draw:1168:Direct3D11\D3D11Graphics.cpp:1177:    buffer->SetParameter(i->second_.offset_, sizeof(Matrix4), &matrix);
Draw:1169:Direct3D11\D3D11Graphics.cpp:1183:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1170:Direct3D11\D3D11Graphics.cpp:1186:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Draw:1171:Direct3D11\D3D11Graphics.cpp:1187:    if (!buffer->IsDirty())
Draw:1172:Direct3D11\D3D11Graphics.cpp:1189:    buffer->SetParameter(i->second_.offset_, sizeof(Vector4), &vector);
Draw:1173:Direct3D11\D3D11Graphics.cpp:1195:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1174:Direct3D11\D3D11Graphics.cpp:1198:    ConstantBuffer* buffer = i->second_.bufferPtr_;
Draw:1175:Direct3D11\D3D11Graphics.cpp:1199:    if (!buffer->IsDirty())
Draw:1176:Direct3D11\D3D11Graphics.cpp:1201:    buffer->SetParameter(i->second_.offset_, sizeof(Matrix3x4), &matrix);
Draw:1177:Direct3D11\D3D11Graphics.cpp:1263:    return shaderProgram_ && shaderProgram_->parameters_.Find(param) != shaderProgram_->parameters_.End();
Draw:1178:Direct3D11\D3D11Graphics.cpp:1268:    return pixelShader_ && pixelShader_->HasTextureUnit(unit);
Draw:1179:Direct3D11\D3D11Graphics.cpp:1296:        if (renderTargets_[0] && renderTargets_[0]->GetParentTexture() == texture)
Draw:1180:Direct3D11\D3D11Graphics.cpp:1297:            texture = texture->GetBackupTexture();
Draw:1181:Direct3D11\D3D11Graphics.cpp:1300:    if (texture && texture->GetParametersDirty())
Draw:1182:Direct3D11\D3D11Graphics.cpp:1302:        texture->UpdateParameters();
Draw:1183:Direct3D11\D3D11Graphics.cpp:1319:        impl_->shaderResourceViews_[index] = texture ? (ID3D11ShaderResourceView*)texture->GetShaderResourceView() : 0;
Draw:1184:Direct3D11\D3D11Graphics.cpp:1320:        impl_->samplers_[index] = texture ? (ID3D11SamplerState*)texture->GetSampler() : 0;
Draw:1185:Direct3D11\D3D11Graphics.cpp:1351:            texture->SetParametersDirty();
Draw:1186:Direct3D11\D3D11Graphics.cpp:1386:            Texture* parentTexture = renderTarget->GetParentTexture();
Draw:1187:Direct3D11\D3D11Graphics.cpp:1391:                    SetTexture(i, textures_[i]->GetBackupTexture());
Draw:1188:Direct3D11\D3D11Graphics.cpp:1401:        renderTarget = texture->GetRenderSurface();
Draw:1189:Direct3D11\D3D11Graphics.cpp:1419:        depthStencil = texture->GetRenderSurface();
Draw:1190:Direct3D11\D3D11Graphics.cpp:1444:    d3dViewport.Width = (float)(rectCopy.right_ - rectCopy.left_);
Draw:1191:Direct3D11\D3D11Graphics.cpp:1445:    d3dViewport.Height = (float)(rectCopy.bottom_ - rectCopy.top_);
Draw:1192:Direct3D11\D3D11Graphics.cpp:1449:    impl_->deviceContext_->RSSetViewports(1, &d3dViewport);
Draw:1193:Direct3D11\D3D11Graphics.cpp:1453:    // Disable scissor test, needs to be re-enabled by the user
Draw:1194:Direct3D11\D3D11Graphics.cpp:1536:        intRect.left_ = Clamp((int)((rect.min_.x_ + 1.0f) * 0.5f * viewSize.x_) + viewPos.x_, 0, rtSize.x_ - 1);
Draw:1195:Direct3D11\D3D11Graphics.cpp:1537:        intRect.top_ = Clamp((int)((-rect.max_.y_ + 1.0f) * 0.5f * viewSize.y_) + viewPos.y_, 0, rtSize.y_ - 1);
Draw:1196:Direct3D11\D3D11Graphics.cpp:1539:        intRect.bottom_ = Clamp((int)((-rect.min_.y_ + 1.0f) * 0.5f * viewSize.y_) + viewPos.y_ + expand, 0, rtSize.y_);
Draw:1197:Direct3D11\D3D11Graphics.cpp:1572:        intRect.left_ = Clamp(rect.left_ + viewPos.x_, 0, rtSize.x_ - 1);
Draw:1198:Direct3D11\D3D11Graphics.cpp:1573:        intRect.top_ = Clamp(rect.top_ + viewPos.y_, 0, rtSize.y_ - 1);
Draw:1199:Direct3D11\D3D11Graphics.cpp:1679:    return impl_->window_ != 0 && impl_->GetDevice() != 0;
Draw:1200:Direct3D11\D3D11Graphics.cpp:1684:    if (impl_->window_)
Draw:1201:Direct3D11\D3D11Graphics.cpp:1724:    if (impl_->device_)
Draw:1202:Direct3D11\D3D11Graphics.cpp:1729:            impl_->device_->CheckMultisampleQualityLevels(sRGB_ ? DXGI_FORMAT_R8G8B8A8_UNORM_SRGB : DXGI_FORMAT_R8G8B8A8_UNORM,
Draw:1203:Direct3D11\D3D11Graphics.cpp:1779:        if (lastShaderName_ == name && !cache->Exists(fullShaderName))
Draw:1204:Direct3D11\D3D11Graphics.cpp:1782:        lastShader_ = cache->GetResource<Shader>(fullShaderName);
Draw:1205:Direct3D11\D3D11Graphics.cpp:1786:    return lastShader_ ? lastShader_->GetVariation(type, defines) : (ShaderVariation*)0;
Draw:1206:Direct3D11\D3D11Graphics.cpp:1798:        return i->second_;
Draw:1207:Direct3D11\D3D11Graphics.cpp:1807:        if (i->second_ == unit)
Draw:1208:Direct3D11\D3D11Graphics.cpp:1808:            return i->first_;
Draw:1209:Direct3D11\D3D11Graphics.cpp:1829:        width = renderTargets_[0]->GetWidth();
Draw:1210:Direct3D11\D3D11Graphics.cpp:1830:        height = renderTargets_[0]->GetHeight();
Draw:1211:Direct3D11\D3D11Graphics.cpp:1832:    else if (depthStencil_) // Depth-only rendering
Draw:1212:Direct3D11\D3D11Graphics.cpp:1834:        width = depthStencil_->GetWidth();
Draw:1213:Direct3D11\D3D11Graphics.cpp:1835:        height = depthStencil_->GetHeight();
Draw:1214:Direct3D11\D3D11Graphics.cpp:1848:    if (!impl_->device_ || !impl_->window_)
Draw:1215:Direct3D11\D3D11Graphics.cpp:1853:    SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Draw:1216:Direct3D11\D3D11Graphics.cpp:1877:    if (!impl_->device_ || !impl_->window_ || fullscreen_)
Draw:1217:Direct3D11\D3D11Graphics.cpp:1882:    SDL_GetWindowPosition(impl_->window_, &newX, &newY);
Draw:1218:Direct3D11\D3D11Graphics.cpp:1901:    if (!impl_->window_)
Draw:1219:Direct3D11\D3D11Graphics.cpp:1904:    SDL_MaximizeWindow(impl_->window_);
Draw:1220:Direct3D11\D3D11Graphics.cpp:1909:    if (!impl_->window_)
Draw:1221:Direct3D11\D3D11Graphics.cpp:1912:    SDL_MinimizeWindow(impl_->window_);
Draw:1222:Direct3D11\D3D11Graphics.cpp:1940:        if (!i->reserved_ && i->size_ >= size)
Draw:1223:Direct3D11\D3D11Graphics.cpp:1942:            i->reserved_ = true;
Draw:1224:Direct3D11\D3D11Graphics.cpp:1943:            return i->data_.Get();
Draw:1225:Direct3D11\D3D11Graphics.cpp:1950:        if (!i->reserved_)
Draw:1226:Direct3D11\D3D11Graphics.cpp:1952:            i->data_ = new unsigned char[size];
Draw:1227:Direct3D11\D3D11Graphics.cpp:1953:            i->size_ = size;
Draw:1228:Direct3D11\D3D11Graphics.cpp:1954:            i->reserved_ = true;
Draw:1229:Direct3D11\D3D11Graphics.cpp:1958:            return i->data_.Get();
Draw:1230:Direct3D11\D3D11Graphics.cpp:1980:        if (i->reserved_ && i->data_.Get() == buffer)
Draw:1231:Direct3D11\D3D11Graphics.cpp:1982:            i->reserved_ = false;
Draw:1232:Direct3D11\D3D11Graphics.cpp:1994:        if (!i->reserved_ && i->size_ > maxScratchBufferRequest_ * 2)
Draw:1233:Direct3D11\D3D11Graphics.cpp:1996:            i->data_ = maxScratchBufferRequest_ > 0 ? new unsigned char[maxScratchBufferRequest_] : 0;
Draw:1234:Direct3D11\D3D11Graphics.cpp:1997:            i->size_ = maxScratchBufferRequest_;
Draw:1235:Direct3D11\D3D11Graphics.cpp:2010:        if (i->first_.first_ == variation || i->first_.second_ == variation)
Draw:1236:Direct3D11\D3D11Graphics.cpp:2026:        return i->second_.Get();
Draw:1237:Direct3D11\D3D11Graphics.cpp:2030:        newConstantBuffer->SetSize(size);
Draw:1238:Direct3D11\D3D11Graphics.cpp:2168:        impl_->window_ = SDL_CreateWindow(windowTitle_.CString(), position_.x_, position_.y_, width, height, flags);
Draw:1239:Direct3D11\D3D11Graphics.cpp:2171:        impl_->window_ = SDL_CreateWindowFrom(externalWindow_, 0);
Draw:1240:Direct3D11\D3D11Graphics.cpp:2173:    if (!impl_->window_)
Draw:1241:Direct3D11\D3D11Graphics.cpp:2179:    SDL_GetWindowPosition(impl_->window_, &position_.x_, &position_.y_);
Draw:1242:Direct3D11\D3D11Graphics.cpp:2190:        SDL_Surface* surface = windowIcon_->GetSDLSurface();
Draw:1243:Direct3D11\D3D11Graphics.cpp:2193:            SDL_SetWindowIcon(impl_->window_, surface);
Draw:1244:Direct3D11\D3D11Graphics.cpp:2205:            SDL_MaximizeWindow(impl_->window_);
Draw:1245:Direct3D11\D3D11Graphics.cpp:2206:            SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Draw:1246:Direct3D11\D3D11Graphics.cpp:2209:            SDL_SetWindowSize(impl_->window_, newWidth, newHeight);
Draw:1247:Direct3D11\D3D11Graphics.cpp:2211:        SDL_SetWindowFullscreen(impl_->window_, newFullscreen ? SDL_TRUE : SDL_FALSE);
Draw:1248:Direct3D11\D3D11Graphics.cpp:2212:        SDL_SetWindowBordered(impl_->window_, newBorderless ? SDL_FALSE : SDL_TRUE);
Draw:1249:Direct3D11\D3D11Graphics.cpp:2217:        SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Draw:1250:Direct3D11\D3D11Graphics.cpp:2225:    if (!impl_->device_)
Draw:1251:Direct3D11\D3D11Graphics.cpp:2235:            &impl_->device_,
Draw:1252:Direct3D11\D3D11Graphics.cpp:2237:            &impl_->deviceContext_
Draw:1253:Direct3D11\D3D11Graphics.cpp:2240:        if (!impl_->device_ || !impl_->deviceContext_)
Draw:1254:Direct3D11\D3D11Graphics.cpp:2257:    if (impl_->swapChain_)
Draw:1255:Direct3D11\D3D11Graphics.cpp:2259:        impl_->swapChain_->Release();
Draw:1256:Direct3D11\D3D11Graphics.cpp:2260:        impl_->swapChain_ = 0;
Draw:1257:Direct3D11\D3D11Graphics.cpp:2270:    swapChainDesc.OutputWindow = GetWindowHandle(impl_->window_);
Draw:1258:Direct3D11\D3D11Graphics.cpp:2277:    impl_->device_->QueryInterface(IID_IDXGIDevice, (void **)&dxgiDevice);
Draw:1259:Direct3D11\D3D11Graphics.cpp:2279:    dxgiDevice->GetParent(IID_IDXGIAdapter, (void **)&dxgiAdapter);
Draw:1260:Direct3D11\D3D11Graphics.cpp:2281:    dxgiAdapter->GetParent(IID_IDXGIFactory, (void **)&dxgiFactory);
Draw:1261:Direct3D11\D3D11Graphics.cpp:2282:    dxgiFactory->CreateSwapChain(impl_->device_, &swapChainDesc, &impl_->swapChain_);
Draw:1262:Direct3D11\D3D11Graphics.cpp:2283:    // After creating the swap chain, disable automatic Alt-Enter fullscreen/windowed switching
Draw:1263:Direct3D11\D3D11Graphics.cpp:2285:    dxgiFactory->MakeWindowAssociation(GetWindowHandle(impl_->window_), DXGI_MWA_NO_ALT_ENTER);
Draw:1264:Direct3D11\D3D11Graphics.cpp:2287:    dxgiFactory->Release();
Draw:1265:Direct3D11\D3D11Graphics.cpp:2288:    dxgiAdapter->Release();
Draw:1266:Direct3D11\D3D11Graphics.cpp:2289:    dxgiDevice->Release();
Draw:1267:Direct3D11\D3D11Graphics.cpp:2291:    if (impl_->swapChain_)
Draw:1268:Direct3D11\D3D11Graphics.cpp:2308:    impl_->deviceContext_->OMSetRenderTargets(1, &nullView, 0);
Draw:1269:Direct3D11\D3D11Graphics.cpp:2309:    if (impl_->defaultRenderTargetView_)
Draw:1270:Direct3D11\D3D11Graphics.cpp:2311:        impl_->defaultRenderTargetView_->Release();
Draw:1271:Direct3D11\D3D11Graphics.cpp:2312:        impl_->defaultRenderTargetView_ = 0;
Draw:1272:Direct3D11\D3D11Graphics.cpp:2314:    if (impl_->defaultDepthStencilView_)
Draw:1273:Direct3D11\D3D11Graphics.cpp:2316:        impl_->defaultDepthStencilView_->Release();
Draw:1274:Direct3D11\D3D11Graphics.cpp:2317:        impl_->defaultDepthStencilView_ = 0;
Draw:1275:Direct3D11\D3D11Graphics.cpp:2319:    if (impl_->defaultDepthTexture_)
Draw:1276:Direct3D11\D3D11Graphics.cpp:2321:        impl_->defaultDepthTexture_->Release();
Draw:1277:Direct3D11\D3D11Graphics.cpp:2322:        impl_->defaultDepthTexture_ = 0;
Draw:1278:Direct3D11\D3D11Graphics.cpp:2325:    impl_->depthStencilView_ = 0;
Draw:1279:Direct3D11\D3D11Graphics.cpp:2327:        impl_->renderTargetViews_[i] = 0;
Draw:1280:Direct3D11\D3D11Graphics.cpp:2330:    impl_->swapChain_->ResizeBuffers(1, width, height, DXGI_FORMAT_UNKNOWN, DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH);
Draw:1281:Direct3D11\D3D11Graphics.cpp:2334:    impl_->swapChain_->GetBuffer(0, IID_ID3D11Texture2D, (void**)&backbufferTexture);
Draw:1282:Direct3D11\D3D11Graphics.cpp:2337:        impl_->device_->CreateRenderTargetView(backbufferTexture, 0, &impl_->defaultRenderTargetView_);
Draw:1283:Direct3D11\D3D11Graphics.cpp:2338:        backbufferTexture->Release();
Draw:1284:Direct3D11\D3D11Graphics.cpp:2346:    // Create default depth-stencil texture and view
Draw:1285:Direct3D11\D3D11Graphics.cpp:2360:    impl_->device_->CreateTexture2D(&depthDesc, 0, &impl_->defaultDepthTexture_);
Draw:1286:Direct3D11\D3D11Graphics.cpp:2361:    if (impl_->defaultDepthTexture_)
Draw:1287:Direct3D11\D3D11Graphics.cpp:2362:        impl_->device_->CreateDepthStencilView(impl_->defaultDepthTexture_, 0, &impl_->defaultDepthStencilView_);
Draw:1288:Direct3D11\D3D11Graphics.cpp:2365:        LOGERROR("Failed to create backbuffer depth-stencil texture");
Draw:1289:Direct3D11\D3D11Graphics.cpp:2396:        impl_->vertexBuffers_[i] = 0;
Draw:1290:Direct3D11\D3D11Graphics.cpp:2397:        impl_->vertexSizes_[i] = 0;
Draw:1291:Direct3D11\D3D11Graphics.cpp:2398:        impl_->vertexOffsets_[i] = 0;
Draw:1292:Direct3D11\D3D11Graphics.cpp:2404:        impl_->shaderResourceViews_[i] = 0;
Draw:1293:Direct3D11\D3D11Graphics.cpp:2405:        impl_->samplers_[i] = 0;
Draw:1294:Direct3D11\D3D11Graphics.cpp:2411:        impl_->renderTargetViews_[i] = 0;
Draw:1295:Direct3D11\D3D11Graphics.cpp:2416:        impl_->constantBuffers_[VS][i] = 0;
Draw:1296:Direct3D11\D3D11Graphics.cpp:2417:        impl_->constantBuffers_[PS][i] = 0;
Draw:1297:Direct3D11\D3D11Graphics.cpp:2421:    impl_->depthStencilView_ = 0;
Draw:1298:Direct3D11\D3D11Graphics.cpp:2470:        impl_->depthStencilView_ = depthStencil_ ? (ID3D11DepthStencilView*)depthStencil_->GetRenderTargetView() : impl_->defaultDepthStencilView_;
Draw:1299:Direct3D11\D3D11Graphics.cpp:2473:            impl_->renderTargetViews_[i] = renderTargets_[i] ? (ID3D11RenderTargetView*)renderTargets_[i]->GetRenderTargetView() : 0;
Draw:1300:Direct3D11\D3D11Graphics.cpp:2474:        // If rendertarget 0 is null and not doing depth-only rendering, render to the backbuffer
Draw:1301:Direct3D11\D3D11Graphics.cpp:2477:        if (!renderTargets_[0] && (!depthStencil_ || (depthStencil_ && depthStencil_->GetWidth() == width_ && depthStencil_->GetHeight() == height_)))
Draw:1302:Direct3D11\D3D11Graphics.cpp:2478:            impl_->renderTargetViews_[0] = impl_->defaultRenderTargetView_;
Draw:1303:Direct3D11\D3D11Graphics.cpp:2480:        impl_->deviceContext_->OMSetRenderTargets(MAX_RENDERTARGETS, &impl_->renderTargetViews_[0], impl_->depthStencilView_);
Draw:1304:Direct3D11\D3D11Graphics.cpp:2487:        impl_->deviceContext_->VSSetShaderResources(firstDirtyTexture_, lastDirtyTexture_ - firstDirtyTexture_ + 1,
Draw:1305:Direct3D11\D3D11Graphics.cpp:2488:            &impl_->shaderResourceViews_[firstDirtyTexture_]);
Draw:1306:Direct3D11\D3D11Graphics.cpp:2489:        impl_->deviceContext_->VSSetSamplers(firstDirtyTexture_, lastDirtyTexture_ - firstDirtyTexture_ + 1,
Draw:1307:Direct3D11\D3D11Graphics.cpp:2490:            &impl_->samplers_[firstDirtyTexture_]);
Draw:1308:Direct3D11\D3D11Graphics.cpp:2491:        impl_->deviceContext_->PSSetShaderResources(firstDirtyTexture_, lastDirtyTexture_ - firstDirtyTexture_ + 1,
Draw:1309:Direct3D11\D3D11Graphics.cpp:2492:            &impl_->shaderResourceViews_[firstDirtyTexture_]);
Draw:1310:Direct3D11\D3D11Graphics.cpp:2493:        impl_->deviceContext_->PSSetSamplers(firstDirtyTexture_, lastDirtyTexture_ - firstDirtyTexture_ + 1,
Draw:1311:Direct3D11\D3D11Graphics.cpp:2494:            &impl_->samplers_[firstDirtyTexture_]);
Draw:1312:Direct3D11\D3D11Graphics.cpp:2500:    if (vertexDeclarationDirty_ && vertexShader_ && vertexShader_->GetByteCode().Size())
Draw:1313:Direct3D11\D3D11Graphics.cpp:2504:            impl_->deviceContext_->IASetVertexBuffers(firstDirtyVB_, lastDirtyVB_ - firstDirtyVB_ + 1, &impl_->vertexBuffers_
Draw:1314:Direct3D11\D3D11Graphics.cpp:2505:                [firstDirtyVB_], &impl_->vertexSizes_[firstDirtyVB_], &impl_->vertexOffsets_[firstDirtyVB_]);
Draw:1315:Direct3D11\D3D11Graphics.cpp:2517:            newVertexDeclarationHash |= (unsigned long long)vertexShader_->GetElementMask() << 51;
Draw:1316:Direct3D11\D3D11Graphics.cpp:2528:                impl_->deviceContext_->IASetInputLayout((ID3D11InputLayout*)i->second_->GetInputLayout());
Draw:1317:Direct3D11\D3D11Graphics.cpp:2541:            HashMap<unsigned, ID3D11BlendState*>::Iterator i = impl_->blendStates_.Find(newBlendStateHash);
Draw:1318:Direct3D11\D3D11Graphics.cpp:2542:            if (i == impl_->blendStates_.End())
Draw:1319:Direct3D11\D3D11Graphics.cpp:2560:                impl_->device_->CreateBlendState(&stateDesc, &newBlendState);
Draw:1320:Direct3D11\D3D11Graphics.cpp:2564:                i = impl_->blendStates_.Insert(MakePair(newBlendStateHash, newBlendState));
Draw:1321:Direct3D11\D3D11Graphics.cpp:2567:            impl_->deviceContext_->OMSetBlendState(i->second_, 0, M_MAX_UNSIGNED);
Draw:1322:Direct3D11\D3D11Graphics.cpp:2581:            HashMap<unsigned, ID3D11DepthStencilState*>::Iterator i = impl_->depthStates_.Find(newDepthStateHash);
Draw:1323:Direct3D11\D3D11Graphics.cpp:2582:            if (i == impl_->depthStates_.End())
Draw:1324:Direct3D11\D3D11Graphics.cpp:2604:                impl_->device_->CreateDepthStencilState(&stateDesc, &newDepthState);
Draw:1325:Direct3D11\D3D11Graphics.cpp:2608:                i = impl_->depthStates_.Insert(MakePair(newDepthStateHash, newDepthState));
Draw:1326:Direct3D11\D3D11Graphics.cpp:2611:            impl_->deviceContext_->OMSetDepthStencilState(i->second_, stencilRef_);
Draw:1327:Direct3D11\D3D11Graphics.cpp:2622:        if (depthStencil_ && depthStencil_->GetParentTexture()->GetFormat() == DXGI_FORMAT_R16_TYPELESS)
Draw:1328:Direct3D11\D3D11Graphics.cpp:2630:            HashMap<unsigned, ID3D11RasterizerState*>::Iterator i = impl_->rasterizerStates_.Find(newRasterizerStateHash);
Draw:1329:Direct3D11\D3D11Graphics.cpp:2631:            if (i == impl_->rasterizerStates_.End())
Draw:1330:Direct3D11\D3D11Graphics.cpp:2649:                impl_->device_->CreateRasterizerState(&stateDesc, &newRasterizerState);
Draw:1331:Direct3D11\D3D11Graphics.cpp:2653:                i = impl_->rasterizerStates_.Insert(MakePair(newRasterizerStateHash, newRasterizerState));
Draw:1332:Direct3D11\D3D11Graphics.cpp:2656:            impl_->deviceContext_->RSSetState(i->second_);
Draw:1333:Direct3D11\D3D11Graphics.cpp:2670:        impl_->deviceContext_->RSSetScissorRects(1, &d3dRect);
Draw:1334:Direct3D11\D3D11Graphics.cpp:2675:        dirtyConstantBuffers_[i]->Apply();
Draw:1335:Direct3D11\D3D11GraphicsImpl.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1336:Direct3D11\D3D11GraphicsImpl.h:35:/// %Graphics implementation. Holds API-specific objects.
Draw:1337:Direct3D11\D3D11GraphicsImpl.h:64:    /// Default depth-stencil texture.
Draw:1338:Direct3D11\D3D11GraphicsImpl.h:66:    /// Default depth-stencil view.
Draw:1339:Direct3D11\D3D11GraphicsImpl.h:70:    /// Current depth-stencil view.
Draw:1340:Direct3D11\D3D11IndexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1341:Direct3D11\D3D11IndexBuffer.h:55:    /// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
Draw:1342:Direct3D11\D3D11IndexBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1343:Direct3D11\D3D11IndexBuffer.cpp:65:        if (graphics_->GetIndexBuffer() == this)
Draw:1344:Direct3D11\D3D11IndexBuffer.cpp:66:            graphics_->SetIndexBuffer(0);
Draw:1345:Direct3D11\D3D11IndexBuffer.cpp:68:        ((ID3D11Buffer*)object_)->Release();
Draw:1346:Direct3D11\D3D11IndexBuffer.cpp:146:            graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Buffer*)object_, 0, &destBox, data, 0, 0);
Draw:1347:Direct3D11\D3D11IndexBuffer.cpp:205:            graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Buffer*)object_, 0, &destBox, data, 0, 0);
Draw:1348:Direct3D11\D3D11IndexBuffer.cpp:249:        lockScratchData_ = graphics_->ReserveScratchBuffer(count * indexSize_);
Draw:1349:Direct3D11\D3D11IndexBuffer.cpp:272:            graphics_->FreeScratchBuffer(lockScratchData_);
Draw:1350:Direct3D11\D3D11IndexBuffer.cpp:321:    vertexCount = maxVertex - minVertex + 1;
Draw:1351:Direct3D11\D3D11IndexBuffer.cpp:341:        graphics_->GetImpl()->GetDevice()->CreateBuffer(&bufferDesc, 0, (ID3D11Buffer**)&object_);
Draw:1352:Direct3D11\D3D11IndexBuffer.cpp:370:        graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Buffer*)object_, 0, discard ? D3D11_MAP_WRITE_DISCARD :
Draw:1353:Direct3D11\D3D11IndexBuffer.cpp:386:        graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Buffer*)object_, 0);
Draw:1354:Direct3D11\D3D11Texture.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1355:Direct3D11\D3D11Texture.cpp:98:        mipsToSkip_[i] = MAX_TEXTURE_QUALITY_LEVELS - 1 - i;
Draw:1356:Direct3D11\D3D11Texture.cpp:140:        enable &= graphics_->GetSRGBSupport();
Draw:1357:Direct3D11\D3D11Texture.cpp:160:            if (mipsToSkip_[i] > mipsToSkip_[i - 1])
Draw:1358:Direct3D11\D3D11Texture.cpp:161:                mipsToSkip_[i] = mipsToSkip_[i - 1];
Draw:1359:Direct3D11\D3D11Texture.cpp:256:    XMLElement rootElem = file->GetRoot();
Draw:1360:Direct3D11\D3D11Texture.cpp:272:                TextureCoordinate coordIndex = (TextureCoordinate)(coord[0] - 'u');
Draw:1361:Direct3D11\D3D11Texture.cpp:322:        ((ID3D11SamplerState*)sampler_)->Release();
Draw:1362:Direct3D11\D3D11Texture.cpp:328:    unsigned filterModeIndex = filterMode_ != FILTER_DEFAULT ? filterMode_ : graphics_->GetDefaultTextureFilterMode();
Draw:1363:Direct3D11\D3D11Texture.cpp:335:    samplerDesc.MaxAnisotropy = graphics_->GetTextureAnisotropy();
Draw:1364:Direct3D11\D3D11Texture.cpp:337:    samplerDesc.MinLOD = -M_INFINITY;
Draw:1365:Direct3D11\D3D11Texture.cpp:341:    graphics_->GetImpl()->GetDevice()->CreateSamplerState(&samplerDesc, (ID3D11SamplerState**)&sampler_);
Draw:1366:Direct3D11\D3D11Texture.cpp:424:    unsigned textureBudget = cache->GetMemoryBudget(type);
Draw:1367:Direct3D11\D3D11Texture.cpp:425:    unsigned textureUse = cache->GetMemoryUse(type);
Draw:1368:Direct3D11\D3D11Texture.cpp:432:        cache->ReleaseResources(Material::GetTypeStatic());
Draw:1369:Direct3D11\D3D11RenderSurface.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1370:Direct3D11\D3D11RenderSurface.h:33:/// %Color or depth-stencil surface that can be rendered into.
Draw:1371:Direct3D11\D3D11RenderSurface.h:53:    /// Set linked depth-stencil surface.
Draw:1372:Direct3D11\D3D11RenderSurface.h:62:    /// Return Direct3D rendertarget or depth-stencil view.
Draw:1373:Direct3D11\D3D11RenderSurface.h:78:    /// Return linked depth-stencil surface.
Draw:1374:Direct3D11\D3D11RenderSurface.h:87:    /// Direct3D rendertarget or depth-stencil view.
Draw:1375:Direct3D11\D3D11ShaderProgram.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1376:Direct3D11\D3D11ShaderProgram.h:41:        const unsigned* vsBufferSizes = vertexShader->GetConstantBufferSizes();
Draw:1377:Direct3D11\D3D11ShaderProgram.h:45:                vsConstantBuffers_[i] = graphics->GetOrCreateConstantBuffer(VS, i, vsBufferSizes[i]);
Draw:1378:Direct3D11\D3D11ShaderProgram.h:48:        const unsigned* psBufferSizes = pixelShader->GetConstantBufferSizes();
Draw:1379:Direct3D11\D3D11ShaderProgram.h:52:                psConstantBuffers_[i] = graphics->GetOrCreateConstantBuffer(PS, i, psBufferSizes[i]);
Draw:1380:Direct3D11\D3D11ShaderProgram.h:56:        const HashMap<StringHash, ShaderParameter>& vsParams = vertexShader->GetParameters();
Draw:1381:Direct3D11\D3D11ShaderProgram.h:59:            parameters_[i->first_] = i->second_;
Draw:1382:Direct3D11\D3D11ShaderProgram.h:60:            parameters_[i->first_].bufferPtr_ = vsConstantBuffers_[i->second_.buffer_].Get();
Draw:1383:Direct3D11\D3D11ShaderProgram.h:63:        const HashMap<StringHash, ShaderParameter>& psParams = pixelShader->GetParameters();
Draw:1384:Direct3D11\D3D11ShaderProgram.h:66:            parameters_[i->first_] = i->second_;
Draw:1385:Direct3D11\D3D11ShaderProgram.h:67:            parameters_[i->first_].bufferPtr_ = psConstantBuffers_[i->second_.buffer_].Get();
Draw:1386:Direct3D11\D3D11ShaderVariation.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1387:Direct3D11\D3D11ShaderVariation.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1388:Direct3D11\D3D11ShaderVariation.cpp:42:    GPUObject(owner->GetSubsystem<Graphics>()),
Draw:1389:Direct3D11\D3D11ShaderVariation.cpp:71:    // Check for up-to-date bytecode on disk
Draw:1390:Direct3D11\D3D11ShaderVariation.cpp:73:    SplitPath(owner_->GetName(), path, name, extension);
Draw:1391:Direct3D11\D3D11ShaderVariation.cpp:84:        if (owner_->GetTimeStamp())
Draw:1392:Direct3D11\D3D11ShaderVariation.cpp:89:    ID3D11Device* device = graphics_->GetImpl()->GetDevice();
Draw:1393:Direct3D11\D3D11ShaderVariation.cpp:93:            device->CreateVertexShader(&byteCode_[0], byteCode_.Size(), 0, (ID3D11VertexShader**)&object_);
Draw:1394:Direct3D11\D3D11ShaderVariation.cpp:100:            device->CreatePixelShader(&byteCode_[0], byteCode_.Size(), 0, (ID3D11PixelShader**)&object_);
Draw:1395:Direct3D11\D3D11ShaderVariation.cpp:115:        graphics_->CleanUpShaderPrograms(this);
Draw:1396:Direct3D11\D3D11ShaderVariation.cpp:119:            if (graphics_->GetVertexShader() == this)
Draw:1397:Direct3D11\D3D11ShaderVariation.cpp:120:                graphics_->SetShaders(0, 0);
Draw:1398:Direct3D11\D3D11ShaderVariation.cpp:122:            ((ID3D11VertexShader*)object_)->Release();
Draw:1399:Direct3D11\D3D11ShaderVariation.cpp:126:            if (graphics_->GetPixelShader() == this)
Draw:1400:Direct3D11\D3D11ShaderVariation.cpp:127:                graphics_->SetShaders(0, 0);
Draw:1401:Direct3D11\D3D11ShaderVariation.cpp:129:            ((ID3D11PixelShader*)object_)->Release();
Draw:1402:Direct3D11\D3D11ShaderVariation.cpp:163:    ResourceCache* cache = owner_->GetSubsystem<ResourceCache>();
Draw:1403:Direct3D11\D3D11ShaderVariation.cpp:164:    if (!cache->Exists(binaryShaderName))
Draw:1404:Direct3D11\D3D11ShaderVariation.cpp:167:    FileSystem* fileSystem = owner_->GetSubsystem<FileSystem>();
Draw:1405:Direct3D11\D3D11ShaderVariation.cpp:168:    unsigned sourceTimeStamp = owner_->GetTimeStamp();
Draw:1406:Direct3D11\D3D11ShaderVariation.cpp:171:    if (sourceTimeStamp && fileSystem->GetLastModifiedTime(cache->GetResourceFileName(binaryShaderName)) <
Draw:1407:Direct3D11\D3D11ShaderVariation.cpp:175:    SharedPtr<File> file = cache->GetFile(binaryShaderName);
Draw:1408:Direct3D11\D3D11ShaderVariation.cpp:176:    if (!file || file->ReadFileID() != "USHD")
Draw:1409:Direct3D11\D3D11ShaderVariation.cpp:183:    unsigned short shaderType = file->ReadUShort();
Draw:1410:Direct3D11\D3D11ShaderVariation.cpp:184:    unsigned short shaderModel = file->ReadUShort();
Draw:1411:Direct3D11\D3D11ShaderVariation.cpp:185:    elementMask_ = file->ReadUInt();
Draw:1412:Direct3D11\D3D11ShaderVariation.cpp:187:    unsigned numParameters = file->ReadUInt();
Draw:1413:Direct3D11\D3D11ShaderVariation.cpp:190:        String name = file->ReadString();
Draw:1414:Direct3D11\D3D11ShaderVariation.cpp:191:        unsigned buffer = file->ReadUByte();
Draw:1415:Direct3D11\D3D11ShaderVariation.cpp:192:        unsigned offset = file->ReadUInt();
Draw:1416:Direct3D11\D3D11ShaderVariation.cpp:193:        unsigned size = file->ReadUInt();
Draw:1417:Direct3D11\D3D11ShaderVariation.cpp:199:    unsigned numTextureUnits = file->ReadUInt();
Draw:1418:Direct3D11\D3D11ShaderVariation.cpp:202:        String unitName = file->ReadString();
Draw:1419:Direct3D11\D3D11ShaderVariation.cpp:203:        unsigned reg = file->ReadUByte();
Draw:1420:Direct3D11\D3D11ShaderVariation.cpp:209:    unsigned byteCodeSize = file->ReadUInt();
Draw:1421:Direct3D11\D3D11ShaderVariation.cpp:213:        file->Read(&byteCode_[0], byteCodeSize);
Draw:1422:Direct3D11\D3D11ShaderVariation.cpp:232:    const String& sourceCode = owner_->GetSourceCode(type_);
Draw:1423:Direct3D11\D3D11ShaderVariation.cpp:296:    if (FAILED(D3DCompile(sourceCode.CString(), sourceCode.Length(), owner_->GetName().CString(), &macros.Front(), 0,
Draw:1424:Direct3D11\D3D11ShaderVariation.cpp:298:        compilerOutput_ = String((const char*)errorMsgs->GetBufferPointer(), errorMsgs->GetBufferSize());
Draw:1425:Direct3D11\D3D11ShaderVariation.cpp:306:        unsigned char* bufData = (unsigned char*)shaderCode->GetBufferPointer();
Draw:1426:Direct3D11\D3D11ShaderVariation.cpp:307:        unsigned bufSize = shaderCode->GetBufferSize();
Draw:1427:Direct3D11\D3D11ShaderVariation.cpp:316:        byteCode_.Resize(strippedCode->GetBufferSize());
Draw:1428:Direct3D11\D3D11ShaderVariation.cpp:317:        memcpy(&byteCode_[0], strippedCode->GetBufferPointer(), byteCode_.Size());
Draw:1429:Direct3D11\D3D11ShaderVariation.cpp:318:        strippedCode->Release();
Draw:1430:Direct3D11\D3D11ShaderVariation.cpp:322:        shaderCode->Release();
Draw:1431:Direct3D11\D3D11ShaderVariation.cpp:324:        errorMsgs->Release();
Draw:1432:Direct3D11\D3D11ShaderVariation.cpp:341:    reflection->GetDesc(&shaderDesc);
Draw:1433:Direct3D11\D3D11ShaderVariation.cpp:348:            reflection->GetInputParameterDesc((unsigned)i, &paramDesc);
Draw:1434:Direct3D11\D3D11ShaderVariation.cpp:366:        reflection->GetResourceBindingDesc(i, &resourceDesc);
Draw:1435:Direct3D11\D3D11ShaderVariation.cpp:376:        ID3D11ShaderReflectionConstantBuffer* cb = reflection->GetConstantBufferByIndex(i);
Draw:1436:Direct3D11\D3D11ShaderVariation.cpp:378:        cb->GetDesc(&cbDesc);
Draw:1437:Direct3D11\D3D11ShaderVariation.cpp:383:            ID3D11ShaderReflectionVariable* var = cb->GetVariableByIndex(j);
Draw:1438:Direct3D11\D3D11ShaderVariation.cpp:385:            var->GetDesc(&varDesc);
Draw:1439:Direct3D11\D3D11ShaderVariation.cpp:395:    reflection->Release();
Draw:1440:Direct3D11\D3D11ShaderVariation.cpp:400:    ResourceCache* cache = owner_->GetSubsystem<ResourceCache>();
Draw:1441:Direct3D11\D3D11ShaderVariation.cpp:401:    FileSystem* fileSystem = owner_->GetSubsystem<FileSystem>();
Draw:1442:Direct3D11\D3D11ShaderVariation.cpp:403:    String path = GetPath(cache->GetResourceFileName(owner_->GetName())) + "Cache/";
Draw:1443:Direct3D11\D3D11ShaderVariation.cpp:405:    if (!fileSystem->DirExists(path))
Draw:1444:Direct3D11\D3D11ShaderVariation.cpp:406:        fileSystem->CreateDir(path);
Draw:1445:Direct3D11\D3D11ShaderVariation.cpp:408:    SharedPtr<File> file(new File(owner_->GetContext(), fullName, FILE_WRITE));
Draw:1446:Direct3D11\D3D11ShaderVariation.cpp:409:    if (!file->IsOpen())
Draw:1447:Direct3D11\D3D11ShaderVariation.cpp:412:    file->WriteFileID("USHD");
Draw:1448:Direct3D11\D3D11ShaderVariation.cpp:413:    file->WriteShort((unsigned short)type_);
Draw:1449:Direct3D11\D3D11ShaderVariation.cpp:414:    file->WriteShort(4);
Draw:1450:Direct3D11\D3D11ShaderVariation.cpp:415:    file->WriteUInt(elementMask_);
Draw:1451:Direct3D11\D3D11ShaderVariation.cpp:417:    file->WriteUInt(parameters_.Size());
Draw:1452:Direct3D11\D3D11ShaderVariation.cpp:420:        file->WriteString(i->second_.name_);
Draw:1453:Direct3D11\D3D11ShaderVariation.cpp:421:        file->WriteUByte((unsigned char)i->second_.buffer_);
Draw:1454:Direct3D11\D3D11ShaderVariation.cpp:422:        file->WriteUInt(i->second_.offset_);
Draw:1455:Direct3D11\D3D11ShaderVariation.cpp:423:        file->WriteUInt(i->second_.size_);
Draw:1456:Direct3D11\D3D11ShaderVariation.cpp:432:    file->WriteUInt(usedTextureUnits);
Draw:1457:Direct3D11\D3D11ShaderVariation.cpp:437:            file->WriteString(graphics_->GetTextureUnitName((TextureUnit)i));
Draw:1458:Direct3D11\D3D11ShaderVariation.cpp:438:            file->WriteUByte(i);
Draw:1459:Direct3D11\D3D11ShaderVariation.cpp:442:    file->WriteUInt(byteCode_.Size());
Draw:1460:Direct3D11\D3D11ShaderVariation.cpp:444:        file->Write(&byteCode_[0], byteCode_.Size());
Draw:1461:Direct3D11\D3D11ShaderVariation.cpp:454:        if (i->second_.buffer_ < MAX_SHADER_PARAMETER_GROUPS)
Draw:1462:Direct3D11\D3D11ShaderVariation.cpp:456:            unsigned oldSize = constantBufferSizes_[i->second_.buffer_];
Draw:1463:Direct3D11\D3D11ShaderVariation.cpp:457:            unsigned paramEnd = i->second_.offset_ + i->second_.size_;
Draw:1464:Direct3D11\D3D11ShaderVariation.cpp:459:                constantBufferSizes_[i->second_.buffer_] = paramEnd;
Draw:1465:Direct3D11\D3D11RenderSurface.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1466:Direct3D11\D3D11RenderSurface.cpp:86:        // Verify that there is at least 1 non-null viewport, as otherwise Renderer will not accept the surface and the update flag
Draw:1467:Direct3D11\D3D11RenderSurface.cpp:99:            Renderer* renderer = parentTexture_->GetSubsystem<Renderer>();
Draw:1468:Direct3D11\D3D11RenderSurface.cpp:101:                renderer->QueueRenderSurface(this);
Draw:1469:Direct3D11\D3D11RenderSurface.cpp:110:    Graphics* graphics = parentTexture_->GetGraphics();
Draw:1470:Direct3D11\D3D11RenderSurface.cpp:118:            if (graphics->GetRenderTarget(i) == this)
Draw:1471:Direct3D11\D3D11RenderSurface.cpp:119:                graphics->ResetRenderTarget(i);
Draw:1472:Direct3D11\D3D11RenderSurface.cpp:122:        if (graphics->GetDepthStencil() == this)
Draw:1473:Direct3D11\D3D11RenderSurface.cpp:123:            graphics->ResetDepthStencil();
Draw:1474:Direct3D11\D3D11RenderSurface.cpp:125:        ((ID3D11View*)renderTargetView_)->Release();
Draw:1475:Direct3D11\D3D11RenderSurface.cpp:132:    return parentTexture_->GetWidth();
Draw:1476:Direct3D11\D3D11RenderSurface.cpp:137:    return parentTexture_->GetHeight();
Draw:1477:Direct3D11\D3D11RenderSurface.cpp:142:    return parentTexture_->GetUsage();
Draw:1478:Direct3D11\D3D11Texture.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1479:Direct3D11\D3D11Texture.h:127:    /// Return the depth-stencil view format corresponding to a texture format. Handles conversion of typeless depth texture formats.
Draw:1480:Direct3D11\D3D11Texture2D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1481:Direct3D11\D3D11Texture2D.h:59:    /// Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.
Draw:1482:Direct3D11\D3D11Texture2D.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1483:Direct3D11\D3D11Texture2D.cpp:52:    context->RegisterFactory<Texture2D>();
Draw:1484:Direct3D11\D3D11Texture2D.cpp:63:    if (!loadImage_->Load(source))
Draw:1485:Direct3D11\D3D11Texture2D.cpp:71:        loadImage_->PrecalculateLevels();
Draw:1486:Direct3D11\D3D11Texture2D.cpp:76:    loadParameters_ = cache->GetTempResource<XMLFile>(xmlName, false);
Draw:1487:Direct3D11\D3D11Texture2D.cpp:108:            if (graphics_->GetTexture(i) == this)
Draw:1488:Direct3D11\D3D11Texture2D.cpp:109:                graphics_->SetTexture(i, 0);
Draw:1489:Direct3D11\D3D11Texture2D.cpp:113:            renderSurface_->Release();
Draw:1490:Direct3D11\D3D11Texture2D.cpp:115:        ((ID3D11Resource*)object_)->Release();
Draw:1491:Direct3D11\D3D11Texture2D.cpp:120:            ((ID3D11ShaderResourceView*)shaderResourceView_)->Release();
Draw:1492:Direct3D11\D3D11Texture2D.cpp:126:            ((ID3D11SamplerState*)sampler_)->Release();
Draw:1493:Direct3D11\D3D11Texture2D.cpp:133:            renderSurface_->Release();
Draw:1494:Direct3D11\D3D11Texture2D.cpp:222:        graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)object_, subResource, D3D11_MAP_WRITE_DISCARD, 0,
Draw:1495:Direct3D11\D3D11Texture2D.cpp:228:            graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)object_, subResource);
Draw:1496:Direct3D11\D3D11Texture2D.cpp:246:        graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Resource*)object_, subResource, &destBox, data,
Draw:1497:Direct3D11\D3D11Texture2D.cpp:266:        quality = renderer->GetTextureQuality();
Draw:1498:Direct3D11\D3D11Texture2D.cpp:268:    if (!image->IsCompressed())
Draw:1499:Direct3D11\D3D11Texture2D.cpp:271:        unsigned components = image->GetComponents();
Draw:1500:Direct3D11\D3D11Texture2D.cpp:274:            image = image->ConvertToRGBA();
Draw:1501:Direct3D11\D3D11Texture2D.cpp:277:            components = image->GetComponents();
Draw:1502:Direct3D11\D3D11Texture2D.cpp:280:        unsigned char* levelData = image->GetData();
Draw:1503:Direct3D11\D3D11Texture2D.cpp:281:        int levelWidth = image->GetWidth();
Draw:1504:Direct3D11\D3D11Texture2D.cpp:282:        int levelHeight = image->GetHeight();
Draw:1505:Direct3D11\D3D11Texture2D.cpp:288:            image = image->GetNextLevel();
Draw:1506:Direct3D11\D3D11Texture2D.cpp:289:            levelData = image->GetData();
Draw:1507:Direct3D11\D3D11Texture2D.cpp:290:            levelWidth = image->GetWidth();
Draw:1508:Direct3D11\D3D11Texture2D.cpp:291:            levelHeight = image->GetHeight();
Draw:1509:Direct3D11\D3D11Texture2D.cpp:315:            if (i < levels_ - 1)
Draw:1510:Direct3D11\D3D11Texture2D.cpp:317:                image = image->GetNextLevel();
Draw:1511:Direct3D11\D3D11Texture2D.cpp:318:                levelData = image->GetData();
Draw:1512:Direct3D11\D3D11Texture2D.cpp:319:                levelWidth = image->GetWidth();
Draw:1513:Direct3D11\D3D11Texture2D.cpp:320:                levelHeight = image->GetHeight();
Draw:1514:Direct3D11\D3D11Texture2D.cpp:326:        int width = image->GetWidth();
Draw:1515:Direct3D11\D3D11Texture2D.cpp:327:        int height = image->GetHeight();
Draw:1516:Direct3D11\D3D11Texture2D.cpp:328:        unsigned levels = image->GetNumCompressedLevels();
Draw:1517:Direct3D11\D3D11Texture2D.cpp:329:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Draw:1518:Direct3D11\D3D11Texture2D.cpp:340:            mipsToSkip = levels - 1;
Draw:1519:Direct3D11\D3D11Texture2D.cpp:342:            --mipsToSkip;
Draw:1520:Direct3D11\D3D11Texture2D.cpp:346:        SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Draw:1521:Direct3D11\D3D11Texture2D.cpp:349:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Draw:1522:Direct3D11\D3D11Texture2D.cpp:351:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Draw:1523:Direct3D11\D3D11Texture2D.cpp:408:    graphics_->GetImpl()->GetDevice()->CreateTexture2D(&textureDesc, 0, &stagingTexture);
Draw:1524:Direct3D11\D3D11Texture2D.cpp:423:    graphics_->GetImpl()->GetDeviceContext()->CopySubresourceRegion(stagingTexture, 0, 0, 0, 0, (ID3D11Resource*)object_,
Draw:1525:Direct3D11\D3D11Texture2D.cpp:431:    graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)stagingTexture, 0, D3D11_MAP_READ, 0, &mappedData);
Draw:1526:Direct3D11\D3D11Texture2D.cpp:436:        graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)stagingTexture, 0);
Draw:1527:Direct3D11\D3D11Texture2D.cpp:437:        stagingTexture->Release();
Draw:1528:Direct3D11\D3D11Texture2D.cpp:443:        stagingTexture->Release();
Draw:1529:Direct3D11\D3D11Texture2D.cpp:474:    graphics_->GetImpl()->GetDevice()->CreateTexture2D(&textureDesc, 0, (ID3D11Texture2D**)&object_);
Draw:1530:Direct3D11\D3D11Texture2D.cpp:487:    graphics_->GetImpl()->GetDevice()->CreateShaderResourceView((ID3D11Resource*)object_, &resourceViewDesc,
Draw:1531:Direct3D11\D3D11Texture2D.cpp:504:        graphics_->GetImpl()->GetDevice()->CreateRenderTargetView((ID3D11Resource*)object_, &renderTargetViewDesc,
Draw:1532:Direct3D11\D3D11Texture2D.cpp:505:            (ID3D11RenderTargetView**)&renderSurface_->renderTargetView_);
Draw:1533:Direct3D11\D3D11Texture2D.cpp:507:        if (!renderSurface_->renderTargetView_)
Draw:1534:Direct3D11\D3D11Texture2D.cpp:522:        graphics_->GetImpl()->GetDevice()->CreateDepthStencilView((ID3D11Resource*)object_, &depthStencilViewDesc,
Draw:1535:Direct3D11\D3D11Texture2D.cpp:523:            (ID3D11DepthStencilView**)&renderSurface_->renderTargetView_);
Draw:1536:Direct3D11\D3D11Texture2D.cpp:525:        if (!renderSurface_->renderTargetView_)
Draw:1537:Direct3D11\D3D11Texture2D.cpp:527:            LOGERROR("Failed to create depth-stencil view for texture");
Draw:1538:Direct3D11\D3D11Texture2D.cpp:537:    if (renderSurface_ && renderSurface_->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Draw:1539:Direct3D11\D3D11Texture2D.cpp:538:        renderSurface_->QueueUpdate();
Draw:1540:Direct3D11\D3D11Texture3D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1541:Direct3D11\D3D11Texture3D.h:58:    /// Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.
Draw:1542:Direct3D11\D3D11Texture3D.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1543:Direct3D11\D3D11Texture3D.cpp:52:    context->RegisterFactory<Texture3D>();
Draw:1544:Direct3D11\D3D11Texture3D.cpp:66:    cache->ResetDependencies(this);
Draw:1545:Direct3D11\D3D11Texture3D.cpp:69:    if (!loadParameters_->Load(source))
Draw:1546:Direct3D11\D3D11Texture3D.cpp:75:    XMLElement textureElem = loadParameters_->GetRoot();
Draw:1547:Direct3D11\D3D11Texture3D.cpp:89:        loadImage_ = cache->GetTempResource<Image>(name);
Draw:1548:Direct3D11\D3D11Texture3D.cpp:92:            loadImage_->PrecalculateLevels();
Draw:1549:Direct3D11\D3D11Texture3D.cpp:93:        cache->StoreResourceDependency(this, name);
Draw:1550:Direct3D11\D3D11Texture3D.cpp:106:        SharedPtr<File> file = GetSubsystem<ResourceCache>()->GetFile(name);
Draw:1551:Direct3D11\D3D11Texture3D.cpp:108:        if (!loadImage_->LoadColorLUT(*(file.Get())))
Draw:1552:Direct3D11\D3D11Texture3D.cpp:116:            loadImage_->PrecalculateLevels();
Draw:1553:Direct3D11\D3D11Texture3D.cpp:117:        cache->StoreResourceDependency(this, name);
Draw:1554:Direct3D11\D3D11Texture3D.cpp:152:            if (graphics_->GetTexture(i) == this)
Draw:1555:Direct3D11\D3D11Texture3D.cpp:153:                graphics_->SetTexture(i, 0);
Draw:1556:Direct3D11\D3D11Texture3D.cpp:157:            renderSurface_->Release();
Draw:1557:Direct3D11\D3D11Texture3D.cpp:159:        ((ID3D11Resource*)object_)->Release();
Draw:1558:Direct3D11\D3D11Texture3D.cpp:164:            ((ID3D11ShaderResourceView*)shaderResourceView_)->Release();
Draw:1559:Direct3D11\D3D11Texture3D.cpp:170:            ((ID3D11SamplerState*)sampler_)->Release();
Draw:1560:Direct3D11\D3D11Texture3D.cpp:177:            renderSurface_->Release();
Draw:1561:Direct3D11\D3D11Texture3D.cpp:269:        graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)object_, subResource, D3D11_MAP_WRITE_DISCARD, 0,
Draw:1562:Direct3D11\D3D11Texture3D.cpp:282:            graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)object_, subResource);
Draw:1563:Direct3D11\D3D11Texture3D.cpp:303:        graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Resource*)object_, subResource, &destBox, data,
Draw:1564:Direct3D11\D3D11Texture3D.cpp:323:        quality = renderer->GetTextureQuality();
Draw:1565:Direct3D11\D3D11Texture3D.cpp:325:    if (!image->IsCompressed())
Draw:1566:Direct3D11\D3D11Texture3D.cpp:328:        unsigned components = image->GetComponents();
Draw:1567:Direct3D11\D3D11Texture3D.cpp:331:            image = image->ConvertToRGBA();
Draw:1568:Direct3D11\D3D11Texture3D.cpp:334:            components = image->GetComponents();
Draw:1569:Direct3D11\D3D11Texture3D.cpp:337:        unsigned char* levelData = image->GetData();
Draw:1570:Direct3D11\D3D11Texture3D.cpp:338:        int levelWidth = image->GetWidth();
Draw:1571:Direct3D11\D3D11Texture3D.cpp:339:        int levelHeight = image->GetHeight();
Draw:1572:Direct3D11\D3D11Texture3D.cpp:340:        int levelDepth = image->GetDepth();
Draw:1573:Direct3D11\D3D11Texture3D.cpp:346:            image = image->GetNextLevel();
Draw:1574:Direct3D11\D3D11Texture3D.cpp:347:            levelData = image->GetData();
Draw:1575:Direct3D11\D3D11Texture3D.cpp:348:            levelWidth = image->GetWidth();
Draw:1576:Direct3D11\D3D11Texture3D.cpp:349:            levelHeight = image->GetHeight();
Draw:1577:Direct3D11\D3D11Texture3D.cpp:350:            levelDepth = image->GetDepth();
Draw:1578:Direct3D11\D3D11Texture3D.cpp:374:            if (i < levels_ - 1)
Draw:1579:Direct3D11\D3D11Texture3D.cpp:376:                image = image->GetNextLevel();
Draw:1580:Direct3D11\D3D11Texture3D.cpp:377:                levelData = image->GetData();
Draw:1581:Direct3D11\D3D11Texture3D.cpp:378:                levelWidth = image->GetWidth();
Draw:1582:Direct3D11\D3D11Texture3D.cpp:379:                levelHeight = image->GetHeight();
Draw:1583:Direct3D11\D3D11Texture3D.cpp:380:                levelDepth = image->GetDepth();
Draw:1584:Direct3D11\D3D11Texture3D.cpp:386:        int width = image->GetWidth();
Draw:1585:Direct3D11\D3D11Texture3D.cpp:387:        int height = image->GetHeight();
Draw:1586:Direct3D11\D3D11Texture3D.cpp:388:        int depth = image->GetDepth();
Draw:1587:Direct3D11\D3D11Texture3D.cpp:389:        unsigned levels = image->GetNumCompressedLevels();
Draw:1588:Direct3D11\D3D11Texture3D.cpp:390:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Draw:1589:Direct3D11\D3D11Texture3D.cpp:401:            mipsToSkip = levels - 1;
Draw:1590:Direct3D11\D3D11Texture3D.cpp:403:            --mipsToSkip;
Draw:1591:Direct3D11\D3D11Texture3D.cpp:408:        SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Draw:1592:Direct3D11\D3D11Texture3D.cpp:411:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Draw:1593:Direct3D11\D3D11Texture3D.cpp:413:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Draw:1594:Direct3D11\D3D11Texture3D.cpp:469:    graphics_->GetImpl()->GetDevice()->CreateTexture3D(&textureDesc, 0, &stagingTexture);
Draw:1595:Direct3D11\D3D11Texture3D.cpp:484:    graphics_->GetImpl()->GetDeviceContext()->CopySubresourceRegion(stagingTexture, 0, 0, 0, 0, (ID3D11Resource*)object_,
Draw:1596:Direct3D11\D3D11Texture3D.cpp:492:    graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)stagingTexture, 0, D3D11_MAP_READ, 0, &mappedData);
Draw:1597:Direct3D11\D3D11Texture3D.cpp:503:        graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)stagingTexture, 0);
Draw:1598:Direct3D11\D3D11Texture3D.cpp:504:        stagingTexture->Release();
Draw:1599:Direct3D11\D3D11Texture3D.cpp:510:        stagingTexture->Release();
Draw:1600:Direct3D11\D3D11Texture3D.cpp:535:    graphics_->GetImpl()->GetDevice()->CreateTexture3D(&textureDesc, 0, (ID3D11Texture3D**)&object_);
Draw:1601:Direct3D11\D3D11Texture3D.cpp:548:    graphics_->GetImpl()->GetDevice()->CreateShaderResourceView((ID3D11Resource*)object_, &resourceViewDesc,
Draw:1602:Direct3D11\D3D11Texture3D.cpp:561:    if (renderSurface_ && renderSurface_->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Draw:1603:Direct3D11\D3D11Texture3D.cpp:562:        renderSurface_->QueueUpdate();
Draw:1604:Direct3D11\D3D11TextureCube.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1605:Direct3D11\D3D11TextureCube.h:61:    /// Set data of one face from an image. Return true if successful. Optionally make a single channel image alpha-only.
Draw:1606:Direct3D11\D3D11TextureCube.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1607:Direct3D11\D3D11TextureCube.cpp:55:    return SharedPtr<Image>(src->GetSubimage(IntRect(tileX * tileWidth, tileY * tileHeight, (tileX + 1) * tileWidth, (tileY + 1) * tileHeight)));
Draw:1608:Direct3D11\D3D11TextureCube.cpp:60:    lockedLevel_(-1)
Draw:1609:Direct3D11\D3D11TextureCube.cpp:78:    context->RegisterFactory<TextureCube>();
Draw:1610:Direct3D11\D3D11TextureCube.cpp:89:    cache->ResetDependencies(this);
Draw:1611:Direct3D11\D3D11TextureCube.cpp:95:    if (!loadParameters_->Load(source))
Draw:1612:Direct3D11\D3D11TextureCube.cpp:103:    XMLElement textureElem = loadParameters_->GetRoot();
Draw:1613:Direct3D11\D3D11TextureCube.cpp:114:        SharedPtr<Image> image = cache->GetTempResource<Image>(name);
Draw:1614:Direct3D11\D3D11TextureCube.cpp:124:            faceWidth = image->GetWidth() / MAX_CUBEMAP_FACES;
Draw:1615:Direct3D11\D3D11TextureCube.cpp:125:            faceHeight = image->GetHeight();
Draw:1616:Direct3D11\D3D11TextureCube.cpp:135:            faceWidth = image->GetWidth() / MAX_CUBEMAP_FACES;
Draw:1617:Direct3D11\D3D11TextureCube.cpp:136:            faceHeight = image->GetHeight();
Draw:1618:Direct3D11\D3D11TextureCube.cpp:142:            faceWidth = image->GetWidth() / 4;
Draw:1619:Direct3D11\D3D11TextureCube.cpp:143:            faceHeight = image->GetHeight() / 3;
Draw:1620:Direct3D11\D3D11TextureCube.cpp:153:            faceWidth = image->GetWidth() / 3;
Draw:1621:Direct3D11\D3D11TextureCube.cpp:154:            faceHeight = image->GetHeight() / 4;
Draw:1622:Direct3D11\D3D11TextureCube.cpp:163:                loadImages_[FACE_NEGATIVE_Z]->FlipVertical();
Draw:1623:Direct3D11\D3D11TextureCube.cpp:164:                loadImages_[FACE_NEGATIVE_Z]->FlipHorizontal();
Draw:1624:Direct3D11\D3D11TextureCube.cpp:169:            faceWidth = image->GetWidth() / 3;
Draw:1625:Direct3D11\D3D11TextureCube.cpp:170:            faceHeight = image->GetHeight() / 2;
Draw:1626:Direct3D11\D3D11TextureCube.cpp:192:            loadImages_.Push(cache->GetTempResource<Image>(name));
Draw:1627:Direct3D11\D3D11TextureCube.cpp:193:            cache->StoreResourceDependency(this, name);
Draw:1628:Direct3D11\D3D11TextureCube.cpp:205:                loadImages_[i]->PrecalculateLevels();
Draw:1629:Direct3D11\D3D11TextureCube.cpp:241:            if (graphics_->GetTexture(i) == this)
Draw:1630:Direct3D11\D3D11TextureCube.cpp:242:                graphics_->SetTexture(i, 0);
Draw:1631:Direct3D11\D3D11TextureCube.cpp:248:                renderSurfaces_[i]->Release();
Draw:1632:Direct3D11\D3D11TextureCube.cpp:251:        ((ID3D11Resource*)object_)->Release();
Draw:1633:Direct3D11\D3D11TextureCube.cpp:256:            ((ID3D11ShaderResourceView*)shaderResourceView_)->Release();
Draw:1634:Direct3D11\D3D11TextureCube.cpp:262:            ((ID3D11SamplerState*)sampler_)->Release();
Draw:1635:Direct3D11\D3D11TextureCube.cpp:277:        LOGERROR("Depth-stencil usage not supported for cube maps");
Draw:1636:Direct3D11\D3D11TextureCube.cpp:368:        graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)object_, subResource, D3D11_MAP_WRITE_DISCARD, 0,
Draw:1637:Direct3D11\D3D11TextureCube.cpp:374:            graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)object_, subResource);
Draw:1638:Direct3D11\D3D11TextureCube.cpp:392:        graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Resource*)object_, subResource, &destBox, data,
Draw:1639:Direct3D11\D3D11TextureCube.cpp:402:    if (!image->Load(source))
Draw:1640:Direct3D11\D3D11TextureCube.cpp:421:        quality = renderer->GetTextureQuality();
Draw:1641:Direct3D11\D3D11TextureCube.cpp:423:    if (!image->IsCompressed())
Draw:1642:Direct3D11\D3D11TextureCube.cpp:426:        unsigned components = image->GetComponents();
Draw:1643:Direct3D11\D3D11TextureCube.cpp:429:            image = image->ConvertToRGBA();
Draw:1644:Direct3D11\D3D11TextureCube.cpp:432:            components = image->GetComponents();
Draw:1645:Direct3D11\D3D11TextureCube.cpp:435:        unsigned char* levelData = image->GetData();
Draw:1646:Direct3D11\D3D11TextureCube.cpp:436:        int levelWidth = image->GetWidth();
Draw:1647:Direct3D11\D3D11TextureCube.cpp:437:        int levelHeight = image->GetHeight();
Draw:1648:Direct3D11\D3D11TextureCube.cpp:449:            image = image->GetNextLevel();
Draw:1649:Direct3D11\D3D11TextureCube.cpp:450:            levelData = image->GetData();
Draw:1650:Direct3D11\D3D11TextureCube.cpp:451:            levelWidth = image->GetWidth();
Draw:1651:Direct3D11\D3D11TextureCube.cpp:452:            levelHeight = image->GetHeight();
Draw:1652:Direct3D11\D3D11TextureCube.cpp:493:            if (i < levels_ - 1)
Draw:1653:Direct3D11\D3D11TextureCube.cpp:495:                image = image->GetNextLevel();
Draw:1654:Direct3D11\D3D11TextureCube.cpp:496:                levelData = image->GetData();
Draw:1655:Direct3D11\D3D11TextureCube.cpp:497:                levelWidth = image->GetWidth();
Draw:1656:Direct3D11\D3D11TextureCube.cpp:498:                levelHeight = image->GetHeight();
Draw:1657:Direct3D11\D3D11TextureCube.cpp:504:        int width = image->GetWidth();
Draw:1658:Direct3D11\D3D11TextureCube.cpp:505:        int height = image->GetHeight();
Draw:1659:Direct3D11\D3D11TextureCube.cpp:506:        unsigned levels = image->GetNumCompressedLevels();
Draw:1660:Direct3D11\D3D11TextureCube.cpp:507:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Draw:1661:Direct3D11\D3D11TextureCube.cpp:524:            mipsToSkip = levels - 1;
Draw:1662:Direct3D11\D3D11TextureCube.cpp:526:            --mipsToSkip;
Draw:1663:Direct3D11\D3D11TextureCube.cpp:533:            SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Draw:1664:Direct3D11\D3D11TextureCube.cpp:550:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Draw:1665:Direct3D11\D3D11TextureCube.cpp:552:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Draw:1666:Direct3D11\D3D11TextureCube.cpp:614:    graphics_->GetImpl()->GetDevice()->CreateTexture2D(&textureDesc, 0, &stagingTexture);
Draw:1667:Direct3D11\D3D11TextureCube.cpp:629:    graphics_->GetImpl()->GetDeviceContext()->CopySubresourceRegion(stagingTexture, 0, 0, 0, 0, (ID3D11Resource*)object_,
Draw:1668:Direct3D11\D3D11TextureCube.cpp:637:    graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Resource*)stagingTexture, 0, D3D11_MAP_READ, 0, &mappedData);
Draw:1669:Direct3D11\D3D11TextureCube.cpp:642:        graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Resource*)stagingTexture, 0);
Draw:1670:Direct3D11\D3D11TextureCube.cpp:643:        stagingTexture->Release();
Draw:1671:Direct3D11\D3D11TextureCube.cpp:649:        stagingTexture->Release();
Draw:1672:Direct3D11\D3D11TextureCube.cpp:681:    graphics_->GetImpl()->GetDevice()->CreateTexture2D(&textureDesc, 0, (ID3D11Texture2D**)&object_);
Draw:1673:Direct3D11\D3D11TextureCube.cpp:694:    graphics_->GetImpl()->GetDevice()->CreateShaderResourceView((ID3D11Resource*)object_, &resourceViewDesc,
Draw:1674:Direct3D11\D3D11TextureCube.cpp:716:            graphics_->GetImpl()->GetDevice()->CreateRenderTargetView((ID3D11Resource*)object_, &renderTargetViewDesc,
Draw:1675:Direct3D11\D3D11TextureCube.cpp:717:                (ID3D11RenderTargetView**)&renderSurfaces_[i]->renderTargetView_);
Draw:1676:Direct3D11\D3D11TextureCube.cpp:719:            if (!renderSurfaces_[i]->renderTargetView_)
Draw:1677:Direct3D11\D3D11TextureCube.cpp:734:        if (renderSurfaces_[i] && renderSurfaces_[i]->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Draw:1678:Direct3D11\D3D11TextureCube.cpp:735:            renderSurfaces_[i]->QueueUpdate();
Draw:1679:Direct3D11\D3D11VertexBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1680:Direct3D11\D3D11VertexBuffer.cpp:136:            if (graphics_->GetVertexBuffer(i) == this)
Draw:1681:Direct3D11\D3D11VertexBuffer.cpp:137:                graphics_->SetVertexBuffer(0);
Draw:1682:Direct3D11\D3D11VertexBuffer.cpp:140:        ((ID3D11Buffer*)object_)->Release();
Draw:1683:Direct3D11\D3D11VertexBuffer.cpp:220:            graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Buffer*)object_, 0, &destBox, data, 0, 0);
Draw:1684:Direct3D11\D3D11VertexBuffer.cpp:279:            graphics_->GetImpl()->GetDeviceContext()->UpdateSubresource((ID3D11Buffer*)object_, 0, &destBox, data, 0, 0);
Draw:1685:Direct3D11\D3D11VertexBuffer.cpp:323:        lockScratchData_ = graphics_->ReserveScratchBuffer(count * vertexSize_);
Draw:1686:Direct3D11\D3D11VertexBuffer.cpp:346:            graphics_->FreeScratchBuffer(lockScratchData_);
Draw:1687:Direct3D11\D3D11VertexBuffer.cpp:429:        graphics_->GetImpl()->GetDevice()->CreateBuffer(&bufferDesc, 0, (ID3D11Buffer**)&object_);
Draw:1688:Direct3D11\D3D11VertexBuffer.cpp:458:        graphics_->GetImpl()->GetDeviceContext()->Map((ID3D11Buffer*)object_, 0, discard ? D3D11_MAP_WRITE_DISCARD :
Draw:1689:Direct3D11\D3D11VertexBuffer.cpp:474:        graphics_->GetImpl()->GetDeviceContext()->Unmap((ID3D11Buffer*)object_, 0);
Draw:1690:Direct3D11\D3D11VertexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1691:Direct3D11\D3D11VertexBuffer.h:54:    /// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
Draw:1692:Direct3D11\D3D11VertexDeclaration.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1693:Direct3D11\D3D11VertexDeclaration.cpp:55:                    newDesc.AlignedByteOffset = vertexBuffers[i]->GetElementOffset((VertexElement)j);
Draw:1694:Direct3D11\D3D11VertexDeclaration.cpp:70:    const PODVector<unsigned char>& byteCode = vertexShader->GetByteCode();
Draw:1695:Direct3D11\D3D11VertexDeclaration.cpp:72:    graphics->GetImpl()->GetDevice()->CreateInputLayout(&elementDescs[0], (unsigned)elementDescs.Size(), &byteCode[0],
Draw:1696:Direct3D11\D3D11VertexDeclaration.cpp:78:            vertexShader->GetFullName().CString(), vertexShader->GetElementMask() & ~vbElementMask);
Draw:1697:Direct3D11\D3D11VertexDeclaration.cpp:85:        ((ID3D11InputLayout*)inputLayout_)->Release();
Draw:1698:Direct3D11\D3D11VertexDeclaration.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1699:Direct3D9\D3D9GPUObject.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1700:Direct3D9\D3D9GPUObject.cpp:39:        graphics->AddGPUObject(this);
Draw:1701:Direct3D9\D3D9GPUObject.cpp:45:        graphics_->RemoveGPUObject(this);
Draw:1702:Direct3D9\D3D9GPUObject.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1703:Direct3D9\D3D9Graphics.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1704:Direct3D9\D3D9Graphics.h:60:/// CPU-side scratch buffer for vertex data updates.
Draw:1705:Direct3D9\D3D9Graphics.h:106:    /// Set allowed screen orientations as a space-separated list of "LandscapeLeft", "LandscapeRight", "Portrait" and "PortraitUpsideDown". Affects currently only iOS platform.
Draw:1706:Direct3D9\D3D9Graphics.h:122:    /// Draw non-indexed geometry.
Draw:1707:Direct3D9\D3D9Graphics.h:178:    /// Reset all rendertargets, depth-stencil surface and viewport.
Draw:1708:Direct3D9\D3D9Graphics.h:182:    /// Reset depth-stencil surface.
Draw:1709:Direct3D9\D3D9Graphics.h:188:    /// Set depth-stencil surface.
Draw:1710:Direct3D9\D3D9Graphics.h:190:    /// Set depth-stencil surface.
Draw:1711:Direct3D9\D3D9Graphics.h:225:    /// Return graphics implementation, which holds the actual API-specific resources.
Draw:1712:Direct3D9\D3D9Graphics.h:227:    /// Return OS-specific external window handle. Null if not in use.
Draw:1713:Direct3D9\D3D9Graphics.h:267:    /// Return 24-bit shadow map depth texture format, or 0 if not supported.
Draw:1714:Direct3D9\D3D9Graphics.h:271:    /// Return whether light pre-pass rendering is supported.
Draw:1715:Direct3D9\D3D9Graphics.h:313:    /// Return current depth-stencil surface.
Draw:1716:Direct3D9\D3D9Graphics.h:372:    /// Reserve a CPU-side scratch buffer.
Draw:1717:Direct3D9\D3D9Graphics.h:374:    /// Free a CPU-side scratch buffer.
Draw:1718:Direct3D9\D3D9Graphics.h:381:    /// Return the API-specific alpha texture format.
Draw:1719:Direct3D9\D3D9Graphics.h:383:    /// Return the API-specific luminance texture format.
Draw:1720:Direct3D9\D3D9Graphics.h:385:    /// Return the API-specific luminance alpha texture format.
Draw:1721:Direct3D9\D3D9Graphics.h:387:    /// Return the API-specific RGB texture format.
Draw:1722:Direct3D9\D3D9Graphics.h:389:    /// Return the API-specific RGBA texture format.
Draw:1723:Direct3D9\D3D9Graphics.h:391:    /// Return the API-specific RGBA 16-bit texture format.
Draw:1724:Direct3D9\D3D9Graphics.h:393:    /// Return the API-specific RGBA 16-bit float texture format.
Draw:1725:Direct3D9\D3D9Graphics.h:395:    /// Return the API-specific RGBA 32-bit float texture format.
Draw:1726:Direct3D9\D3D9Graphics.h:397:    /// Return the API-specific RG 16-bit texture format.
Draw:1727:Direct3D9\D3D9Graphics.h:399:    /// Return the API-specific RG 16-bit float texture format.
Draw:1728:Direct3D9\D3D9Graphics.h:401:    /// Return the API-specific RG 32-bit float texture format.
Draw:1729:Direct3D9\D3D9Graphics.h:403:    /// Return the API-specific single channel 16-bit float texture format.
Draw:1730:Direct3D9\D3D9Graphics.h:405:    /// Return the API-specific single channel 32-bit float texture format.
Draw:1731:Direct3D9\D3D9Graphics.h:407:    /// Return the API-specific linear depth texture format.
Draw:1732:Direct3D9\D3D9Graphics.h:409:    /// Return the API-specific hardware depth-stencil texture format.
Draw:1733:Direct3D9\D3D9Graphics.h:411:    /// Return the API-specific readable hardware depth format, or 0 if not supported.
Draw:1734:Direct3D9\D3D9Graphics.h:413:    /// Return the API-specific texture format from a textual description, for example "rgb".
Draw:1735:Direct3D9\D3D9Graphics.h:484:    /// Light pre-pass rendering support flag.
Draw:1736:Direct3D9\D3D9Graphics.h:512:    /// Shadow map 24-bit depth texture format.
Draw:1737:Direct3D9\D3D9Graphics.h:534:    /// Depth-stencil surface in use.
Draw:1738:Direct3D9\D3D9GraphicsImpl.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1739:Direct3D9\D3D9GraphicsImpl.h:33:/// %Graphics implementation. Holds API-specific objects.
Draw:1740:Direct3D9\D3D9GraphicsImpl.h:62:    /// Default depth-stencil surface.
Draw:1741:Direct3D9\D3D9GraphicsImpl.h:94:    /// Depth-stencil surface in use.
Draw:1742:Direct3D9\D3D9GraphicsImpl.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1743:Direct3D9\D3D9GraphicsImpl.cpp:50:    if (SUCCEEDED(interface_->CheckDeviceFormat(
Draw:1744:Direct3D9\D3D9IndexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1745:Direct3D9\D3D9IndexBuffer.h:59:    /// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
Draw:1746:Direct3D9\D3D9RenderSurface.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1747:Direct3D9\D3D9RenderSurface.cpp:86:        // Verify that there is at least 1 non-null viewport, as otherwise Renderer will not accept the surface and the update flag
Draw:1748:Direct3D9\D3D9RenderSurface.cpp:99:            Renderer* renderer = parentTexture_->GetSubsystem<Renderer>();
Draw:1749:Direct3D9\D3D9RenderSurface.cpp:101:                renderer->QueueRenderSurface(this);
Draw:1750:Direct3D9\D3D9RenderSurface.cpp:110:    Graphics* graphics = parentTexture_->GetGraphics();
Draw:1751:Direct3D9\D3D9RenderSurface.cpp:118:            if (graphics->GetRenderTarget(i) == this)
Draw:1752:Direct3D9\D3D9RenderSurface.cpp:119:                graphics->ResetRenderTarget(i);
Draw:1753:Direct3D9\D3D9RenderSurface.cpp:122:        if (graphics->GetDepthStencil() == this)
Draw:1754:Direct3D9\D3D9RenderSurface.cpp:123:            graphics->ResetDepthStencil();
Draw:1755:Direct3D9\D3D9RenderSurface.cpp:125:        ((IDirect3DSurface9*)surface_)->Release();
Draw:1756:Direct3D9\D3D9RenderSurface.cpp:132:    return parentTexture_->GetWidth();
Draw:1757:Direct3D9\D3D9RenderSurface.cpp:137:    return parentTexture_->GetHeight();
Draw:1758:Direct3D9\D3D9RenderSurface.cpp:142:    return parentTexture_->GetUsage();
Draw:1759:Direct3D9\D3D9IndexBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1760:Direct3D9\D3D9IndexBuffer.cpp:85:        if (graphics_->GetIndexBuffer() == this)
Draw:1761:Direct3D9\D3D9IndexBuffer.cpp:86:            graphics_->SetIndexBuffer(0);
Draw:1762:Direct3D9\D3D9IndexBuffer.cpp:88:        ((IDirect3DIndexBuffer9*)object_)->Release();
Draw:1763:Direct3D9\D3D9IndexBuffer.cpp:155:        if (graphics_->IsDeviceLost())
Draw:1764:Direct3D9\D3D9IndexBuffer.cpp:207:        if (graphics_->IsDeviceLost())
Draw:1765:Direct3D9\D3D9IndexBuffer.cpp:254:    if (object_ && !shadowData_ && !graphics_->IsDeviceLost())
Draw:1766:Direct3D9\D3D9IndexBuffer.cpp:264:        lockScratchData_ = graphics_->ReserveScratchBuffer(count * indexSize_);
Draw:1767:Direct3D9\D3D9IndexBuffer.cpp:287:            graphics_->FreeScratchBuffer(lockScratchData_);
Draw:1768:Direct3D9\D3D9IndexBuffer.cpp:341:    vertexCount = maxVertex - minVertex + 1;
Draw:1769:Direct3D9\D3D9IndexBuffer.cpp:354:        if (graphics_->IsDeviceLost())
Draw:1770:Direct3D9\D3D9IndexBuffer.cpp:360:        IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Draw:1771:Direct3D9\D3D9IndexBuffer.cpp:361:        if (!device || FAILED(device->CreateIndexBuffer(
Draw:1772:Direct3D9\D3D9IndexBuffer.cpp:396:        if (FAILED(((IDirect3DIndexBuffer9*)object_)->Lock(start * indexSize_, count * indexSize_, &hwData, flags)))
Draw:1773:Direct3D9\D3D9IndexBuffer.cpp:409:        ((IDirect3DIndexBuffer9*)object_)->Unlock();
Draw:1774:Direct3D9\D3D9Graphics.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:1775:Direct3D9\D3D9Graphics.cpp:220:        primitiveCount = elementCount - 2;
Draw:1776:Direct3D9\D3D9Graphics.cpp:225:        primitiveCount = elementCount - 1;
Draw:1777:Direct3D9\D3D9Graphics.cpp:230:        primitiveCount = elementCount - 2;
Draw:1778:Direct3D9\D3D9Graphics.cpp:284:    // Initialize SDL now. Graphics should be the first SDL-using subsystem to be created
Draw:1779:Direct3D9\D3D9Graphics.cpp:298:            (*i)->Release();
Draw:1780:Direct3D9\D3D9Graphics.cpp:304:    if (impl_->defaultColorSurface_)
Draw:1781:Direct3D9\D3D9Graphics.cpp:306:        impl_->defaultColorSurface_->Release();
Draw:1782:Direct3D9\D3D9Graphics.cpp:307:        impl_->defaultColorSurface_ = 0;
Draw:1783:Direct3D9\D3D9Graphics.cpp:309:    if (impl_->defaultDepthStencilSurface_)
Draw:1784:Direct3D9\D3D9Graphics.cpp:311:        impl_->defaultDepthStencilSurface_->Release();
Draw:1785:Direct3D9\D3D9Graphics.cpp:312:        impl_->defaultDepthStencilSurface_ = 0;
Draw:1786:Direct3D9\D3D9Graphics.cpp:314:    if (impl_->frameQuery_)
Draw:1787:Direct3D9\D3D9Graphics.cpp:316:        impl_->frameQuery_->Release();
Draw:1788:Direct3D9\D3D9Graphics.cpp:317:        impl_->frameQuery_ = 0;
Draw:1789:Direct3D9\D3D9Graphics.cpp:319:    if (impl_->device_)
Draw:1790:Direct3D9\D3D9Graphics.cpp:321:        impl_->device_->Release();
Draw:1791:Direct3D9\D3D9Graphics.cpp:322:        impl_->device_ = 0;
Draw:1792:Direct3D9\D3D9Graphics.cpp:324:    if (impl_->interface_)
Draw:1793:Direct3D9\D3D9Graphics.cpp:326:        impl_->interface_->Release();
Draw:1794:Direct3D9\D3D9Graphics.cpp:327:        impl_->interface_ = 0;
Draw:1795:Direct3D9\D3D9Graphics.cpp:329:    if (impl_->window_)
Draw:1796:Direct3D9\D3D9Graphics.cpp:332:        SDL_DestroyWindow(impl_->window_);
Draw:1797:Direct3D9\D3D9Graphics.cpp:333:        impl_->window_ = 0;
Draw:1798:Direct3D9\D3D9Graphics.cpp:339:    // Shut down SDL now. Graphics should be the last SDL-using subsystem to be destroyed
Draw:1799:Direct3D9\D3D9Graphics.cpp:345:    if (!impl_->window_)
Draw:1800:Direct3D9\D3D9Graphics.cpp:354:    if (impl_->window_)
Draw:1801:Direct3D9\D3D9Graphics.cpp:355:        SDL_SetWindowTitle(impl_->window_, windowTitle_.CString());
Draw:1802:Direct3D9\D3D9Graphics.cpp:361:    if (impl_->window_)
Draw:1803:Direct3D9\D3D9Graphics.cpp:367:    if (impl_->window_)
Draw:1804:Direct3D9\D3D9Graphics.cpp:368:        SDL_SetWindowPosition(impl_->window_, position.x_, position.y_);
Draw:1805:Direct3D9\D3D9Graphics.cpp:422:    if (!impl_->window_)
Draw:1806:Direct3D9\D3D9Graphics.cpp:428:    if (!impl_->interface_)
Draw:1807:Direct3D9\D3D9Graphics.cpp:452:                unsigned error = Abs(resolutions[i].x_ - width) + Abs(resolutions[i].y_ - height);
Draw:1808:Direct3D9\D3D9Graphics.cpp:465:    // Fall back to non-multisampled if unsupported multisampling mode
Draw:1809:Direct3D9\D3D9Graphics.cpp:468:        if (FAILED(impl_->interface_->CheckDeviceMultiSampleType(impl_->adapter_, impl_->deviceType_, fullscreenFormat, FALSE,
Draw:1810:Direct3D9\D3D9Graphics.cpp:478:        SDL_GetWindowSize(impl_->window_, &width, &height);
Draw:1811:Direct3D9\D3D9Graphics.cpp:483:        impl_->presentParams_.BackBufferFormat = fullscreenFormat;
Draw:1812:Direct3D9\D3D9Graphics.cpp:484:        impl_->presentParams_.Windowed         = false;
Draw:1813:Direct3D9\D3D9Graphics.cpp:488:        impl_->presentParams_.BackBufferFormat = D3DFMT_UNKNOWN;
Draw:1814:Direct3D9\D3D9Graphics.cpp:489:        impl_->presentParams_.Windowed         = true;
Draw:1815:Direct3D9\D3D9Graphics.cpp:492:    impl_->presentParams_.BackBufferWidth            = width;
Draw:1816:Direct3D9\D3D9Graphics.cpp:493:    impl_->presentParams_.BackBufferHeight           = height;
Draw:1817:Direct3D9\D3D9Graphics.cpp:494:    impl_->presentParams_.BackBufferCount            = tripleBuffer ? 2 : 1;
Draw:1818:Direct3D9\D3D9Graphics.cpp:495:    impl_->presentParams_.MultiSampleType            = multiSample > 1 ? (D3DMULTISAMPLE_TYPE)multiSample : D3DMULTISAMPLE_NONE;
Draw:1819:Direct3D9\D3D9Graphics.cpp:496:    impl_->presentParams_.MultiSampleQuality         = 0;
Draw:1820:Direct3D9\D3D9Graphics.cpp:497:    impl_->presentParams_.SwapEffect                 = D3DSWAPEFFECT_DISCARD;
Draw:1821:Direct3D9\D3D9Graphics.cpp:498:    impl_->presentParams_.hDeviceWindow              = GetWindowHandle(impl_->window_);
Draw:1822:Direct3D9\D3D9Graphics.cpp:499:    impl_->presentParams_.EnableAutoDepthStencil     = TRUE;
Draw:1823:Direct3D9\D3D9Graphics.cpp:500:    impl_->presentParams_.AutoDepthStencilFormat     = D3DFMT_D24S8;
Draw:1824:Direct3D9\D3D9Graphics.cpp:501:    impl_->presentParams_.Flags                      = D3DPRESENT_LINEAR_CONTENT;
Draw:1825:Direct3D9\D3D9Graphics.cpp:502:    impl_->presentParams_.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
Draw:1826:Direct3D9\D3D9Graphics.cpp:505:        impl_->presentParams_.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
Draw:1827:Direct3D9\D3D9Graphics.cpp:507:        impl_->presentParams_.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
Draw:1828:Direct3D9\D3D9Graphics.cpp:517:    if (!impl_->device_)
Draw:1829:Direct3D9\D3D9Graphics.cpp:523:        for (unsigned i=0; i < impl_->interface_->GetAdapterCount(); ++i)
Draw:1830:Direct3D9\D3D9Graphics.cpp:526:            impl_->interface_->GetAdapterIdentifier(i, 0, &identifier);
Draw:1831:Direct3D9\D3D9Graphics.cpp:535:        impl_->interface_->GetAdapterIdentifier(adapter, 0, &impl_->adapterIdentifier_);
Draw:1832:Direct3D9\D3D9Graphics.cpp:543:    impl_->device_->BeginScene();
Draw:1833:Direct3D9\D3D9Graphics.cpp:545:    impl_->device_->EndScene();
Draw:1834:Direct3D9\D3D9Graphics.cpp:546:    impl_->device_->Present(0, 0, 0, 0);
Draw:1835:Direct3D9\D3D9Graphics.cpp:601:    if (impl_->window_)
Draw:1836:Direct3D9\D3D9Graphics.cpp:604:        SDL_DestroyWindow(impl_->window_);
Draw:1837:Direct3D9\D3D9Graphics.cpp:605:        impl_->window_ = 0;
Draw:1838:Direct3D9\D3D9Graphics.cpp:613:    if (!impl_->device_)
Draw:1839:Direct3D9\D3D9Graphics.cpp:617:    impl_->defaultColorSurface_->GetDesc(&surfaceDesc);
Draw:1840:Direct3D9\D3D9Graphics.cpp:625:    if (impl_->presentParams_.MultiSampleType)
Draw:1841:Direct3D9\D3D9Graphics.cpp:639:    impl_->device_->CreateOffscreenPlainSurface(surfaceWidth, surfaceHeight, surfaceDesc.Format, D3DPOOL_SYSTEMMEM, &surface, 0);
Draw:1842:Direct3D9\D3D9Graphics.cpp:647:        impl_->device_->GetRenderTargetData(impl_->defaultColorSurface_, surface);
Draw:1843:Direct3D9\D3D9Graphics.cpp:649:        impl_->device_->GetFrontBufferData(0, surface);
Draw:1844:Direct3D9\D3D9Graphics.cpp:662:        HWND hwnd = GetWindowHandle(impl_->window_);
Draw:1845:Direct3D9\D3D9Graphics.cpp:669:    surface->LockRect(&lockedRect, &sourceRect, D3DLOCK_NOSYSLOCK | D3DLOCK_READONLY);
Draw:1846:Direct3D9\D3D9Graphics.cpp:673:        surface->Release();
Draw:1847:Direct3D9\D3D9Graphics.cpp:719:    surface->UnlockRect();
Draw:1848:Direct3D9\D3D9Graphics.cpp:720:    surface->Release();
Draw:1849:Direct3D9\D3D9Graphics.cpp:735:        SDL_GetWindowSize(impl_->window_, &width, &height);
Draw:1850:Direct3D9\D3D9Graphics.cpp:743:        if (fullscreen_ && (SDL_GetWindowFlags(impl_->window_) & SDL_WINDOW_MINIMIZED))
Draw:1851:Direct3D9\D3D9Graphics.cpp:748:    HRESULT hr = impl_->device_->TestCooperativeLevel();
Draw:1852:Direct3D9\D3D9Graphics.cpp:769:    impl_->device_->BeginScene();
Draw:1853:Direct3D9\D3D9Graphics.cpp:796:        impl_->device_->EndScene();
Draw:1854:Direct3D9\D3D9Graphics.cpp:797:        impl_->device_->Present(0, 0, 0, 0);
Draw:1855:Direct3D9\D3D9Graphics.cpp:802:    if (impl_->frameQuery_)
Draw:1856:Direct3D9\D3D9Graphics.cpp:808:            while (impl_->frameQuery_->GetData(0, 0, D3DGETDATA_FLUSH) == S_FALSE)
Draw:1857:Direct3D9\D3D9Graphics.cpp:817:            impl_->frameQuery_->Issue(D3DISSUE_END);
Draw:1858:Direct3D9\D3D9Graphics.cpp:836:    impl_->device_->Clear(0, 0, d3dFlags, GetD3DColor(color), depth, stencil);
Draw:1859:Direct3D9\D3D9Graphics.cpp:841:    if (!destination || !destination->GetRenderSurface())
Draw:1860:Direct3D9\D3D9Graphics.cpp:861:    destRect.right = destination->GetWidth();
Draw:1861:Direct3D9\D3D9Graphics.cpp:862:    destRect.bottom = destination->GetHeight();
Draw:1862:Direct3D9\D3D9Graphics.cpp:864:    return SUCCEEDED(impl_->device_->StretchRect(impl_->defaultColorSurface_, &rect,
Draw:1863:Direct3D9\D3D9Graphics.cpp:865:        (IDirect3DSurface9*)destination->GetRenderSurface()->GetSurface(), &destRect, D3DTEXF_NONE));
Draw:1864:Direct3D9\D3D9Graphics.cpp:879:    impl_->device_->DrawPrimitive(d3dPrimitiveType, vertexStart, primitiveCount);
Draw:1865:Direct3D9\D3D9Graphics.cpp:896:    impl_->device_->DrawIndexedPrimitive(d3dPrimitiveType, 0, minVertex, vertexCount, indexStart, primitiveCount);
Draw:1866:Direct3D9\D3D9Graphics.cpp:913:            if (buffer->GetElementMask() & MASK_INSTANCEMATRIX1)
Draw:1867:Direct3D9\D3D9Graphics.cpp:924:    impl_->device_->DrawIndexedPrimitive(d3dPrimitiveType, 0, minVertex, vertexCount, indexStart, primitiveCount);
Draw:1868:Direct3D9\D3D9Graphics.cpp:932:    // Note: this is not multi-instance safe
Draw:1869:Direct3D9\D3D9Graphics.cpp:961:        hash |= buffers[i]->GetBufferHash(i, elementMasks[i]);
Draw:1870:Direct3D9\D3D9Graphics.cpp:970:            if (!newDeclaration->GetDeclaration())
Draw:1871:Direct3D9\D3D9Graphics.cpp:982:            impl_->device_->SetVertexDeclaration(declaration->GetDeclaration());
Draw:1872:Direct3D9\D3D9Graphics.cpp:995:            if (buffer && buffer->GetElementMask() & MASK_INSTANCEMATRIX1)
Draw:1873:Direct3D9\D3D9Graphics.cpp:996:                offset = instanceOffset * buffer->GetVertexSize();
Draw:1874:Direct3D9\D3D9Graphics.cpp:1002:                impl_->device_->SetStreamSource(i, (IDirect3DVertexBuffer9*)buffer->GetGPUObject(), offset, buffer->GetVertexSize());
Draw:1875:Direct3D9\D3D9Graphics.cpp:1004:                impl_->device_->SetStreamSource(i, 0, 0, 0);
Draw:1876:Direct3D9\D3D9Graphics.cpp:1025:            impl_->device_->SetIndices((IDirect3DIndexBuffer9*)buffer->GetGPUObject());
Draw:1877:Direct3D9\D3D9Graphics.cpp:1027:            impl_->device_->SetIndices(0);
Draw:1878:Direct3D9\D3D9Graphics.cpp:1043:        if (vs && !vs->GetGPUObject())
Draw:1879:Direct3D9\D3D9Graphics.cpp:1045:            if (vs->GetCompilerOutput().Empty())
Draw:1880:Direct3D9\D3D9Graphics.cpp:1049:                bool success = vs->Create();
Draw:1881:Direct3D9\D3D9Graphics.cpp:1052:                    LOGERROR("Failed to compile vertex shader " + vs->GetFullName() + ":\n" + vs->GetCompilerOutput());
Draw:1882:Direct3D9\D3D9Graphics.cpp:1060:        if (vs && vs->GetShaderType() == VS)
Draw:1883:Direct3D9\D3D9Graphics.cpp:1061:            impl_->device_->SetVertexShader((IDirect3DVertexShader9*)vs->GetGPUObject());
Draw:1884:Direct3D9\D3D9Graphics.cpp:1064:            impl_->device_->SetVertexShader(0);
Draw:1885:Direct3D9\D3D9Graphics.cpp:1073:        if (ps && !ps->GetGPUObject())
Draw:1886:Direct3D9\D3D9Graphics.cpp:1075:            if (ps->GetCompilerOutput().Empty())
Draw:1887:Direct3D9\D3D9Graphics.cpp:1079:                bool success = ps->Create();
Draw:1888:Direct3D9\D3D9Graphics.cpp:1082:                    LOGERROR("Failed to compile pixel shader " + ps->GetFullName() + ":\n" + ps->GetCompilerOutput());
Draw:1889:Direct3D9\D3D9Graphics.cpp:1090:        if (ps && ps->GetShaderType() == PS)
Draw:1890:Direct3D9\D3D9Graphics.cpp:1091:            impl_->device_->SetPixelShader((IDirect3DPixelShader9*)ps->GetGPUObject());
Draw:1891:Direct3D9\D3D9Graphics.cpp:1094:            impl_->device_->SetPixelShader(0);
Draw:1892:Direct3D9\D3D9Graphics.cpp:1107:            shaderProgram_ = i->second_.Get();
Draw:1893:Direct3D9\D3D9Graphics.cpp:1119:        shaderPrecache_->StoreShaders(vertexShader_, pixelShader_);
Draw:1894:Direct3D9\D3D9Graphics.cpp:1125:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1895:Direct3D9\D3D9Graphics.cpp:1128:    if (i->second_.type_ == VS)
Draw:1896:Direct3D9\D3D9Graphics.cpp:1129:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, data, count / 4);
Draw:1897:Direct3D9\D3D9Graphics.cpp:1131:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, data, count / 4);
Draw:1898:Direct3D9\D3D9Graphics.cpp:1137:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1899:Direct3D9\D3D9Graphics.cpp:1143:    if (i->second_.type_ == VS)
Draw:1900:Direct3D9\D3D9Graphics.cpp:1144:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, &data.x_, 1);
Draw:1901:Direct3D9\D3D9Graphics.cpp:1146:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, &data.x_, 1);
Draw:1902:Direct3D9\D3D9Graphics.cpp:1153:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1903:Direct3D9\D3D9Graphics.cpp:1158:    if (i->second_.type_ == VS)
Draw:1904:Direct3D9\D3D9Graphics.cpp:1159:        impl_->device_->SetVertexShaderConstantB(i->second_.register_, &data, 1);
Draw:1905:Direct3D9\D3D9Graphics.cpp:1161:        impl_->device_->SetPixelShaderConstantB(i->second_.register_, &data, 1);
Draw:1906:Direct3D9\D3D9Graphics.cpp:1167:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1907:Direct3D9\D3D9Graphics.cpp:1170:    if (i->second_.type_ == VS)
Draw:1908:Direct3D9\D3D9Graphics.cpp:1171:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, color.Data(), 1);
Draw:1909:Direct3D9\D3D9Graphics.cpp:1173:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, color.Data(), 1);
Draw:1910:Direct3D9\D3D9Graphics.cpp:1179:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1911:Direct3D9\D3D9Graphics.cpp:1186:    if (i->second_.type_ == VS)
Draw:1912:Direct3D9\D3D9Graphics.cpp:1187:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, &data.x_, 1);
Draw:1913:Direct3D9\D3D9Graphics.cpp:1189:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, &data.x_, 1);
Draw:1914:Direct3D9\D3D9Graphics.cpp:1195:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1915:Direct3D9\D3D9Graphics.cpp:1209:    if (i->second_.type_ == VS)
Draw:1916:Direct3D9\D3D9Graphics.cpp:1210:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, &data.m00_, 3);
Draw:1917:Direct3D9\D3D9Graphics.cpp:1212:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, &data.m00_, 3);
Draw:1918:Direct3D9\D3D9Graphics.cpp:1218:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1919:Direct3D9\D3D9Graphics.cpp:1226:    if (i->second_.type_ == VS)
Draw:1920:Direct3D9\D3D9Graphics.cpp:1227:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, &data.x_, 1);
Draw:1921:Direct3D9\D3D9Graphics.cpp:1229:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, &data.x_, 1);
Draw:1922:Direct3D9\D3D9Graphics.cpp:1235:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1923:Direct3D9\D3D9Graphics.cpp:1238:    if (i->second_.type_ == VS)
Draw:1924:Direct3D9\D3D9Graphics.cpp:1239:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, matrix.Data(), 4);
Draw:1925:Direct3D9\D3D9Graphics.cpp:1241:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, matrix.Data(), 4);
Draw:1926:Direct3D9\D3D9Graphics.cpp:1247:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1927:Direct3D9\D3D9Graphics.cpp:1250:    if (i->second_.type_ == VS)
Draw:1928:Direct3D9\D3D9Graphics.cpp:1251:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, vector.Data(), 1);
Draw:1929:Direct3D9\D3D9Graphics.cpp:1253:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, vector.Data(), 1);
Draw:1930:Direct3D9\D3D9Graphics.cpp:1259:    if (!shaderProgram_ || (i = shaderProgram_->parameters_.Find(param)) == shaderProgram_->parameters_.End())
Draw:1931:Direct3D9\D3D9Graphics.cpp:1262:    if (i->second_.type_ == VS)
Draw:1932:Direct3D9\D3D9Graphics.cpp:1263:        impl_->device_->SetVertexShaderConstantF(i->second_.register_, matrix.Data(), 3);
Draw:1933:Direct3D9\D3D9Graphics.cpp:1265:        impl_->device_->SetPixelShaderConstantF(i->second_.register_, matrix.Data(), 3);
Draw:1934:Direct3D9\D3D9Graphics.cpp:1327:    return shaderProgram_ && shaderProgram_->parameters_.Find(param) != shaderProgram_->parameters_.End();
Draw:1935:Direct3D9\D3D9Graphics.cpp:1332:    return pixelShader_ && pixelShader_->HasTextureUnit(unit);
Draw:1936:Direct3D9\D3D9Graphics.cpp:1360:        if (renderTargets_[0] && renderTargets_[0]->GetParentTexture() == texture)
Draw:1937:Direct3D9\D3D9Graphics.cpp:1361:            texture = texture->GetBackupTexture();
Draw:1938:Direct3D9\D3D9Graphics.cpp:1367:            impl_->device_->SetTexture(index, (IDirect3DBaseTexture9*)texture->GetGPUObject());
Draw:1939:Direct3D9\D3D9Graphics.cpp:1369:            impl_->device_->SetTexture(index, 0);
Draw:1940:Direct3D9\D3D9Graphics.cpp:1376:        TextureFilterMode filterMode = texture->GetFilterMode();
Draw:1941:Direct3D9\D3D9Graphics.cpp:1382:        if (minMag != impl_->minMagFilters_[index])
Draw:1942:Direct3D9\D3D9Graphics.cpp:1384:            impl_->device_->SetSamplerState(index, D3DSAMP_MAGFILTER, minMag);
Draw:1943:Direct3D9\D3D9Graphics.cpp:1385:            impl_->device_->SetSamplerState(index, D3DSAMP_MINFILTER, minMag);
Draw:1944:Direct3D9\D3D9Graphics.cpp:1386:            impl_->minMagFilters_[index] = minMag;
Draw:1945:Direct3D9\D3D9Graphics.cpp:1389:        if (mip != impl_->mipFilters_[index])
Draw:1946:Direct3D9\D3D9Graphics.cpp:1391:            impl_->device_->SetSamplerState(index, D3DSAMP_MIPFILTER, mip);
Draw:1947:Direct3D9\D3D9Graphics.cpp:1392:            impl_->mipFilters_[index] = mip;
Draw:1948:Direct3D9\D3D9Graphics.cpp:1395:        u = d3dAddressMode[texture->GetAddressMode(COORD_U)];
Draw:1949:Direct3D9\D3D9Graphics.cpp:1396:        if (u != impl_->uAddressModes_[index])
Draw:1950:Direct3D9\D3D9Graphics.cpp:1398:            impl_->device_->SetSamplerState(index, D3DSAMP_ADDRESSU, u);
Draw:1951:Direct3D9\D3D9Graphics.cpp:1399:            impl_->uAddressModes_[index] = u;
Draw:1952:Direct3D9\D3D9Graphics.cpp:1401:        v = d3dAddressMode[texture->GetAddressMode(COORD_V)];
Draw:1953:Direct3D9\D3D9Graphics.cpp:1402:        if (v != impl_->vAddressModes_[index])
Draw:1954:Direct3D9\D3D9Graphics.cpp:1404:            impl_->device_->SetSamplerState(index, D3DSAMP_ADDRESSV, v);
Draw:1955:Direct3D9\D3D9Graphics.cpp:1405:            impl_->vAddressModes_[index] = v;
Draw:1956:Direct3D9\D3D9Graphics.cpp:1407:        if (texture->GetType() == TextureCube::GetTypeStatic())
Draw:1957:Direct3D9\D3D9Graphics.cpp:1409:            D3DTEXTUREADDRESS w = d3dAddressMode[texture->GetAddressMode(COORD_W)];
Draw:1958:Direct3D9\D3D9Graphics.cpp:1410:            if (w != impl_->wAddressModes_[index])
Draw:1959:Direct3D9\D3D9Graphics.cpp:1412:                impl_->device_->SetSamplerState(index, D3DSAMP_ADDRESSW, w);
Draw:1960:Direct3D9\D3D9Graphics.cpp:1413:                impl_->wAddressModes_[index] = w;
Draw:1961:Direct3D9\D3D9Graphics.cpp:1418:            const Color& borderColor = texture->GetBorderColor();
Draw:1962:Direct3D9\D3D9Graphics.cpp:1419:            if (borderColor != impl_->borderColors_[index])
Draw:1963:Direct3D9\D3D9Graphics.cpp:1421:                impl_->device_->SetSamplerState(index, D3DSAMP_BORDERCOLOR, GetD3DColor(borderColor));
Draw:1964:Direct3D9\D3D9Graphics.cpp:1422:                impl_->borderColors_[index] = borderColor;
Draw:1965:Direct3D9\D3D9Graphics.cpp:1427:            bool sRGB = texture->GetSRGB();
Draw:1966:Direct3D9\D3D9Graphics.cpp:1428:            if (sRGB != impl_->sRGBModes_[index])
Draw:1967:Direct3D9\D3D9Graphics.cpp:1430:                impl_->device_->SetSamplerState(index, D3DSAMP_SRGBTEXTURE, sRGB ? TRUE : FALSE);
Draw:1968:Direct3D9\D3D9Graphics.cpp:1431:                impl_->sRGBModes_[index] = sRGB;
Draw:1969:Direct3D9\D3D9Graphics.cpp:1469:        if (renderTarget->GetUsage() != TEXTURE_RENDERTARGET)
Draw:1970:Direct3D9\D3D9Graphics.cpp:1471:        newColorSurface = (IDirect3DSurface9*)renderTarget->GetSurface();
Draw:1971:Direct3D9\D3D9Graphics.cpp:1476:            newColorSurface = impl_->defaultColorSurface_;
Draw:1972:Direct3D9\D3D9Graphics.cpp:1481:    if (newColorSurface != impl_->colorSurfaces_[index])
Draw:1973:Direct3D9\D3D9Graphics.cpp:1483:        impl_->device_->SetRenderTarget(index, newColorSurface);
Draw:1974:Direct3D9\D3D9Graphics.cpp:1484:        impl_->colorSurfaces_[index] = newColorSurface;
Draw:1975:Direct3D9\D3D9Graphics.cpp:1496:        Texture* parentTexture = renderTarget->GetParentTexture();
Draw:1976:Direct3D9\D3D9Graphics.cpp:1501:                SetTexture(i, textures_[i]->GetBackupTexture());
Draw:1977:Direct3D9\D3D9Graphics.cpp:1508:        bool sRGBWrite = renderTarget ? renderTarget->GetParentTexture()->GetSRGB() : sRGB_;
Draw:1978:Direct3D9\D3D9Graphics.cpp:1509:        if (sRGBWrite != impl_->sRGBWrite_)
Draw:1979:Direct3D9\D3D9Graphics.cpp:1511:            impl_->device_->SetRenderState(D3DRS_SRGBWRITEENABLE, sRGBWrite ? TRUE : FALSE);
Draw:1980:Direct3D9\D3D9Graphics.cpp:1512:            impl_->sRGBWrite_ = sRGBWrite;
Draw:1981:Direct3D9\D3D9Graphics.cpp:1521:        renderTarget = texture->GetRenderSurface();
Draw:1982:Direct3D9\D3D9Graphics.cpp:1529:    if (depthStencil && depthStencil->GetUsage() == TEXTURE_DEPTHSTENCIL)
Draw:1983:Direct3D9\D3D9Graphics.cpp:1531:        newDepthStencilSurface = (IDirect3DSurface9*)depthStencil->GetSurface();
Draw:1984:Direct3D9\D3D9Graphics.cpp:1536:        newDepthStencilSurface = impl_->defaultDepthStencilSurface_;
Draw:1985:Direct3D9\D3D9Graphics.cpp:1539:    if (newDepthStencilSurface != impl_->depthStencilSurface_)
Draw:1986:Direct3D9\D3D9Graphics.cpp:1541:        impl_->device_->SetDepthStencilSurface(newDepthStencilSurface);
Draw:1987:Direct3D9\D3D9Graphics.cpp:1542:        impl_->depthStencilSurface_ = newDepthStencilSurface;
Draw:1988:Direct3D9\D3D9Graphics.cpp:1550:        depthStencil = texture->GetRenderSurface();
Draw:1989:Direct3D9\D3D9Graphics.cpp:1578:    impl_->device_->SetViewport(&vp);
Draw:1990:Direct3D9\D3D9Graphics.cpp:1581:    // Disable scissor test, needs to be re-enabled by the user
Draw:1991:Direct3D9\D3D9Graphics.cpp:1593:            impl_->device_->SetSamplerState(i, D3DSAMP_MAXANISOTROPY, level);
Draw:1992:Direct3D9\D3D9Graphics.cpp:1603:        if (d3dBlendEnable[mode] != impl_->blendEnable_)
Draw:1993:Direct3D9\D3D9Graphics.cpp:1605:            impl_->device_->SetRenderState(D3DRS_ALPHABLENDENABLE, d3dBlendEnable[mode]);
Draw:1994:Direct3D9\D3D9Graphics.cpp:1606:            impl_->blendEnable_ = d3dBlendEnable[mode];
Draw:1995:Direct3D9\D3D9Graphics.cpp:1609:        if (impl_->blendEnable_)
Draw:1996:Direct3D9\D3D9Graphics.cpp:1611:            if (d3dSrcBlend[mode] != impl_->srcBlend_)
Draw:1997:Direct3D9\D3D9Graphics.cpp:1613:                impl_->device_->SetRenderState(D3DRS_SRCBLEND, d3dSrcBlend[mode]);
Draw:1998:Direct3D9\D3D9Graphics.cpp:1614:                impl_->srcBlend_ = d3dSrcBlend[mode];
Draw:1999:Direct3D9\D3D9Graphics.cpp:1616:            if (d3dDestBlend[mode] != impl_->destBlend_)
Draw:2000:Direct3D9\D3D9Graphics.cpp:1618:                impl_->device_->SetRenderState(D3DRS_DESTBLEND, d3dDestBlend[mode]);
Draw:2001:Direct3D9\D3D9Graphics.cpp:1619:                impl_->destBlend_ = d3dDestBlend[mode];
Draw:2002:Direct3D9\D3D9Graphics.cpp:1621:            if (d3dBlendOp[mode] != impl_->blendOp_)
Draw:2003:Direct3D9\D3D9Graphics.cpp:1623:                impl_->device_->SetRenderState(D3DRS_BLENDOP, d3dBlendOp[mode]);
Draw:2004:Direct3D9\D3D9Graphics.cpp:1624:                impl_->blendOp_ = d3dBlendOp[mode];
Draw:2005:Direct3D9\D3D9Graphics.cpp:1636:        impl_->device_->SetRenderState(D3DRS_COLORWRITEENABLE, enable ? D3DCOLORWRITEENABLE_RED |
Draw:2006:Direct3D9\D3D9Graphics.cpp:1646:        impl_->device_->SetRenderState(D3DRS_CULLMODE, d3dCullMode[mode]);
Draw:2007:Direct3D9\D3D9Graphics.cpp:1655:        impl_->device_->SetRenderState(D3DRS_DEPTHBIAS, *((DWORD*)&constantBias));
Draw:2008:Direct3D9\D3D9Graphics.cpp:1660:        impl_->device_->SetRenderState(D3DRS_SLOPESCALEDEPTHBIAS, *((DWORD*)&slopeScaledBias));
Draw:2009:Direct3D9\D3D9Graphics.cpp:1669:        impl_->device_->SetRenderState(D3DRS_ZFUNC, d3dCmpFunc[mode]);
Draw:2010:Direct3D9\D3D9Graphics.cpp:1678:        impl_->device_->SetRenderState(D3DRS_ZWRITEENABLE, enable ? TRUE : FALSE);
Draw:2011:Direct3D9\D3D9Graphics.cpp:1687:        impl_->device_->SetRenderState(D3DRS_FILLMODE, d3dFillMode[mode]);
Draw:2012:Direct3D9\D3D9Graphics.cpp:1707:        intRect.left_ = Clamp((int)((rect.min_.x_ + 1.0f) * 0.5f * viewSize.x_) + viewPos.x_, 0, rtSize.x_ - 1);
Draw:2013:Direct3D9\D3D9Graphics.cpp:1708:        intRect.top_ = Clamp((int)((-rect.max_.y_ + 1.0f) * 0.5f * viewSize.y_) + viewPos.y_, 0, rtSize.y_ - 1);
Draw:2014:Direct3D9\D3D9Graphics.cpp:1710:        intRect.bottom_ = Clamp((int)((-rect.min_.y_ + 1.0f) * 0.5f * viewSize.y_) + viewPos.y_ + expand, 0, rtSize.y_);
Draw:2015:Direct3D9\D3D9Graphics.cpp:1728:            impl_->device_->SetScissorRect(&d3dRect);
Draw:2016:Direct3D9\D3D9Graphics.cpp:1737:        impl_->device_->SetRenderState(D3DRS_SCISSORTESTENABLE, enable ? TRUE : FALSE);
Draw:2017:Direct3D9\D3D9Graphics.cpp:1751:        intRect.left_ = Clamp(rect.left_ + viewPos.x_, 0, rtSize.x_ - 1);
Draw:2018:Direct3D9\D3D9Graphics.cpp:1752:        intRect.top_ = Clamp(rect.top_ + viewPos.y_, 0, rtSize.y_ - 1);
Draw:2019:Direct3D9\D3D9Graphics.cpp:1772:            impl_->device_->SetScissorRect(&d3dRect);
Draw:2020:Direct3D9\D3D9Graphics.cpp:1781:        impl_->device_->SetRenderState(D3DRS_SCISSORTESTENABLE, enable ? TRUE : FALSE);
Draw:2021:Direct3D9\D3D9Graphics.cpp:1790:        impl_->device_->SetRenderState(D3DRS_STENCILENABLE, enable ? TRUE : FALSE);
Draw:2022:Direct3D9\D3D9Graphics.cpp:1798:            impl_->device_->SetRenderState(D3DRS_STENCILFUNC, d3dCmpFunc[mode]);
Draw:2023:Direct3D9\D3D9Graphics.cpp:1803:            impl_->device_->SetRenderState(D3DRS_STENCILPASS, d3dStencilOp[pass]);
Draw:2024:Direct3D9\D3D9Graphics.cpp:1808:            impl_->device_->SetRenderState(D3DRS_STENCILFAIL, d3dStencilOp[fail]);
Draw:2025:Direct3D9\D3D9Graphics.cpp:1813:            impl_->device_->SetRenderState(D3DRS_STENCILZFAIL, d3dStencilOp[zFail]);
Draw:2026:Direct3D9\D3D9Graphics.cpp:1818:            impl_->device_->SetRenderState(D3DRS_STENCILREF, stencilRef);
Draw:2027:Direct3D9\D3D9Graphics.cpp:1823:            impl_->device_->SetRenderState(D3DRS_STENCILMASK, compareMask);
Draw:2028:Direct3D9\D3D9Graphics.cpp:1828:            impl_->device_->SetRenderState(D3DRS_STENCILWRITEMASK, writeMask);
Draw:2029:Direct3D9\D3D9Graphics.cpp:1838:        impl_->device_->SetRenderState(D3DRS_CLIPPLANEENABLE, enable ? 1 : 0);
Draw:2030:Direct3D9\D3D9Graphics.cpp:1845:        impl_->device_->SetClipPlane(0, clipPlane.Transformed(viewProj).ToVector4().Data());
Draw:2031:Direct3D9\D3D9Graphics.cpp:1868:    return impl_->window_ != 0 && impl_->GetDevice() != 0;
Draw:2032:Direct3D9\D3D9Graphics.cpp:1873:    if (impl_->window_)
Draw:2033:Direct3D9\D3D9Graphics.cpp:1914:    if (!impl_->interface_)
Draw:2034:Direct3D9\D3D9Graphics.cpp:1923:        if (SUCCEEDED(impl_->interface_->CheckDeviceMultiSampleType(impl_->adapter_, impl_->deviceType_, fullscreenFormat, FALSE,
Draw:2035:Direct3D9\D3D9Graphics.cpp:1971:        if (lastShaderName_ == name && !cache->Exists(fullShaderName))
Draw:2036:Direct3D9\D3D9Graphics.cpp:1974:        lastShader_ = cache->GetResource<Shader>(fullShaderName);
Draw:2037:Direct3D9\D3D9Graphics.cpp:1978:    return lastShader_ ? lastShader_->GetVariation(type, defines) : (ShaderVariation*)0;
Draw:2038:Direct3D9\D3D9Graphics.cpp:1990:        return i->second_;
Draw:2039:Direct3D9\D3D9Graphics.cpp:1999:        if (i->second_ == unit)
Draw:2040:Direct3D9\D3D9Graphics.cpp:2000:            return i->first_;
Draw:2041:Direct3D9\D3D9Graphics.cpp:2021:        width = renderTargets_[0]->GetWidth();
Draw:2042:Direct3D9\D3D9Graphics.cpp:2022:        height = renderTargets_[0]->GetHeight();
Draw:2043:Direct3D9\D3D9Graphics.cpp:2035:    if (!impl_->device_ || !impl_->window_)
Draw:2044:Direct3D9\D3D9Graphics.cpp:2040:    SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Draw:2045:Direct3D9\D3D9Graphics.cpp:2047:    impl_->presentParams_.BackBufferWidth            = width_;
Draw:2046:Direct3D9\D3D9Graphics.cpp:2048:    impl_->presentParams_.BackBufferHeight           = height_;
Draw:2047:Direct3D9\D3D9Graphics.cpp:2069:    if (!impl_->device_ || !impl_->window_ || fullscreen_)
Draw:2048:Direct3D9\D3D9Graphics.cpp:2074:    SDL_GetWindowPosition(impl_->window_, &newX, &newY);
Draw:2049:Direct3D9\D3D9Graphics.cpp:2093:    if (!impl_->window_)
Draw:2050:Direct3D9\D3D9Graphics.cpp:2096:    SDL_MaximizeWindow(impl_->window_);
Draw:2051:Direct3D9\D3D9Graphics.cpp:2101:    if (!impl_->window_)
Draw:2052:Direct3D9\D3D9Graphics.cpp:2104:    SDL_MinimizeWindow(impl_->window_);
Draw:2053:Direct3D9\D3D9Graphics.cpp:2132:        if (!i->reserved_ && i->size_ >= size)
Draw:2054:Direct3D9\D3D9Graphics.cpp:2134:            i->reserved_ = true;
Draw:2055:Direct3D9\D3D9Graphics.cpp:2135:            return i->data_.Get();
Draw:2056:Direct3D9\D3D9Graphics.cpp:2142:        if (!i->reserved_)
Draw:2057:Direct3D9\D3D9Graphics.cpp:2144:            i->data_ = new unsigned char[size];
Draw:2058:Direct3D9\D3D9Graphics.cpp:2145:            i->size_ = size;
Draw:2059:Direct3D9\D3D9Graphics.cpp:2146:            i->reserved_ = true;
Draw:2060:Direct3D9\D3D9Graphics.cpp:2150:            return i->data_.Get();
Draw:2061:Direct3D9\D3D9Graphics.cpp:2172:        if (i->reserved_ && i->data_.Get() == buffer)
Draw:2062:Direct3D9\D3D9Graphics.cpp:2174:            i->reserved_ = false;
Draw:2063:Direct3D9\D3D9Graphics.cpp:2186:        if (!i->reserved_ && i->size_ > maxScratchBufferRequest_ * 2)
Draw:2064:Direct3D9\D3D9Graphics.cpp:2188:            i->data_ = maxScratchBufferRequest_ > 0 ? new unsigned char[maxScratchBufferRequest_] : 0;
Draw:2065:Direct3D9\D3D9Graphics.cpp:2189:            i->size_ = maxScratchBufferRequest_;
Draw:2066:Direct3D9\D3D9Graphics.cpp:2202:        if (i->first_.first_ == variation || i->first_.second_ == variation)
Draw:2067:Direct3D9\D3D9Graphics.cpp:2336:        impl_->device_->SetStreamSourceFreq(index, frequency);
Draw:2068:Direct3D9\D3D9Graphics.cpp:2347:            impl_->device_->SetStreamSourceFreq(i, 1);
Draw:2069:Direct3D9\D3D9Graphics.cpp:2363:        impl_->window_ = SDL_CreateWindow(windowTitle_.CString(), position_.x_, position_.y_, width, height, flags);
Draw:2070:Direct3D9\D3D9Graphics.cpp:2366:        impl_->window_ = SDL_CreateWindowFrom(externalWindow_, 0);
Draw:2071:Direct3D9\D3D9Graphics.cpp:2368:    if (!impl_->window_)
Draw:2072:Direct3D9\D3D9Graphics.cpp:2374:    SDL_GetWindowPosition(impl_->window_, &position_.x_, &position_.y_);
Draw:2073:Direct3D9\D3D9Graphics.cpp:2385:        SDL_Surface* surface = windowIcon_->GetSDLSurface();
Draw:2074:Direct3D9\D3D9Graphics.cpp:2388:            SDL_SetWindowIcon(impl_->window_, surface);
Draw:2075:Direct3D9\D3D9Graphics.cpp:2400:            SDL_MaximizeWindow(impl_->window_);
Draw:2076:Direct3D9\D3D9Graphics.cpp:2401:            SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Draw:2077:Direct3D9\D3D9Graphics.cpp:2404:            SDL_SetWindowSize(impl_->window_, newWidth, newHeight);
Draw:2078:Direct3D9\D3D9Graphics.cpp:2406:        SDL_SetWindowFullscreen(impl_->window_, newFullscreen ? SDL_TRUE : SDL_FALSE);
Draw:2079:Direct3D9\D3D9Graphics.cpp:2407:        SDL_SetWindowBordered(impl_->window_, newBorderless ? SDL_FALSE : SDL_TRUE);
Draw:2080:Direct3D9\D3D9Graphics.cpp:2412:        SDL_GetWindowSize(impl_->window_, &newWidth, &newHeight);
Draw:2081:Direct3D9\D3D9Graphics.cpp:2419:    impl_->interface_ = Direct3DCreate9(D3D_SDK_VERSION);
Draw:2082:Direct3D9\D3D9Graphics.cpp:2420:    if (!impl_->interface_)
Draw:2083:Direct3D9\D3D9Graphics.cpp:2426:    if (FAILED(impl_->interface_->GetDeviceCaps(impl_->adapter_, impl_->deviceType_, &impl_->deviceCaps_)))
Draw:2084:Direct3D9\D3D9Graphics.cpp:2432:    if (FAILED(impl_->interface_->GetAdapterIdentifier(impl_->adapter_, 0, &impl_->adapterIdentifier_)))
Draw:2085:Direct3D9\D3D9Graphics.cpp:2438:    if (impl_->deviceCaps_.PixelShaderVersion < D3DPS_VERSION(3, 0))
Draw:2086:Direct3D9\D3D9Graphics.cpp:2454:    if (impl_->deviceCaps_.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT)
Draw:2087:Direct3D9\D3D9Graphics.cpp:2457:        if (impl_->deviceCaps_.DevCaps & D3DDEVCAPS_PUREDEVICE)
Draw:2088:Direct3D9\D3D9Graphics.cpp:2463:    if (FAILED(impl_->interface_->CreateDevice(
Draw:2089:Direct3D9\D3D9Graphics.cpp:2466:        GetWindowHandle(impl_->window_),
Draw:2090:Direct3D9\D3D9Graphics.cpp:2468:        &impl_->presentParams_,
Draw:2091:Direct3D9\D3D9Graphics.cpp:2469:        &impl_->device_)))
Draw:2092:Direct3D9\D3D9Graphics.cpp:2475:    impl_->adapter_ = adapter;
Draw:2093:Direct3D9\D3D9Graphics.cpp:2476:    impl_->deviceType_ = (D3DDEVTYPE)deviceType;
Draw:2094:Direct3D9\D3D9Graphics.cpp:2495:    if (impl_->CheckFormatSupport((D3DFORMAT)shadowMapFormat_, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE))
Draw:2095:Direct3D9\D3D9Graphics.cpp:2501:        if (!impl_->CheckFormatSupport((D3DFORMAT)hiresShadowMapFormat_, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE))
Draw:2096:Direct3D9\D3D9Graphics.cpp:2508:        if (impl_->CheckFormatSupport((D3DFORMAT)shadowMapFormat_, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE))
Draw:2097:Direct3D9\D3D9Graphics.cpp:2512:            if (!impl_->CheckFormatSupport((D3DFORMAT)hiresShadowMapFormat_, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE))
Draw:2098:Direct3D9\D3D9Graphics.cpp:2526:        if (impl_->adapterIdentifier_.VendorId == 0x8086 && impl_->adapterIdentifier_.DeviceId == 0x2a42 &&
Draw:2099:Direct3D9\D3D9Graphics.cpp:2527:            impl_->adapterIdentifier_.DriverVersion.QuadPart <= 0x0007000f000a05d0ULL)
Draw:2100:Direct3D9\D3D9Graphics.cpp:2533:    if (impl_->CheckFormatSupport(intZFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_TEXTURE))
Draw:2101:Direct3D9\D3D9Graphics.cpp:2539:    if (impl_->CheckFormatSupport(nullFormat, D3DUSAGE_RENDERTARGET, D3DRTYPE_TEXTURE))
Draw:2102:Direct3D9\D3D9Graphics.cpp:2541:    else if (impl_->CheckFormatSupport(D3DFMT_R16F, D3DUSAGE_RENDERTARGET, D3DRTYPE_TEXTURE))
Draw:2103:Direct3D9\D3D9Graphics.cpp:2543:    else if (impl_->CheckFormatSupport(D3DFMT_R5G6B5, D3DUSAGE_RENDERTARGET, D3DRTYPE_TEXTURE))
Draw:2104:Direct3D9\D3D9Graphics.cpp:2545:    else if (impl_->CheckFormatSupport(D3DFMT_A4R4G4B4, D3DUSAGE_RENDERTARGET, D3DRTYPE_TEXTURE))
Draw:2105:Direct3D9\D3D9Graphics.cpp:2549:    if (impl_->deviceCaps_.NumSimultaneousRTs >= 2 && impl_->CheckFormatSupport(D3DFMT_R32F, D3DUSAGE_RENDERTARGET,
Draw:2106:Direct3D9\D3D9Graphics.cpp:2553:        if (impl_->deviceCaps_.NumSimultaneousRTs >= 4)
Draw:2107:Direct3D9\D3D9Graphics.cpp:2558:    if (impl_->deviceCaps_.DevCaps2 & D3DDEVCAPS2_STREAMOFFSET)
Draw:2108:Direct3D9\D3D9Graphics.cpp:2563:    sRGBSupport_ = impl_->CheckFormatSupport(D3DFMT_X8R8G8B8, D3DUSAGE_QUERY_SRGBREAD, D3DRTYPE_TEXTURE);
Draw:2109:Direct3D9\D3D9Graphics.cpp:2564:    sRGBWriteSupport_ = impl_->CheckFormatSupport(D3DFMT_X8R8G8B8, D3DUSAGE_QUERY_SRGBWRITE, D3DRTYPE_TEXTURE);
Draw:2110:Direct3D9\D3D9Graphics.cpp:2571:    if (SUCCEEDED(impl_->device_->Reset(&impl_->presentParams_)))
Draw:2111:Direct3D9\D3D9Graphics.cpp:2582:    if (impl_->defaultColorSurface_)
Draw:2112:Direct3D9\D3D9Graphics.cpp:2584:        impl_->defaultColorSurface_->Release();
Draw:2113:Direct3D9\D3D9Graphics.cpp:2585:        impl_->defaultColorSurface_ = 0;
Draw:2114:Direct3D9\D3D9Graphics.cpp:2587:    if (impl_->defaultDepthStencilSurface_)
Draw:2115:Direct3D9\D3D9Graphics.cpp:2589:        impl_->defaultDepthStencilSurface_->Release();
Draw:2116:Direct3D9\D3D9Graphics.cpp:2590:        impl_->defaultDepthStencilSurface_ = 0;
Draw:2117:Direct3D9\D3D9Graphics.cpp:2592:    if (impl_->frameQuery_)
Draw:2118:Direct3D9\D3D9Graphics.cpp:2594:        impl_->frameQuery_->Release();
Draw:2119:Direct3D9\D3D9Graphics.cpp:2595:        impl_->frameQuery_ = 0;
Draw:2120:Direct3D9\D3D9Graphics.cpp:2602:            (*i)->OnDeviceLost();
Draw:2121:Direct3D9\D3D9Graphics.cpp:2614:            (*i)->OnDeviceReset();
Draw:2122:Direct3D9\D3D9Graphics.cpp:2618:    impl_->device_->GetRenderTarget(0, &impl_->defaultColorSurface_);
Draw:2123:Direct3D9\D3D9Graphics.cpp:2619:    impl_->device_->GetDepthStencilSurface(&impl_->defaultDepthStencilSurface_);
Draw:2124:Direct3D9\D3D9Graphics.cpp:2622:    impl_->device_->CreateQuery(D3DQUERYTYPE_EVENT, &impl_->frameQuery_);
Draw:2125:Direct3D9\D3D9Graphics.cpp:2640:        impl_->minMagFilters_[i] = D3DTEXF_POINT;
Draw:2126:Direct3D9\D3D9Graphics.cpp:2641:        impl_->mipFilters_[i] = D3DTEXF_NONE;
Draw:2127:Direct3D9\D3D9Graphics.cpp:2642:        impl_->uAddressModes_[i] = D3DTADDRESS_WRAP;
Draw:2128:Direct3D9\D3D9Graphics.cpp:2643:        impl_->vAddressModes_[i] = D3DTADDRESS_WRAP;
Draw:2129:Direct3D9\D3D9Graphics.cpp:2644:        impl_->wAddressModes_[i] = D3DTADDRESS_WRAP;
Draw:2130:Direct3D9\D3D9Graphics.cpp:2645:        impl_->borderColors_[i] = Color(0.0f, 0.0f, 0.0f, 0.0f);
Draw:2131:Direct3D9\D3D9Graphics.cpp:2646:        impl_->sRGBModes_[i] = false;
Draw:2132:Direct3D9\D3D9Graphics.cpp:2652:        impl_->colorSurfaces_[i] = 0;
Draw:2133:Direct3D9\D3D9Graphics.cpp:2656:    impl_->depthStencilSurface_ = 0;
Draw:2134:Direct3D9\D3D9Graphics.cpp:2658:    impl_->sRGBWrite_ = false;
Draw:2135:Direct3D9\D3D9Graphics.cpp:2687:    impl_->blendEnable_ = FALSE;
Draw:2136:Direct3D9\D3D9Graphics.cpp:2688:    impl_->srcBlend_ = D3DBLEND_ONE;
Draw:2137:Direct3D9\D3D9Graphics.cpp:2689:    impl_->destBlend_ = D3DBLEND_ZERO;
Draw:2138:Direct3D9\D3D9Graphics.cpp:2690:    impl_->blendOp_ = D3DBLENDOP_ADD;
Draw:2139:Direct3D9\D3D9RenderSurface.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2140:Direct3D9\D3D9RenderSurface.h:33:/// %Color or depth-stencil surface that can be rendered into.
Draw:2141:Direct3D9\D3D9RenderSurface.h:53:    /// Set linked depth-stencil surface.
Draw:2142:Direct3D9\D3D9RenderSurface.h:78:    /// Return linked depth-stencil surface.
Draw:2143:Direct3D9\D3D9ShaderProgram.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2144:Direct3D9\D3D9ShaderProgram.h:38:        const HashMap<StringHash, ShaderParameter>& vsParams = vertexShader->GetParameters();
Draw:2145:Direct3D9\D3D9ShaderProgram.h:40:        parameters_[i->first_] = i->second_;
Draw:2146:Direct3D9\D3D9ShaderProgram.h:42:        const HashMap<StringHash, ShaderParameter>& psParams = pixelShader->GetParameters();
Draw:2147:Direct3D9\D3D9ShaderProgram.h:44:            parameters_[i->first_] = i->second_;
Draw:2148:Direct3D9\D3D9ShaderVariation.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2149:Direct3D9\D3D9ShaderVariation.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2150:Direct3D9\D3D9ShaderVariation.cpp:42:    GPUObject(owner->GetSubsystem<Graphics>()),
Draw:2151:Direct3D9\D3D9ShaderVariation.cpp:68:    // Check for up-to-date bytecode on disk
Draw:2152:Direct3D9\D3D9ShaderVariation.cpp:70:    SplitPath(owner_->GetName(), path, name, extension);
Draw:2153:Direct3D9\D3D9ShaderVariation.cpp:82:        if (owner_->GetTimeStamp())
Draw:2154:Direct3D9\D3D9ShaderVariation.cpp:87:    IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Draw:2155:Direct3D9\D3D9ShaderVariation.cpp:90:        if (!device || FAILED(device->CreateVertexShader(
Draw:2156:Direct3D9\D3D9ShaderVariation.cpp:97:        if (!device || FAILED(device->CreatePixelShader(
Draw:2157:Direct3D9\D3D9ShaderVariation.cpp:113:        graphics_->CleanupShaderPrograms(this);
Draw:2158:Direct3D9\D3D9ShaderVariation.cpp:117:            if (graphics_->GetVertexShader() == this)
Draw:2159:Direct3D9\D3D9ShaderVariation.cpp:118:                graphics_->SetShaders(0, 0);
Draw:2160:Direct3D9\D3D9ShaderVariation.cpp:120:            ((IDirect3DVertexShader9*)object_)->Release();
Draw:2161:Direct3D9\D3D9ShaderVariation.cpp:124:            if (graphics_->GetPixelShader() == this)
Draw:2162:Direct3D9\D3D9ShaderVariation.cpp:125:                graphics_->SetShaders(0, 0);
Draw:2163:Direct3D9\D3D9ShaderVariation.cpp:127:            ((IDirect3DPixelShader9*)object_)->Release();
Draw:2164:Direct3D9\D3D9ShaderVariation.cpp:157:    ResourceCache* cache = owner_->GetSubsystem<ResourceCache>();
Draw:2165:Direct3D9\D3D9ShaderVariation.cpp:158:    if (!cache->Exists(binaryShaderName))
Draw:2166:Direct3D9\D3D9ShaderVariation.cpp:161:    FileSystem* fileSystem = owner_->GetSubsystem<FileSystem>();
Draw:2167:Direct3D9\D3D9ShaderVariation.cpp:162:    unsigned sourceTimeStamp = owner_->GetTimeStamp();
Draw:2168:Direct3D9\D3D9ShaderVariation.cpp:165:    if (sourceTimeStamp && fileSystem->GetLastModifiedTime(cache->GetResourceFileName(binaryShaderName)) <
Draw:2169:Direct3D9\D3D9ShaderVariation.cpp:169:    SharedPtr<File> file = cache->GetFile(binaryShaderName);
Draw:2170:Direct3D9\D3D9ShaderVariation.cpp:170:    if (!file || file->ReadFileID() != "USHD")
Draw:2171:Direct3D9\D3D9ShaderVariation.cpp:177:    unsigned short shaderType = file->ReadUShort();
Draw:2172:Direct3D9\D3D9ShaderVariation.cpp:178:    unsigned short shaderModel = file->ReadUShort();
Draw:2173:Direct3D9\D3D9ShaderVariation.cpp:180:    unsigned numParameters = file->ReadUInt();
Draw:2174:Direct3D9\D3D9ShaderVariation.cpp:183:        String name = file->ReadString();
Draw:2175:Direct3D9\D3D9ShaderVariation.cpp:184:        unsigned reg = file->ReadUByte();
Draw:2176:Direct3D9\D3D9ShaderVariation.cpp:185:        unsigned regCount = file->ReadUByte();
Draw:2177:Direct3D9\D3D9ShaderVariation.cpp:191:    unsigned numTextureUnits = file->ReadUInt();
Draw:2178:Direct3D9\D3D9ShaderVariation.cpp:194:        String unitName = file->ReadString();
Draw:2179:Direct3D9\D3D9ShaderVariation.cpp:195:        unsigned reg = file->ReadUByte();
Draw:2180:Direct3D9\D3D9ShaderVariation.cpp:201:    unsigned byteCodeSize = file->ReadUInt();
Draw:2181:Direct3D9\D3D9ShaderVariation.cpp:205:        file->Read(&byteCode[0], byteCodeSize);
Draw:2182:Direct3D9\D3D9ShaderVariation.cpp:223:    const String& sourceCode = owner_->GetSourceCode(type_);
Draw:2183:Direct3D9\D3D9ShaderVariation.cpp:286:    if (FAILED(D3DCompile(sourceCode.CString(), sourceCode.Length(), owner_->GetName().CString(), &macros.Front(), 0,
Draw:2184:Direct3D9\D3D9ShaderVariation.cpp:288:        compilerOutput_ = String((const char*)errorMsgs->GetBufferPointer(), errorMsgs->GetBufferSize());
Draw:2185:Direct3D9\D3D9ShaderVariation.cpp:297:        unsigned char* bufData = (unsigned char*)shaderCode->GetBufferPointer();
Draw:2186:Direct3D9\D3D9ShaderVariation.cpp:298:        unsigned bufSize = shaderCode->GetBufferSize();
Draw:2187:Direct3D9\D3D9ShaderVariation.cpp:304:        shaderCode->Release();
Draw:2188:Direct3D9\D3D9ShaderVariation.cpp:306:        errorMsgs->Release();
Draw:2189:Direct3D9\D3D9ShaderVariation.cpp:315:    for (int i = 0; i < parseData->symbol_count; i++)
Draw:2190:Direct3D9\D3D9ShaderVariation.cpp:317:        MOJOSHADER_symbol const& symbol = parseData->symbols[i];
Draw:2191:Direct3D9\D3D9ShaderVariation.cpp:329:            // Skip if it's a G-buffer sampler, which are aliases for the standard texture units
Draw:2192:Direct3D9\D3D9ShaderVariation.cpp:374:    ResourceCache* cache = owner_->GetSubsystem<ResourceCache>();
Draw:2193:Direct3D9\D3D9ShaderVariation.cpp:375:    FileSystem* fileSystem = owner_->GetSubsystem<FileSystem>();
Draw:2194:Direct3D9\D3D9ShaderVariation.cpp:377:    String path = GetPath(cache->GetResourceFileName(owner_->GetName())) + "Cache/";
Draw:2195:Direct3D9\D3D9ShaderVariation.cpp:379:    if (!fileSystem->DirExists(path))
Draw:2196:Direct3D9\D3D9ShaderVariation.cpp:380:        fileSystem->CreateDir(path);
Draw:2197:Direct3D9\D3D9ShaderVariation.cpp:382:    SharedPtr<File> file(new File(owner_->GetContext(), fullName, FILE_WRITE));
Draw:2198:Direct3D9\D3D9ShaderVariation.cpp:383:    if (!file->IsOpen())
Draw:2199:Direct3D9\D3D9ShaderVariation.cpp:386:    file->WriteFileID("USHD");
Draw:2200:Direct3D9\D3D9ShaderVariation.cpp:387:    file->WriteShort((unsigned short)type_);
Draw:2201:Direct3D9\D3D9ShaderVariation.cpp:388:    file->WriteShort(3);
Draw:2202:Direct3D9\D3D9ShaderVariation.cpp:390:    file->WriteUInt(parameters_.Size());
Draw:2203:Direct3D9\D3D9ShaderVariation.cpp:393:        file->WriteString(i->second_.name_);
Draw:2204:Direct3D9\D3D9ShaderVariation.cpp:394:        file->WriteUByte(i->second_.register_);
Draw:2205:Direct3D9\D3D9ShaderVariation.cpp:395:        file->WriteUByte(i->second_.regCount_);
Draw:2206:Direct3D9\D3D9ShaderVariation.cpp:404:    file->WriteUInt(usedTextureUnits);
Draw:2207:Direct3D9\D3D9ShaderVariation.cpp:409:            file->WriteString(graphics_->GetTextureUnitName((TextureUnit)i));
Draw:2208:Direct3D9\D3D9ShaderVariation.cpp:410:            file->WriteUByte(i);
Draw:2209:Direct3D9\D3D9ShaderVariation.cpp:415:    file->WriteUInt(dataSize);
Draw:2210:Direct3D9\D3D9ShaderVariation.cpp:417:        file->Write(&byteCode[0], dataSize);
Draw:2211:Direct3D9\D3D9Texture.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2212:Direct3D9\D3D9Texture.cpp:74:        mipsToSkip_[i] = MAX_TEXTURE_QUALITY_LEVELS - 1 - i;
Draw:2213:Direct3D9\D3D9Texture.cpp:107:        enable &= graphics_->GetSRGBSupport();
Draw:2214:Direct3D9\D3D9Texture.cpp:126:            if (mipsToSkip_[i] > mipsToSkip_[i - 1])
Draw:2215:Direct3D9\D3D9Texture.cpp:127:                mipsToSkip_[i] = mipsToSkip_[i - 1];
Draw:2216:Direct3D9\D3D9Texture.cpp:241:    XMLElement rootElem = file->GetRoot();
Draw:2217:Direct3D9\D3D9Texture.cpp:257:                TextureCoordinate coordIndex = (TextureCoordinate)(coord[0] - 'u');
Draw:2218:Direct3D9\D3D9Texture.cpp:297:    unsigned textureBudget = cache->GetMemoryBudget(type);
Draw:2219:Direct3D9\D3D9Texture.cpp:298:    unsigned textureUse = cache->GetMemoryUse(type);
Draw:2220:Direct3D9\D3D9Texture.cpp:305:        cache->ReleaseResources(Material::GetTypeStatic());
Draw:2221:Direct3D9\D3D9Texture.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2222:Direct3D9\D3D9Texture.h:53:    /// Set shadow compare mode. No-op on D3D9.
Draw:2223:Direct3D9\D3D9Texture2D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2224:Direct3D9\D3D9Texture2D.h:63:    /// Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.
Draw:2225:Direct3D9\D3D9Texture3D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2226:Direct3D9\D3D9Texture3D.h:62:    /// Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.
Draw:2227:Direct3D9\D3D9Texture2D.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2228:Direct3D9\D3D9Texture2D.cpp:52:    context->RegisterFactory<Texture2D>();
Draw:2229:Direct3D9\D3D9Texture2D.cpp:62:    if (graphics_->IsDeviceLost())
Draw:2230:Direct3D9\D3D9Texture2D.cpp:71:    if (!loadImage_->Load(source))
Draw:2231:Direct3D9\D3D9Texture2D.cpp:79:        loadImage_->PrecalculateLevels();
Draw:2232:Direct3D9\D3D9Texture2D.cpp:84:    loadParameters_ = cache->GetTempResource<XMLFile>(xmlName, false);
Draw:2233:Direct3D9\D3D9Texture2D.cpp:92:    if (!graphics_ || graphics_->IsDeviceLost())
Draw:2234:Direct3D9\D3D9Texture2D.cpp:119:        if (cache->Exists(GetName()))
Draw:2235:Direct3D9\D3D9Texture2D.cpp:120:            dataLost_ = !cache->ReloadResource(this);
Draw:2236:Direct3D9\D3D9Texture2D.cpp:141:            if (graphics_->GetTexture(i) == this)
Draw:2237:Direct3D9\D3D9Texture2D.cpp:142:                graphics_->SetTexture(i, 0);
Draw:2238:Direct3D9\D3D9Texture2D.cpp:146:            renderSurface_->Release();
Draw:2239:Direct3D9\D3D9Texture2D.cpp:148:        ((IDirect3DTexture9*)object_)->Release();
Draw:2240:Direct3D9\D3D9Texture2D.cpp:154:            renderSurface_->Release();
Draw:2241:Direct3D9\D3D9Texture2D.cpp:220:    if (graphics_->IsDeviceLost())
Draw:2242:Direct3D9\D3D9Texture2D.cpp:252:    if (FAILED(((IDirect3DTexture9*)object_)->LockRect(level, &d3dLockedRect, (flags & D3DLOCK_DISCARD) ? 0 : &d3dRect, flags)))
Draw:2243:Direct3D9\D3D9Texture2D.cpp:267:    // GetRowDataSize() returns CPU-side (source) data size, so need to convert for X8R8G8B8
Draw:2244:Direct3D9\D3D9Texture2D.cpp:308:    ((IDirect3DTexture9*)object_)->UnlockRect(level);
Draw:2245:Direct3D9\D3D9Texture2D.cpp:325:        quality = renderer->GetTextureQuality();
Draw:2246:Direct3D9\D3D9Texture2D.cpp:327:    if (!image->IsCompressed())
Draw:2247:Direct3D9\D3D9Texture2D.cpp:329:        unsigned char* levelData = image->GetData();
Draw:2248:Direct3D9\D3D9Texture2D.cpp:330:        int levelWidth = image->GetWidth();
Draw:2249:Direct3D9\D3D9Texture2D.cpp:331:        int levelHeight = image->GetHeight();
Draw:2250:Direct3D9\D3D9Texture2D.cpp:332:        unsigned components = image->GetComponents();
Draw:2251:Direct3D9\D3D9Texture2D.cpp:338:            image = image->GetNextLevel();
Draw:2252:Direct3D9\D3D9Texture2D.cpp:339:            levelData = image->GetData();
Draw:2253:Direct3D9\D3D9Texture2D.cpp:340:            levelWidth = image->GetWidth();
Draw:2254:Direct3D9\D3D9Texture2D.cpp:341:            levelHeight = image->GetHeight();
Draw:2255:Direct3D9\D3D9Texture2D.cpp:373:            if (i < levels_ - 1)
Draw:2256:Direct3D9\D3D9Texture2D.cpp:375:                image = image->GetNextLevel();
Draw:2257:Direct3D9\D3D9Texture2D.cpp:376:                levelData = image->GetData();
Draw:2258:Direct3D9\D3D9Texture2D.cpp:377:                levelWidth = image->GetWidth();
Draw:2259:Direct3D9\D3D9Texture2D.cpp:378:                levelHeight = image->GetHeight();
Draw:2260:Direct3D9\D3D9Texture2D.cpp:384:        int width = image->GetWidth();
Draw:2261:Direct3D9\D3D9Texture2D.cpp:385:        int height = image->GetHeight();
Draw:2262:Direct3D9\D3D9Texture2D.cpp:386:        unsigned levels = image->GetNumCompressedLevels();
Draw:2263:Direct3D9\D3D9Texture2D.cpp:387:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Draw:2264:Direct3D9\D3D9Texture2D.cpp:398:            mipsToSkip = levels - 1;
Draw:2265:Direct3D9\D3D9Texture2D.cpp:400:            --mipsToSkip;
Draw:2266:Direct3D9\D3D9Texture2D.cpp:404:        SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Draw:2267:Direct3D9\D3D9Texture2D.cpp:407:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Draw:2268:Direct3D9\D3D9Texture2D.cpp:409:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Draw:2269:Direct3D9\D3D9Texture2D.cpp:450:    if (graphics_->IsDeviceLost())
Draw:2270:Direct3D9\D3D9Texture2D.cpp:466:    if (FAILED(((IDirect3DTexture9*)object_)->LockRect(level, &d3dLockedRect, &d3dRect, D3DLOCK_READONLY)))
Draw:2271:Direct3D9\D3D9Texture2D.cpp:478:    // GetRowDataSize() returns CPU-side (destination) data size, so need to convert for X8R8G8B8
Draw:2272:Direct3D9\D3D9Texture2D.cpp:519:    ((IDirect3DTexture9*)object_)->UnlockRect(level);
Draw:2273:Direct3D9\D3D9Texture2D.cpp:530:    if (graphics_->IsDeviceLost())
Draw:2274:Direct3D9\D3D9Texture2D.cpp:536:    IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Draw:2275:Direct3D9\D3D9Texture2D.cpp:537:    // If creating a depth-stencil texture, and it is not supported, create a depth-stencil surface instead
Draw:2276:Direct3D9\D3D9Texture2D.cpp:538:    if (usage_ & D3DUSAGE_DEPTHSTENCIL && !graphics_->GetImpl()->CheckFormatSupport((D3DFORMAT)format_, usage_, D3DRTYPE_TEXTURE))
Draw:2277:Direct3D9\D3D9Texture2D.cpp:540:        if (!device || FAILED(device->CreateDepthStencilSurface(
Draw:2278:Direct3D9\D3D9Texture2D.cpp:547:            (IDirect3DSurface9**)&renderSurface_->surface_,
Draw:2279:Direct3D9\D3D9Texture2D.cpp:550:            LOGERROR("Could not create depth-stencil surface");
Draw:2280:Direct3D9\D3D9Texture2D.cpp:558:        if (!device || FAILED(graphics_->GetImpl()->GetDevice()->CreateTexture(
Draw:2281:Direct3D9\D3D9Texture2D.cpp:572:        levels_ = ((IDirect3DTexture9*)object_)->GetLevelCount();
Draw:2282:Direct3D9\D3D9Texture2D.cpp:575:            ((IDirect3DTexture9*)object_)->GetSurfaceLevel(0, (IDirect3DSurface9**)&renderSurface_->surface_);
Draw:2283:Direct3D9\D3D9Texture2D.cpp:583:    if (renderSurface_ && renderSurface_->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Draw:2284:Direct3D9\D3D9Texture2D.cpp:584:        renderSurface_->QueueUpdate();
Draw:2285:Direct3D9\D3D9Texture3D.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2286:Direct3D9\D3D9Texture3D.cpp:52:    context->RegisterFactory<Texture3D>();
Draw:2287:Direct3D9\D3D9Texture3D.cpp:64:    if (graphics_->IsDeviceLost())
Draw:2288:Direct3D9\D3D9Texture3D.cpp:74:    cache->ResetDependencies(this);
Draw:2289:Direct3D9\D3D9Texture3D.cpp:77:    if (!loadParameters_->Load(source))
Draw:2290:Direct3D9\D3D9Texture3D.cpp:83:    XMLElement textureElem = loadParameters_->GetRoot();
Draw:2291:Direct3D9\D3D9Texture3D.cpp:97:        loadImage_ = cache->GetTempResource<Image>(name);
Draw:2292:Direct3D9\D3D9Texture3D.cpp:100:            loadImage_->PrecalculateLevels();
Draw:2293:Direct3D9\D3D9Texture3D.cpp:101:        cache->StoreResourceDependency(this, name);
Draw:2294:Direct3D9\D3D9Texture3D.cpp:114:        SharedPtr<File> file = GetSubsystem<ResourceCache>()->GetFile(name);
Draw:2295:Direct3D9\D3D9Texture3D.cpp:116:        if (!loadImage_->LoadColorLUT(*(file.Get())))
Draw:2296:Direct3D9\D3D9Texture3D.cpp:124:            loadImage_->PrecalculateLevels();
Draw:2297:Direct3D9\D3D9Texture3D.cpp:125:        cache->StoreResourceDependency(this, name);
Draw:2298:Direct3D9\D3D9Texture3D.cpp:136:    if (!graphics_ || graphics_->IsDeviceLost())
Draw:2299:Direct3D9\D3D9Texture3D.cpp:163:        if (cache->Exists(GetName()))
Draw:2300:Direct3D9\D3D9Texture3D.cpp:164:            dataLost_ = !cache->ReloadResource(this);
Draw:2301:Direct3D9\D3D9Texture3D.cpp:185:            if (graphics_->GetTexture(i) == this)
Draw:2302:Direct3D9\D3D9Texture3D.cpp:186:                graphics_->SetTexture(i, 0);
Draw:2303:Direct3D9\D3D9Texture3D.cpp:190:            renderSurface_->Release();
Draw:2304:Direct3D9\D3D9Texture3D.cpp:192:        ((IDirect3DVolumeTexture9*)object_)->Release();
Draw:2305:Direct3D9\D3D9Texture3D.cpp:198:            renderSurface_->Release();
Draw:2306:Direct3D9\D3D9Texture3D.cpp:262:    if (graphics_->IsDeviceLost())
Draw:2307:Direct3D9\D3D9Texture3D.cpp:297:    if (FAILED(((IDirect3DVolumeTexture9*)object_)->LockBox(level, &d3dLockedBox, (flags & D3DLOCK_DISCARD) ? 0 : &d3dBox, flags)))
Draw:2308:Direct3D9\D3D9Texture3D.cpp:312:    // GetRowDataSize() returns CPU-side (source) data size, so need to convert for X8R8G8B8
Draw:2309:Direct3D9\D3D9Texture3D.cpp:362:    ((IDirect3DVolumeTexture9*)object_)->UnlockBox(level);
Draw:2310:Direct3D9\D3D9Texture3D.cpp:379:        quality = renderer->GetTextureQuality();
Draw:2311:Direct3D9\D3D9Texture3D.cpp:381:    if (!image->IsCompressed())
Draw:2312:Direct3D9\D3D9Texture3D.cpp:383:        unsigned char* levelData = image->GetData();
Draw:2313:Direct3D9\D3D9Texture3D.cpp:384:        int levelWidth = image->GetWidth();
Draw:2314:Direct3D9\D3D9Texture3D.cpp:385:        int levelHeight = image->GetHeight();
Draw:2315:Direct3D9\D3D9Texture3D.cpp:386:        int levelDepth = image->GetDepth();
Draw:2316:Direct3D9\D3D9Texture3D.cpp:387:        unsigned components = image->GetComponents();
Draw:2317:Direct3D9\D3D9Texture3D.cpp:393:            image = image->GetNextLevel();
Draw:2318:Direct3D9\D3D9Texture3D.cpp:394:            levelData = image->GetData();
Draw:2319:Direct3D9\D3D9Texture3D.cpp:395:            levelWidth = image->GetWidth();
Draw:2320:Direct3D9\D3D9Texture3D.cpp:396:            levelHeight = image->GetHeight();
Draw:2321:Direct3D9\D3D9Texture3D.cpp:397:            levelDepth = image->GetDepth();
Draw:2322:Direct3D9\D3D9Texture3D.cpp:429:            if (i < levels_ - 1)
Draw:2323:Direct3D9\D3D9Texture3D.cpp:431:                image = image->GetNextLevel();
Draw:2324:Direct3D9\D3D9Texture3D.cpp:432:                levelData = image->GetData();
Draw:2325:Direct3D9\D3D9Texture3D.cpp:433:                levelWidth = image->GetWidth();
Draw:2326:Direct3D9\D3D9Texture3D.cpp:434:                levelHeight = image->GetHeight();
Draw:2327:Direct3D9\D3D9Texture3D.cpp:435:                levelDepth = image->GetDepth();
Draw:2328:Direct3D9\D3D9Texture3D.cpp:441:        int width = image->GetWidth();
Draw:2329:Direct3D9\D3D9Texture3D.cpp:442:        int height = image->GetHeight();
Draw:2330:Direct3D9\D3D9Texture3D.cpp:443:        int depth = image->GetDepth();
Draw:2331:Direct3D9\D3D9Texture3D.cpp:444:        unsigned levels = image->GetNumCompressedLevels();
Draw:2332:Direct3D9\D3D9Texture3D.cpp:445:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Draw:2333:Direct3D9\D3D9Texture3D.cpp:456:            mipsToSkip = levels - 1;
Draw:2334:Direct3D9\D3D9Texture3D.cpp:458:            --mipsToSkip;
Draw:2335:Direct3D9\D3D9Texture3D.cpp:463:        SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Draw:2336:Direct3D9\D3D9Texture3D.cpp:466:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Draw:2337:Direct3D9\D3D9Texture3D.cpp:468:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Draw:2338:Direct3D9\D3D9Texture3D.cpp:509:    if (graphics_->IsDeviceLost())
Draw:2339:Direct3D9\D3D9Texture3D.cpp:528:    if (FAILED(((IDirect3DVolumeTexture9*)object_)->LockBox(level, &d3dLockedBox, &d3dBox, D3DLOCK_READONLY)))
Draw:2340:Direct3D9\D3D9Texture3D.cpp:540:    // GetRowDataSize() returns CPU-side (destination) data size, so need to convert for X8R8G8B8
Draw:2341:Direct3D9\D3D9Texture3D.cpp:590:    ((IDirect3DVolumeTexture9*)object_)->UnlockBox(level);
Draw:2342:Direct3D9\D3D9Texture3D.cpp:601:    if (graphics_->IsDeviceLost())
Draw:2343:Direct3D9\D3D9Texture3D.cpp:607:    IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Draw:2344:Direct3D9\D3D9Texture3D.cpp:609:    if (!device || FAILED(graphics_->GetImpl()->GetDevice()->CreateVolumeTexture(
Draw:2345:Direct3D9\D3D9Texture3D.cpp:624:    levels_ = ((IDirect3DVolumeTexture9*)object_)->GetLevelCount();
Draw:2346:Direct3D9\D3D9Texture3D.cpp:631:    if (renderSurface_ && renderSurface_->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Draw:2347:Direct3D9\D3D9Texture3D.cpp:632:        renderSurface_->QueueUpdate();
Draw:2348:Direct3D9\D3D9TextureCube.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2349:Direct3D9\D3D9TextureCube.h:65:    /// Set data of one face from an image. Return true if successful. Optionally make a single channel image alpha-only.
Draw:2350:Direct3D9\D3D9TextureCube.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2351:Direct3D9\D3D9TextureCube.cpp:55:    return SharedPtr<Image>(src->GetSubimage(IntRect(tileX * tileWidth, tileY * tileHeight, (tileX + 1) * tileWidth, (tileY + 1) * tileHeight)));
Draw:2352:Direct3D9\D3D9TextureCube.cpp:60:    lockedLevel_(-1)
Draw:2353:Direct3D9\D3D9TextureCube.cpp:78:    context->RegisterFactory<TextureCube>();
Draw:2354:Direct3D9\D3D9TextureCube.cpp:90:    if (graphics_->IsDeviceLost())
Draw:2355:Direct3D9\D3D9TextureCube.cpp:97:    cache->ResetDependencies(this);
Draw:2356:Direct3D9\D3D9TextureCube.cpp:103:    if (!loadParameters_->Load(source))
Draw:2357:Direct3D9\D3D9TextureCube.cpp:111:    XMLElement textureElem = loadParameters_->GetRoot();
Draw:2358:Direct3D9\D3D9TextureCube.cpp:122:        SharedPtr<Image> image = cache->GetTempResource<Image>(name);
Draw:2359:Direct3D9\D3D9TextureCube.cpp:132:            faceWidth = image->GetWidth() / MAX_CUBEMAP_FACES;
Draw:2360:Direct3D9\D3D9TextureCube.cpp:133:            faceHeight = image->GetHeight();
Draw:2361:Direct3D9\D3D9TextureCube.cpp:143:            faceWidth = image->GetWidth() / MAX_CUBEMAP_FACES;
Draw:2362:Direct3D9\D3D9TextureCube.cpp:144:            faceHeight = image->GetHeight();
Draw:2363:Direct3D9\D3D9TextureCube.cpp:150:            faceWidth = image->GetWidth() / 4;
Draw:2364:Direct3D9\D3D9TextureCube.cpp:151:            faceHeight = image->GetHeight() / 3;
Draw:2365:Direct3D9\D3D9TextureCube.cpp:161:            faceWidth = image->GetWidth() / 3;
Draw:2366:Direct3D9\D3D9TextureCube.cpp:162:            faceHeight = image->GetHeight() / 4;
Draw:2367:Direct3D9\D3D9TextureCube.cpp:171:                loadImages_[FACE_NEGATIVE_Z]->FlipVertical();
Draw:2368:Direct3D9\D3D9TextureCube.cpp:172:                loadImages_[FACE_NEGATIVE_Z]->FlipHorizontal();
Draw:2369:Direct3D9\D3D9TextureCube.cpp:177:            faceWidth = image->GetWidth() / 3;
Draw:2370:Direct3D9\D3D9TextureCube.cpp:178:            faceHeight = image->GetHeight() / 2;
Draw:2371:Direct3D9\D3D9TextureCube.cpp:200:            loadImages_.Push(cache->GetTempResource<Image>(name));
Draw:2372:Direct3D9\D3D9TextureCube.cpp:201:            cache->StoreResourceDependency(this, name);
Draw:2373:Direct3D9\D3D9TextureCube.cpp:213:                loadImages_[i]->PrecalculateLevels();
Draw:2374:Direct3D9\D3D9TextureCube.cpp:223:    if (!graphics_ || graphics_->IsDeviceLost())
Draw:2375:Direct3D9\D3D9TextureCube.cpp:252:        if (cache->Exists(GetName()))
Draw:2376:Direct3D9\D3D9TextureCube.cpp:253:            dataLost_ = !cache->ReloadResource(this);
Draw:2377:Direct3D9\D3D9TextureCube.cpp:274:            if (graphics_->GetTexture(i) == this)
Draw:2378:Direct3D9\D3D9TextureCube.cpp:275:                graphics_->SetTexture(i, 0);
Draw:2379:Direct3D9\D3D9TextureCube.cpp:281:                renderSurfaces_[i]->Release();
Draw:2380:Direct3D9\D3D9TextureCube.cpp:284:        ((IDirect3DCubeTexture9*)object_)->Release();
Draw:2381:Direct3D9\D3D9TextureCube.cpp:298:        LOGERROR("Depth-stencil usage not supported for cube maps");
Draw:2382:Direct3D9\D3D9TextureCube.cpp:364:    if (graphics_->IsDeviceLost())
Draw:2383:Direct3D9\D3D9TextureCube.cpp:396:    if (FAILED(((IDirect3DCubeTexture9*)object_)->LockRect((D3DCUBEMAP_FACES)face, level, &d3dLockedRect, (flags &
Draw:2384:Direct3D9\D3D9TextureCube.cpp:412:    // GetRowDataSize() returns CPU-side (source) data size, so need to convert for X8R8G8B8
Draw:2385:Direct3D9\D3D9TextureCube.cpp:453:    ((IDirect3DCubeTexture9*)object_)->UnlockRect((D3DCUBEMAP_FACES)face, level);
Draw:2386:Direct3D9\D3D9TextureCube.cpp:460:    if (!image->Load(source))
Draw:2387:Direct3D9\D3D9TextureCube.cpp:479:        quality = renderer->GetTextureQuality();
Draw:2388:Direct3D9\D3D9TextureCube.cpp:481:    if (!image->IsCompressed())
Draw:2389:Direct3D9\D3D9TextureCube.cpp:483:        unsigned char* levelData = image->GetData();
Draw:2390:Direct3D9\D3D9TextureCube.cpp:484:        int levelWidth = image->GetWidth();
Draw:2391:Direct3D9\D3D9TextureCube.cpp:485:        int levelHeight = image->GetHeight();
Draw:2392:Direct3D9\D3D9TextureCube.cpp:486:        unsigned components = image->GetComponents();
Draw:2393:Direct3D9\D3D9TextureCube.cpp:498:            image = image->GetNextLevel();
Draw:2394:Direct3D9\D3D9TextureCube.cpp:499:            levelData = image->GetData();
Draw:2395:Direct3D9\D3D9TextureCube.cpp:500:            levelWidth = image->GetWidth();
Draw:2396:Direct3D9\D3D9TextureCube.cpp:501:            levelHeight = image->GetHeight();
Draw:2397:Direct3D9\D3D9TextureCube.cpp:550:            if (i < levels_ - 1)
Draw:2398:Direct3D9\D3D9TextureCube.cpp:552:                image = image->GetNextLevel();
Draw:2399:Direct3D9\D3D9TextureCube.cpp:553:                levelData = image->GetData();
Draw:2400:Direct3D9\D3D9TextureCube.cpp:554:                levelWidth = image->GetWidth();
Draw:2401:Direct3D9\D3D9TextureCube.cpp:555:                levelHeight = image->GetHeight();
Draw:2402:Direct3D9\D3D9TextureCube.cpp:561:        int width = image->GetWidth();
Draw:2403:Direct3D9\D3D9TextureCube.cpp:562:        int height = image->GetHeight();
Draw:2404:Direct3D9\D3D9TextureCube.cpp:563:        unsigned levels = image->GetNumCompressedLevels();
Draw:2405:Direct3D9\D3D9TextureCube.cpp:564:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
Draw:2406:Direct3D9\D3D9TextureCube.cpp:581:            mipsToSkip = levels - 1;
Draw:2407:Direct3D9\D3D9TextureCube.cpp:583:            --mipsToSkip;
Draw:2408:Direct3D9\D3D9TextureCube.cpp:590:            SetNumLevels(Max((int)(levels - mipsToSkip), 1));
Draw:2409:Direct3D9\D3D9TextureCube.cpp:607:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
Draw:2410:Direct3D9\D3D9TextureCube.cpp:609:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
Draw:2411:Direct3D9\D3D9TextureCube.cpp:655:    if (graphics_->IsDeviceLost())
Draw:2412:Direct3D9\D3D9TextureCube.cpp:671:    if (FAILED(((IDirect3DCubeTexture9*)object_)->LockRect((D3DCUBEMAP_FACES)face, level, &d3dLockedRect, &d3dRect, D3DLOCK_READONLY)))
Draw:2413:Direct3D9\D3D9TextureCube.cpp:683:    // GetRowDataSize() returns CPU-side (destination) data size, so need to convert for X8R8G8B8
Draw:2414:Direct3D9\D3D9TextureCube.cpp:724:    ((IDirect3DCubeTexture9*)object_)->UnlockRect((D3DCUBEMAP_FACES)face, level);
Draw:2415:Direct3D9\D3D9TextureCube.cpp:735:    if (graphics_->IsDeviceLost())
Draw:2416:Direct3D9\D3D9TextureCube.cpp:741:    IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Draw:2417:Direct3D9\D3D9TextureCube.cpp:742:    if (!device || FAILED(device->CreateCubeTexture(
Draw:2418:Direct3D9\D3D9TextureCube.cpp:755:    levels_ = ((IDirect3DCubeTexture9*)object_)->GetLevelCount();
Draw:2419:Direct3D9\D3D9TextureCube.cpp:761:            ((IDirect3DCubeTexture9*)object_)->GetCubeMapSurface((D3DCUBEMAP_FACES)i, 0,
Draw:2420:Direct3D9\D3D9TextureCube.cpp:762:                (IDirect3DSurface9**)&renderSurfaces_[i]->surface_);
Draw:2421:Direct3D9\D3D9TextureCube.cpp:773:        if (renderSurfaces_[i] && renderSurfaces_[i]->GetUpdateMode() == SURFACE_UPDATEALWAYS)
Draw:2422:Direct3D9\D3D9TextureCube.cpp:774:            renderSurfaces_[i]->QueueUpdate();
Draw:2423:Direct3D9\D3D9VertexBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2424:Direct3D9\D3D9VertexBuffer.cpp:105:            if (graphics_->GetVertexBuffer(i) == this)
Draw:2425:Direct3D9\D3D9VertexBuffer.cpp:106:                graphics_->SetVertexBuffer(0);
Draw:2426:Direct3D9\D3D9VertexBuffer.cpp:109:        ((IDirect3DVertexBuffer9*)object_)->Release();
Draw:2427:Direct3D9\D3D9VertexBuffer.cpp:178:        if (graphics_->IsDeviceLost())
Draw:2428:Direct3D9\D3D9VertexBuffer.cpp:230:        if (graphics_->IsDeviceLost())
Draw:2429:Direct3D9\D3D9VertexBuffer.cpp:277:    if (object_ && !shadowData_ && !graphics_->IsDeviceLost())
Draw:2430:Direct3D9\D3D9VertexBuffer.cpp:287:        lockScratchData_ = graphics_->ReserveScratchBuffer(count * vertexSize_);
Draw:2431:Direct3D9\D3D9VertexBuffer.cpp:310:            graphics_->FreeScratchBuffer(lockScratchData_);
Draw:2432:Direct3D9\D3D9VertexBuffer.cpp:391:        if (graphics_->IsDeviceLost())
Draw:2433:Direct3D9\D3D9VertexBuffer.cpp:397:        IDirect3DDevice9* device = graphics_->GetImpl()->GetDevice();
Draw:2434:Direct3D9\D3D9VertexBuffer.cpp:398:        if (!device || FAILED(device->CreateVertexBuffer(
Draw:2435:Direct3D9\D3D9VertexBuffer.cpp:433:        if (FAILED(((IDirect3DVertexBuffer9*)object_)->Lock(start * vertexSize_, count * vertexSize_, &hwData, flags)))
Draw:2436:Direct3D9\D3D9VertexBuffer.cpp:446:        ((IDirect3DVertexBuffer9*)object_)->Unlock();
Draw:2437:Direct3D9\D3D9VertexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2438:Direct3D9\D3D9VertexBuffer.h:58:    /// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
Draw:2439:Direct3D9\D3D9VertexDeclaration.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2440:Direct3D9\D3D9VertexDeclaration.cpp:122:                elementMask = buffers[i]->GetElementMask();
Draw:2441:Direct3D9\D3D9VertexDeclaration.cpp:125:                if ((buffers[i]->GetElementMask() & elementMask) != elementMask)
Draw:2442:Direct3D9\D3D9VertexDeclaration.cpp:138:                    newElement.offset_ = buffers[i]->GetElementOffset(element);
Draw:2443:Direct3D9\D3D9VertexDeclaration.cpp:163:                elementMask = buffers[i]->GetElementMask();
Draw:2444:Direct3D9\D3D9VertexDeclaration.cpp:166:                if ((buffers[i]->GetElementMask() & elementMask) != elementMask)
Draw:2445:Direct3D9\D3D9VertexDeclaration.cpp:179:                    newElement.offset_ = buffers[i]->GetElementOffset(element);
Draw:2446:Direct3D9\D3D9VertexDeclaration.cpp:203:        dest->Stream = i->stream_;
Draw:2447:Direct3D9\D3D9VertexDeclaration.cpp:204:        dest->Offset = i->offset_;
Draw:2448:Direct3D9\D3D9VertexDeclaration.cpp:205:        dest->Type = d3dElementType[i->element_];
Draw:2449:Direct3D9\D3D9VertexDeclaration.cpp:206:        dest->Method = D3DDECLMETHOD_DEFAULT;
Draw:2450:Direct3D9\D3D9VertexDeclaration.cpp:207:        dest->Usage = d3dElementUsage[i->element_];
Draw:2451:Direct3D9\D3D9VertexDeclaration.cpp:208:        dest->UsageIndex = d3dElementUsageIndex[i->element_];
Draw:2452:Direct3D9\D3D9VertexDeclaration.cpp:212:    dest->Stream = 0xff;
Draw:2453:Direct3D9\D3D9VertexDeclaration.cpp:213:    dest->Offset = 0;
Draw:2454:Direct3D9\D3D9VertexDeclaration.cpp:214:    dest->Type = D3DDECLTYPE_UNUSED;
Draw:2455:Direct3D9\D3D9VertexDeclaration.cpp:215:    dest->Method = 0;
Draw:2456:Direct3D9\D3D9VertexDeclaration.cpp:216:    dest->Usage = 0;
Draw:2457:Direct3D9\D3D9VertexDeclaration.cpp:217:    dest->UsageIndex = 0;
Draw:2458:Direct3D9\D3D9VertexDeclaration.cpp:219:    IDirect3DDevice9* device = graphics->GetImpl()->GetDevice();
Draw:2459:Direct3D9\D3D9VertexDeclaration.cpp:223:    device->CreateVertexDeclaration(elementArray, &declaration_);
Draw:2460:Direct3D9\D3D9VertexDeclaration.cpp:230:        declaration_->Release();
Draw:2461:Direct3D9\D3D9VertexDeclaration.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2462:Drawable.cpp:3:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2463:Drawable.cpp:116:        result.normal_ = -query.ray_.direction_;
Draw:2464:Drawable.cpp:132:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
Draw:2465:Drawable.cpp:133:    distance_ = frame.camera_->GetDistance(worldBoundingBox.Center());
Draw:2466:Drawable.cpp:142:    float newLodDistance = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
Draw:2467:Drawable.cpp:169:        debug->AddBoundingBox(GetWorldBoundingBox(), Color::GREEN, depthTest);
Draw:2468:Drawable.cpp:241:            octant_->GetRoot()->QueueUpdate(this);
Draw:2469:Drawable.cpp:249:        octant_->GetRoot()->QueueUpdate(this);
Draw:2470:Drawable.cpp:268:    return renderer && viewFrameNumber_ == renderer->GetFrameInfo().frameNumber_ && !viewCameras_.Empty();
Draw:2471:Drawable.cpp:274:    return renderer && viewFrameNumber_ == renderer->GetFrameInfo().frameNumber_ && (!camera || viewCameras_.Contains(camera));
Draw:2472:Drawable.cpp:286:    // If the zone assignment was temporary (inconclusive) set the dirty flag so that it will be re-evaluated on the next frame
Draw:2473:Drawable.cpp:330:        lights_[i]->SetIntensitySortValue(box);
Draw:2474:Drawable.cpp:341:        for (unsigned i = vertexLights_.Size() - 1; i < vertexLights_.Size(); --i)
Draw:2475:Drawable.cpp:343:            if (!vertexLights_[i]->GetPerVertex())
Draw:2476:Drawable.cpp:353:        vertexLights_[i]->SetIntensitySortValue(box);
Draw:2477:Drawable.cpp:364:        node->AddListener(this);
Draw:2478:Drawable.cpp:374:        octant_->GetRoot()->QueueUpdate(this);
Draw:2479:Drawable.cpp:390:        Octree* octree = scene->GetComponent<Octree>();
Draw:2480:Drawable.cpp:392:            octree->InsertDrawable(this);
Draw:2481:Drawable.cpp:407:        Octree* octree = octant_->GetRoot();
Draw:2482:Drawable.cpp:409:            octree->CancelUpdate(this);
Draw:2483:Drawable.cpp:414:        octant_->RemoveDrawable(this);
Draw:2484:Drawable.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2485:Drawable.h:121:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
Draw:2486:Drawable.h:150:    /// Set maximum number of per-pixel lights. Default 0 is unlimited.
Draw:2487:Drawable.h:163:    /// Return world-space bounding box.
Draw:2488:Drawable.h:181:    /// Return maximum number of per-pixel lights.
Draw:2489:Drawable.h:196:    /// Set new zone. Zone assignment may optionally be temporary, meaning it needs to be re-evaluated on the next frame.
Draw:2490:Drawable.h:200:    /// Set view-space depth bounds.
Draw:2491:Drawable.h:206:    /// Sort and limit per-pixel lights to maximum allowed. Convert extra lights into vertex lights.
Draw:2492:Drawable.h:208:    /// Sort and limit per-vertex lights to maximum allowed.
Draw:2493:Drawable.h:228:    /// Return per-pixel lights.
Draw:2494:Drawable.h:230:    /// Return per-vertex lights.
Draw:2495:Drawable.h:232:    /// Return the first added per-pixel light.
Draw:2496:Drawable.h:234:    /// Return the minimum view-space depth.
Draw:2497:Drawable.h:236:    /// Return the maximum view-space depth.
Draw:2498:Drawable.h:239:    // Add a per-pixel light affecting the object this frame.
Draw:2499:Drawable.h:245:        // Need to store into the light list only if the per-pixel lights are being limited.
Draw:2500:Drawable.h:251:    // Add a per-vertex light affecting the object this frame.
Draw:2501:Drawable.h:262:    /// Recalculate the world-space bounding box.
Draw:2502:Drawable.h:273:    /// World-space bounding box.
Draw:2503:Drawable.h:275:    /// Local-space bounding box.
Draw:2504:Drawable.h:325:    /// Maximum per-pixel lights.
Draw:2505:Drawable.h:329:    /// First per-pixel light added this frame.
Draw:2506:Drawable.h:331:    /// Per-pixel lights affecting this drawable.
Draw:2507:Drawable.h:333:    /// Per-vertex lights affecting this drawable.
Draw:2508:Drawable.h:339:    return lhs->GetSortValue() < rhs->GetSortValue();
Draw:2509:DrawableEvents.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2510:DrawableEvents.h:42:    PARAM(P_DATA, Data);                    // User-defined data type
Draw:2511:Geometry.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2512:Geometry.cpp:87:            elementMasks_[index] = buffer->GetElementMask();
Draw:2513:Geometry.cpp:108:    if (indexBuffer_ && indexStart + indexCount > indexBuffer_->GetIndexCount())
Draw:2514:Geometry.cpp:110:        LOGERROR("Illegal draw range " + String(indexStart) + " to " + String(indexStart + indexCount - 1) + ", index buffer has " +
Draw:2515:Geometry.cpp:111:            String(indexBuffer_->GetIndexCount()) + " indices");
Draw:2516:Geometry.cpp:123:        vertexCount_ = vertexBuffers_[0] ? vertexBuffers_[0]->GetVertexCount() : 0;
Draw:2517:Geometry.cpp:126:            indexBuffer_->GetUsedVertexRange(indexStart_, indexCount_, vertexStart_, vertexCount_);
Draw:2518:Geometry.cpp:142:        if (checkIllegal && indexStart + indexCount > indexBuffer_->GetIndexCount())
Draw:2519:Geometry.cpp:144:            LOGERROR("Illegal draw range " + String(indexStart) + " to " + String(indexStart + indexCount - 1) +
Draw:2520:Geometry.cpp:145:                ", index buffer has " + String(indexBuffer_->GetIndexCount()) + " indices");
Draw:2521:Geometry.cpp:189:        graphics->SetIndexBuffer(indexBuffer_);
Draw:2522:Geometry.cpp:190:        graphics->SetVertexBuffers(vertexBuffers_, elementMasks_);
Draw:2523:Geometry.cpp:191:        graphics->Draw(primitiveType_, indexStart_, indexCount_, vertexStart_, vertexCount_);
Draw:2524:Geometry.cpp:195:        graphics->SetVertexBuffers(vertexBuffers_, elementMasks_);
Draw:2525:Geometry.cpp:196:        graphics->Draw(primitiveType_, vertexStart_, vertexCount_);
Draw:2526:Geometry.cpp:239:            vertexData = vertexBuffers_[positionBufferIndex_]->GetShadowData();
Draw:2527:Geometry.cpp:242:                vertexSize = vertexBuffers_[positionBufferIndex_]->GetVertexSize();
Draw:2528:Geometry.cpp:243:                elementMask = vertexBuffers_[positionBufferIndex_]->GetElementMask();
Draw:2529:Geometry.cpp:268:            indexData = indexBuffer_->GetShadowData();
Draw:2530:Geometry.cpp:270:                indexSize = indexBuffer_->GetIndexSize();
Draw:2531:Geometry.cpp:295:            vertexData = vertexBuffers_[positionBufferIndex_]->GetShadowDataShared();
Draw:2532:Geometry.cpp:298:                vertexSize = vertexBuffers_[positionBufferIndex_]->GetVertexSize();
Draw:2533:Geometry.cpp:299:                elementMask = vertexBuffers_[positionBufferIndex_]->GetElementMask();
Draw:2534:Geometry.cpp:324:            indexData = indexBuffer_->GetShadowDataShared();
Draw:2535:Geometry.cpp:326:                indexSize = indexBuffer_->GetIndexSize();
Draw:2536:Geometry.cpp:378:        if (vertexBuffers_[i] && vertexBuffers_[i]->GetElementMask() & MASK_POSITION)
Draw:2537:GPUObject.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2538:Geometry.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2539:Geometry.h:60:    /// Override raw vertex data to be returned for CPU-side operations.
Draw:2540:Geometry.h:62:    /// Override raw index data to be returned for CPU-side operations.
Draw:2541:Graphics.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2542:GraphicsDefs.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2543:GraphicsDefs.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2544:GraphicsDefs.h:33:/// Graphics capability support level. HTML5 (Emscripten) also uses OpenGL ES, but is considered a desktop platform capability-wise
Draw:2545:GraphicsEvents.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2546:GraphicsImpl.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2547:IndexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2548:Light.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2549:Light.h:111:    /// The point relative to the total shadow range where shadow fade begins (0.0 - 1.0)
Draw:2550:Light.h:140:    /// Non-uniform focusing flag.
Draw:2551:Light.h:142:    /// Auto-size (reduce resolution when far away) flag.
Draw:2552:Light.h:167:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
Draw:2553:Light.h:190:    /// Set shadow fade out start distance. Only has effect if shadow distance is also non-zero.
Draw:2554:Light.h:198:    /// Set shadow intensity between 0.0 - 1.0. 0.0 (the default) gives fully dark shadows.
Draw:2555:Light.h:200:    /// Set shadow resolution between 0.25 - 1.0. Determines the shadow map to use.
Draw:2556:Light.h:279:    /// Recalculate the world-space bounding box.
Draw:2557:Light.h:321:    /// Per-vertex lighting flag.
Draw:2558:Light.h:327:    // When sorting lights, give priority to per-vertex lights, so that vertex lit base pass can be evaluated first
Draw:2559:Light.h:328:    if (lhs->GetPerVertex() != rhs->GetPerVertex())
Draw:2560:Light.h:329:        return lhs->GetPerVertex();
Draw:2561:Light.h:331:        return lhs->GetSortValue() < rhs->GetSortValue();
Draw:2562:Material.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2563:Material.cpp:114:            unit = (TextureUnit)Clamp(ToInt(name), 0, MAX_TEXTURE_UNITS - 1);
Draw:2564:Material.cpp:168:    static_cast<Material*>(target_.Get())->SetShaderParameter(name_, newValue);
Draw:2565:Material.cpp:189:    context->RegisterFactory<Material>();
Draw:2566:Material.cpp:200:    if (loadXMLFile_->Load(source))
Draw:2567:Material.cpp:207:            XMLElement rootElem = loadXMLFile_->GetRoot();
Draw:2568:Material.cpp:211:                cache->BackgroundLoadResource<Technique>(techniqueElem.GetAttribute("name"), true, this);
Draw:2569:Material.cpp:228:                        cache->BackgroundLoadResource<Texture3D>(name, true, this);
Draw:2570:Material.cpp:231:                        cache->BackgroundLoadResource<TextureCube>(name, true, this);
Draw:2571:Material.cpp:234:                    cache->BackgroundLoadResource<Texture2D>(name, true, this);
Draw:2572:Material.cpp:260:        XMLElement rootElem = loadXMLFile_->GetRoot();
Draw:2573:Material.cpp:272:    XMLElement materialElem = xml->CreateRoot("material");
Draw:2574:Material.cpp:275:    return xml->Save(dest);
Draw:2575:Material.cpp:295:        Technique* tech = cache->GetResource<Technique>(techniqueElem.GetAttribute("name"));
Draw:2576:Material.cpp:327:                    SetTexture(unit, cache->GetResource<Texture3D>(name));
Draw:2577:Material.cpp:330:                    SetTexture(unit, cache->GetResource<TextureCube>(name));
Draw:2578:Material.cpp:333:                SetTexture(unit, cache->GetResource<Texture2D>(name));
Draw:2579:Material.cpp:353:        if (!animation->LoadXML(parameterAnimationElem))
Draw:2580:Material.cpp:414:        techniqueElem.SetString("name", entry.technique_->GetName());
Draw:2581:Material.cpp:427:            textureElem.SetString("name", texture->GetName());
Draw:2582:Material.cpp:435:        parameterElem.SetString("name", j->second_.name_);
Draw:2583:Material.cpp:436:        parameterElem.SetVectorVariant("value", j->second_.value_);
Draw:2584:Material.cpp:442:        ShaderParameterAnimationInfo* info = j->second_;
Draw:2585:Material.cpp:444:        parameterAnimationElem.SetString("name", info->GetName());
Draw:2586:Material.cpp:445:        if (!info->GetAnimation()->SaveXML(parameterAnimationElem))
Draw:2587:Material.cpp:448:        parameterAnimationElem.SetAttribute("wrapmode", wrapModeNames[info->GetWrapMode()]);
Draw:2588:Material.cpp:449:        parameterAnimationElem.SetFloat("speed", info->GetSpeed());
Draw:2589:Material.cpp:525:        if (info && info->GetAnimation() == animation)
Draw:2590:Material.cpp:527:            info->SetWrapMode(wrapMode);
Draw:2591:Material.cpp:528:            info->SetSpeed(speed);
Draw:2592:Material.cpp:557:        info->SetWrapMode(wrapMode);
Draw:2593:Material.cpp:564:        info->SetSpeed(speed);
Draw:2594:Material.cpp:583:    transform.m03_ = -0.5f * transform.m00_ + 0.5f;
Draw:2595:Material.cpp:584:    transform.m13_ = -0.5f * transform.m11_ + 0.5f;
Draw:2596:Material.cpp:589:    rotationMatrix.m10_ = -rotationMatrix.m01_;
Draw:2597:Material.cpp:591:    rotationMatrix.m03_ = 0.5f - 0.5f * (rotationMatrix.m00_ + rotationMatrix.m01_);
Draw:2598:Material.cpp:592:    rotationMatrix.m13_ = 0.5f - 0.5f * (rotationMatrix.m10_ + rotationMatrix.m11_);
Draw:2599:Material.cpp:659:            tech->ReleaseShaders();
Draw:2600:Material.cpp:667:    ret->SetName(cloneName);
Draw:2601:Material.cpp:668:    ret->techniques_ = techniques_;
Draw:2602:Material.cpp:669:    ret->shaderParameters_ = shaderParameters_;
Draw:2603:Material.cpp:670:    ret->textures_ = textures_;
Draw:2604:Material.cpp:671:    ret->occlusion_ = occlusion_;
Draw:2605:Material.cpp:672:    ret->specular_ = specular_;
Draw:2606:Material.cpp:673:    ret->cullMode_ = cullMode_;
Draw:2607:Material.cpp:674:    ret->shadowCullMode_ = shadowCullMode_;
Draw:2608:Material.cpp:675:    ret->fillMode_ = fillMode_;
Draw:2609:Material.cpp:676:    ret->RefreshMemoryUse();
Draw:2610:Material.cpp:704:    return tech ? tech->GetPass(passName) : 0;
Draw:2611:Material.cpp:710:    return i != textures_.End() ? i->second_.Get() : (Texture*)0;
Draw:2612:Material.cpp:716:    return i != shaderParameters_.End() ? i->second_.value_ : Variant::EMPTY;
Draw:2613:Material.cpp:722:    return info == 0 ? 0 : info->GetAnimation();
Draw:2614:Material.cpp:728:    return info == 0 ? WM_LOOP : info->GetWrapMode();
Draw:2615:Material.cpp:734:    return info == 0 ? 0 : info->GetSpeed();
Draw:2616:Material.cpp:765:            Pass* pass = tech->GetPass("base");
Draw:2617:Material.cpp:766:            if (pass && pass->GetDepthWrite() && !pass->GetAlphaMask())
Draw:2618:Material.cpp:774:    // Needs to be a no-op when async loading, as this does a GetResource() which is not allowed from worker threads
Draw:2619:Material.cpp:779:    SetTechnique(0, GetSubsystem<ResourceCache>()->GetResource<Technique>("Techniques/NoTexture.xml"));
Draw:2620:Material.cpp:807:        temp.WriteStringHash(i->first_);
Draw:2621:Material.cpp:808:        temp.WriteVariant(i->second_.value_);
Draw:2622:Material.cpp:835:    return i->second_;
Draw:2623:Material.cpp:864:        if (i->second_->Update(timeStep))
Draw:2624:Material.cpp:865:            finishedNames.Push(i->second_->GetName());
Draw:2625:Material.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2626:Material.h:207:    /// Parse a shader parameter value from a string. Retunrs either a bool, a float, or a 2 to 4-component vector.
Draw:2627:Material.h:211:    /// Re-evaluate occlusion rendering.
Draw:2628:Model.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2629:Model.h:127:    /// Set local-space bounding box.
Draw:2630:Model.h:147:    /// Clone the model. The geometry data is deep-copied and can be modified in the clone without affecting the original.
Draw:2631:OcclusionBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2632:OcclusionBuffer.h:81:    /// Draw a triangle mesh to the buffer using non-indexed geometry.
Draw:2633:Light.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2634:Light.cpp:66:    constantBias_ = Clamp(constantBias_, -1.0f, 1.0f);
Draw:2635:Light.cpp:67:    slopeScaledBias_ = Clamp(slopeScaledBias_, -16.0f, 16.0f);
Draw:2636:Light.cpp:110:    context->RegisterFactory<Light>(SCENE_CATEGORY);
Draw:2637:Light.cpp:132:    ATTRIBUTE("Non-uniform View", bool, shadowFocus_.nonUniform_, true, AM_DEFAULT);
Draw:2638:Light.cpp:133:    ATTRIBUTE("Auto-Reduce Size", bool, shadowFocus_.autoSize_, true, AM_DEFAULT);
Draw:2639:Light.cpp:174:            Matrix3x4 inverse(node_->GetWorldTransform().Inverse());
Draw:2640:Light.cpp:191:            distance = query.ray_.HitDistance(Sphere(node_->GetWorldPosition(), range_));
Draw:2641:Light.cpp:201:    result.normal_ = -query.ray_.direction_;
Draw:2642:Light.cpp:219:        distance_ = frame.camera_->GetDistance(node_->GetWorldPosition());
Draw:2643:Light.cpp:234:                Vector3 start = node_->GetWorldPosition();
Draw:2644:Light.cpp:235:                Vector3 end = start + node_->GetWorldDirection() * 10.f;
Draw:2645:Light.cpp:236:                for (int i = -1; i < 2; ++i)
Draw:2646:Light.cpp:238:                    for (int j = -1; j < 2; ++j)
Draw:2647:Light.cpp:241:                        debug->AddSphere(Sphere(start + offset, 0.1f), color, depthTest);
Draw:2648:Light.cpp:242:                        debug->AddLine(start + offset, end + offset, color, depthTest);
Draw:2649:Light.cpp:249:            debug->AddFrustum(GetFrustum(), color, depthTest);
Draw:2650:Light.cpp:253:            debug->AddSphere(Sphere(node_->GetWorldPosition(), range_), color, depthTest);
Draw:2651:Light.cpp:377:    Matrix3x4 frustumTransform(node_ ? Matrix3x4(node_->GetWorldPosition(), node_->GetWorldRotation(), 1.0f) :
Draw:2652:Light.cpp:414:            camera->GetFrustumSize(near, far);
Draw:2653:Light.cpp:415:            quadTransform.SetTranslation(Vector3(0.0f, 0.0f, (camera->GetNearClip() + camera->GetFarClip()) * 0.5f));
Draw:2654:Light.cpp:417:            volumeTransform_ = camera->GetEffectiveWorldTransform() * quadTransform;
Draw:2655:Light.cpp:425:            volumeTransform_ = Matrix3x4(node_->GetWorldPosition(), node_->GetWorldRotation(), Vector3(xScale, yScale, range_));
Draw:2656:Light.cpp:430:        volumeTransform_ = Matrix3x4(node_->GetWorldPosition(), Quaternion::IDENTITY, range_);
Draw:2657:Light.cpp:440:    rampTexture_ = static_cast<Texture*>(cache->GetResource(value.type_, value.name_));
Draw:2658:Light.cpp:446:    shapeTexture_ = static_cast<Texture*>(cache->GetResource(value.type_, value.name_));
Draw:2659:Light.cpp:465:        worldBoundingBox_.Define(-M_LARGE_VALUE, M_LARGE_VALUE);
Draw:2660:Light.cpp:475:            const Vector3& center = node_->GetWorldPosition();
Draw:2661:Light.cpp:477:            worldBoundingBox_.Define(center - edge, center + edge);
Draw:2662:Light.cpp:498:            sortValue_ = -Max(distance, M_MIN_NEARCLIP) * GetIntensityDivisor();
Draw:2663:Light.cpp:500:            sortValue_ = -M_LARGE_VALUE * GetIntensityDivisor();
Draw:2664:Light.cpp:516:            Vector3 lightPos = node_->GetWorldPosition();
Draw:2665:Light.cpp:517:            Vector3 lightDir = node_->GetWorldDirection();
Draw:2666:Light.cpp:521:            float centerDistance = (centerProj - lightPos).Length();
Draw:2667:Light.cpp:522:            Ray centerRay(centerProj, centerPos - centerProj);
Draw:2668:Light.cpp:526:            Vector3 cornerPos = centerPos + box.HalfSize() * Vector3(centerPos.x_ < centerProj.x_ ? 1.0f : -1.0f,
Draw:2669:Light.cpp:527:                centerPos.y_ < centerProj.y_ ? 1.0f : -1.0f, centerPos.z_ < centerProj.z_ ? 1.0f : -1.0f);
Draw:2670:Light.cpp:529:            float cornerDistance = (cornerProj - lightPos).Length();
Draw:2671:Light.cpp:530:            float cornerAngle = (cornerPos - cornerProj).Length() / cornerDistance;
Draw:2672:Light.cpp:536:            float att = Max(1.0f - spotFactor * spotFactor, M_EPSILON);
Draw:2673:Light.cpp:544:            Vector3 lightPos = node_->GetWorldPosition();
Draw:2674:Light.cpp:545:            Vector3 lightDir = (centerPos - lightPos).Normalized();
Draw:2675:Light.cpp:549:            float att = Max(1.0f - normDistance * normDistance, M_EPSILON);
Draw:2676:OcclusionBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2677:OcclusionBuffer.cpp:110:    view_ = camera->GetView();
Draw:2678:OcclusionBuffer.cpp:111:    projection_ = camera->GetProjection(false);
Draw:2679:OcclusionBuffer.cpp:113:    nearClip_ = camera->GetNearClip();
Draw:2680:OcclusionBuffer.cpp:114:    farClip_ = camera->GetFarClip();
Draw:2681:OcclusionBuffer.cpp:115:    reverseCulling_ = camera->GetReverseCulling();
Draw:2682:OcclusionBuffer.cpp:151:    while (count--)
Draw:2683:OcclusionBuffer.cpp:167:    // 16-bit indices
Draw:2684:OcclusionBuffer.cpp:200:    // 16-bit indices
Draw:2685:OcclusionBuffer.cpp:254:    // Build the first mip level from the pixel-level data
Draw:2686:OcclusionBuffer.cpp:272:                    dest->min_ = Min(minUpper, minLower);
Draw:2687:OcclusionBuffer.cpp:275:                    dest->max_ = Max(maxUpper, maxLower);
Draw:2688:OcclusionBuffer.cpp:286:                    dest->min_ = Min(src[0], src[1]);
Draw:2689:OcclusionBuffer.cpp:287:                    dest->max_ = Max(src[0], src[1]);
Draw:2690:OcclusionBuffer.cpp:306:            DepthValue* src = mipBuffers_[i - 1].Get() + (y * 2) * prevWidth;
Draw:2691:OcclusionBuffer.cpp:317:                    dest->min_ = Min(minUpper, minLower);
Draw:2692:OcclusionBuffer.cpp:320:                    dest->max_ = Max(maxUpper, maxLower);
Draw:2693:OcclusionBuffer.cpp:331:                    dest->min_ = Min(src[0].min_, src[1].min_);
Draw:2694:OcclusionBuffer.cpp:332:                    dest->max_ = Max(src[0].max_, src[1].max_);
Draw:2695:OcclusionBuffer.cpp:367:        vertices[i].z_ -= OCCLUSION_RELATIVE_BIAS;
Draw:2696:OcclusionBuffer.cpp:397:        (int)(minX - 1.5f), (int)(minY - 1.5f),
Draw:2697:OcclusionBuffer.cpp:413:        rect.right_ = width_ - 1;
Draw:2698:OcclusionBuffer.cpp:415:        rect.bottom_ = height_ - 1;
Draw:2699:OcclusionBuffer.cpp:418:    int z = (int)(minZ + 0.5f) - OCCLUSION_FIXED_BIAS;
Draw:2700:OcclusionBuffer.cpp:423:        for (int i = mipBuffers_.Size() - 1; i >= 0; --i)
Draw:2701:OcclusionBuffer.cpp:441:                    if (z <= src->min_)
Draw:2702:OcclusionBuffer.cpp:443:                    if (z <= src->max_)
Draw:2703:OcclusionBuffer.cpp:455:    // If no conclusive result, finally check the pixel-level data
Draw:2704:OcclusionBuffer.cpp:501:    float t = d0 / (d0 - d1);
Draw:2705:OcclusionBuffer.cpp:502:    return v0 + t * (v1 - v0);
Draw:2706:OcclusionBuffer.cpp:507:    float aX = v0.x_ - v1.x_;
Draw:2707:OcclusionBuffer.cpp:508:    float aY = v0.y_ - v1.y_;
Draw:2708:OcclusionBuffer.cpp:509:    float bX = v2.x_ - v1.x_;
Draw:2709:OcclusionBuffer.cpp:510:    float bY = v2.y_ - v1.y_;
Draw:2710:OcclusionBuffer.cpp:511:    return aX * bY - aY * bX;
Draw:2711:OcclusionBuffer.cpp:518:    scaleY_ = -0.5f * height_;
Draw:2712:OcclusionBuffer.cpp:539:        if (vertices[i].x_ < -vertices[i].w_)
Draw:2713:OcclusionBuffer.cpp:543:        if (vertices[i].y_ < -vertices[i].w_)
Draw:2714:OcclusionBuffer.cpp:585:            ClipVertices(Vector4(-1.0f, 0.0f, 0.0f, 1.0f), vertices, triangles, numTriangles);
Draw:2715:OcclusionBuffer.cpp:589:            ClipVertices(Vector4(0.0f, -1.0f, 0.0f, 1.0f), vertices, triangles, numTriangles);
Draw:2716:OcclusionBuffer.cpp:593:            ClipVertices(Vector4(0.0f, 0.0f, -1.0f, 1.0f), vertices, triangles, numTriangles);
Draw:2717:OcclusionBuffer.cpp:640:            // If 2 vertices behind the plane, create a new triangle in-place
Draw:2718:OcclusionBuffer.cpp:656:            // 1 vertex behind the plane: create one new triangle, and modify one in-place
Draw:2719:OcclusionBuffer.cpp:700:        float invdX = 1.0f / (((vertices[1].x_ - vertices[2].x_) *
Draw:2720:OcclusionBuffer.cpp:701:            (vertices[0].y_ - vertices[2].y_)) -
Draw:2721:OcclusionBuffer.cpp:702:            ((vertices[0].x_ - vertices[2].x_) *
Draw:2722:OcclusionBuffer.cpp:703:            (vertices[1].y_ - vertices[2].y_)));
Draw:2723:OcclusionBuffer.cpp:705:        float invdY = -invdX;
Draw:2724:OcclusionBuffer.cpp:707:        dInvZdX_ = invdX * (((vertices[1].z_ - vertices[2].z_) * (vertices[0].y_ - vertices[2].y_)) -
Draw:2725:OcclusionBuffer.cpp:708:            ((vertices[0].z_ - vertices[2].z_) * (vertices[1].y_ - vertices[2].y_)));
Draw:2726:OcclusionBuffer.cpp:710:        dInvZdY_ = invdY * (((vertices[1].z_ - vertices[2].z_) * (vertices[0].x_ - vertices[2].x_)) -
Draw:2727:OcclusionBuffer.cpp:711:            ((vertices[0].z_ - vertices[2].z_) * (vertices[1].x_ - vertices[2].x_)));
Draw:2728:OcclusionBuffer.cpp:730:        float height = (bottom.y_ - top.y_);
Draw:2729:OcclusionBuffer.cpp:731:        float slope = (height != 0.0f) ? (bottom.x_ - top.x_) / height : 0.0f;
Draw:2730:OcclusionBuffer.cpp:732:        float yPreStep = (float)(topY + 1) - top.y_;
Draw:2731:OcclusionBuffer.cpp:756:    // Sort vertices in Y-direction
Draw:2732:Model.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2733:Model.cpp:72:    context->RegisterFactory<Model>();
Draw:2734:Model.cpp:123:            buffer->SetShadowed(true);
Draw:2735:Model.cpp:124:            buffer->SetSize(vertexCount, elementMask);
Draw:2736:Model.cpp:125:            void* dest = buffer->Lock(0, vertexCount);
Draw:2737:Model.cpp:127:            buffer->Unlock();
Draw:2738:Model.cpp:158:            buffer->SetShadowed(true);
Draw:2739:Model.cpp:159:            buffer->SetSize(indexCount, indexSize > sizeof(unsigned short));
Draw:2740:Model.cpp:160:            void* dest = buffer->Lock(0, indexCount);
Draw:2741:Model.cpp:162:            buffer->Unlock();
Draw:2742:Model.cpp:217:            geometry->SetLodDistance(distance);
Draw:2743:Model.cpp:302:            buffer->SetShadowed(true);
Draw:2744:Model.cpp:303:            buffer->SetSize(desc.vertexCount_, desc.elementMask_);
Draw:2745:Model.cpp:304:            buffer->SetData(desc.data_.Get());
Draw:2746:Model.cpp:315:            buffer->SetShadowed(true);
Draw:2747:Model.cpp:316:            buffer->SetSize(desc.indexCount_, desc.indexSize_ > sizeof(unsigned short));
Draw:2748:Model.cpp:317:            buffer->SetData(desc.data_.Get());
Draw:2749:Model.cpp:328:            geometry->SetVertexBuffer(0, vertexBuffers_[desc.vbRef_]);
Draw:2750:Model.cpp:329:            geometry->SetIndexBuffer(indexBuffers_[desc.ibRef_]);
Draw:2751:Model.cpp:330:            geometry->SetDrawRange(desc.type_, desc.indexStart_, desc.indexCount_);
Draw:2752:Model.cpp:351:        dest.WriteUInt(buffer->GetVertexCount());
Draw:2753:Model.cpp:352:        dest.WriteUInt(buffer->GetElementMask());
Draw:2754:Model.cpp:355:        dest.Write(buffer->GetShadowData(), buffer->GetVertexCount() * buffer->GetVertexSize());
Draw:2755:Model.cpp:362:        dest.WriteUInt(buffer->GetIndexCount());
Draw:2756:Model.cpp:363:        dest.WriteUInt(buffer->GetIndexSize());
Draw:2757:Model.cpp:364:        dest.Write(buffer->GetShadowData(), buffer->GetIndexCount() * buffer->GetIndexSize());
Draw:2758:Model.cpp:380:            dest.WriteFloat(geometry->GetLodDistance());
Draw:2759:Model.cpp:381:            dest.WriteUInt(geometry->GetPrimitiveType());
Draw:2760:Model.cpp:382:            dest.WriteUInt(LookupVertexBuffer(geometry->GetVertexBuffer(0), vertexBuffers_));
Draw:2761:Model.cpp:383:            dest.WriteUInt(LookupIndexBuffer(geometry->GetIndexBuffer(), indexBuffers_));
Draw:2762:Model.cpp:384:            dest.WriteUInt(geometry->GetIndexStart());
Draw:2763:Model.cpp:385:            dest.WriteUInt(geometry->GetIndexCount());
Draw:2764:Model.cpp:400:            dest.WriteUInt(j->first_);
Draw:2765:Model.cpp:401:            dest.WriteUInt(j->second_.elementMask_);
Draw:2766:Model.cpp:402:            dest.WriteUInt(j->second_.vertexCount_);
Draw:2767:Model.cpp:407:            if (j->second_.elementMask_ & MASK_POSITION)
Draw:2768:Model.cpp:409:            if (j->second_.elementMask_ & MASK_NORMAL)
Draw:2769:Model.cpp:411:            if (j->second_.elementMask_ & MASK_TANGENT)
Draw:2770:Model.cpp:414:            dest.Write(j->second_.morphData_.Get(), vertexSize * j->second_.vertexCount_);
Draw:2771:Model.cpp:445:        if (!buffers[i]->IsShadowed())
Draw:2772:Model.cpp:475:        if (!buffers[i]->IsShadowed())
Draw:2773:Model.cpp:492:    // For easier creation of from-scratch geometry, ensure that all geometries start with at least 1 LOD level (0 makes no sense)
Draw:2774:Model.cpp:565:    ret->SetName(cloneName);
Draw:2775:Model.cpp:566:    ret->boundingBox_ = boundingBox_;
Draw:2776:Model.cpp:567:    ret->skeleton_ = skeleton_;
Draw:2777:Model.cpp:568:    ret->geometryBoneMappings_ = geometryBoneMappings_;
Draw:2778:Model.cpp:569:    ret->geometryCenters_ = geometryCenters_;
Draw:2779:Model.cpp:570:    ret->morphs_ = morphs_;
Draw:2780:Model.cpp:571:    ret->morphRangeStarts_ = morphRangeStarts_;
Draw:2781:Model.cpp:572:    ret->morphRangeCounts_ = morphRangeCounts_;
Draw:2782:Model.cpp:584:            cloneBuffer->SetSize(origBuffer->GetVertexCount(), origBuffer->GetElementMask(), origBuffer->IsDynamic());
Draw:2783:Model.cpp:585:            cloneBuffer->SetShadowed(origBuffer->IsShadowed());
Draw:2784:Model.cpp:586:            if (origBuffer->IsShadowed())
Draw:2785:Model.cpp:587:                cloneBuffer->SetData(origBuffer->GetShadowData());
Draw:2786:Model.cpp:590:                void* origData = origBuffer->Lock(0, origBuffer->GetVertexCount());
Draw:2787:Model.cpp:592:                    cloneBuffer->SetData(origData);
Draw:2788:Model.cpp:599:        ret->vertexBuffers_.Push(cloneBuffer);
Draw:2789:Model.cpp:611:            cloneBuffer->SetSize(origBuffer->GetIndexCount(), origBuffer->GetIndexSize() == sizeof(unsigned), origBuffer->IsDynamic());
Draw:2790:Model.cpp:612:            cloneBuffer->SetShadowed(origBuffer->IsShadowed());
Draw:2791:Model.cpp:613:            if (origBuffer->IsShadowed())
Draw:2792:Model.cpp:614:                cloneBuffer->SetData(origBuffer->GetShadowData());
Draw:2793:Model.cpp:617:                void* origData = origBuffer->Lock(0, origBuffer->GetIndexCount());
Draw:2794:Model.cpp:619:                    cloneBuffer->SetData(origData);
Draw:2795:Model.cpp:626:        ret->indexBuffers_.Push(cloneBuffer);
Draw:2796:Model.cpp:630:    ret->geometries_.Resize(geometries_.Size());
Draw:2797:Model.cpp:633:        ret->geometries_[i].Resize(geometries_[i].Size());
Draw:2798:Model.cpp:642:                cloneGeometry->SetIndexBuffer(ibMapping[origGeometry->GetIndexBuffer()]);
Draw:2799:Model.cpp:643:                unsigned numVbs = origGeometry->GetNumVertexBuffers();
Draw:2800:Model.cpp:646:                    cloneGeometry->SetVertexBuffer(k, vbMapping[origGeometry->GetVertexBuffer(k)],
Draw:2801:Model.cpp:647:                        origGeometry->GetVertexElementMask(k));
Draw:2802:Model.cpp:649:                cloneGeometry->SetDrawRange(origGeometry->GetPrimitiveType(), origGeometry->GetIndexStart(),
Draw:2803:Model.cpp:650:                    origGeometry->GetIndexCount(), origGeometry->GetVertexStart(), origGeometry->GetVertexCount(), false);
Draw:2804:Model.cpp:651:                cloneGeometry->SetLodDistance(origGeometry->GetLodDistance());
Draw:2805:Model.cpp:654:            ret->geometries_[i][j] = cloneGeometry;
Draw:2806:Model.cpp:660:    for (Vector<ModelMorph>::Iterator i = ret->morphs_.Begin(); i != ret->morphs_.End(); ++i)
Draw:2807:Model.cpp:665:            VertexBufferMorph& vbMorph = j->second_;
Draw:2808:Model.cpp:675:    ret->SetMemoryUse(GetMemoryUse());
Draw:2809:Model.cpp:691:        lodLevel = geometries_[index].Size() - 1;
Draw:2810:Model.cpp:710:        if (i->nameHash_ == nameHash)
Draw:2811:Octree.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2812:Octree.h:59:        drawable->SetOctant(this);
Draw:2813:Octree.h:70:                drawable->SetOctant(0);
Draw:2814:Octree.h:75:    /// Return world-space bounding box.
Draw:2815:Octree.h:110:            parent_->IncDrawableCount();
Draw:2816:Octree.h:118:        --numDrawables_;
Draw:2817:Octree.h:122:                parent->DeleteChild(index_);
Draw:2818:Octree.h:126:            parent->DecDrawableCount();
Draw:2819:OctreeQuery.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2820:OctreeQuery.cpp:44:        if ((drawable->GetDrawableFlags() & drawableFlags_) && (drawable->GetViewMask() & viewMask_))
Draw:2821:OctreeQuery.cpp:46:            if (inside || drawable->GetWorldBoundingBox().IsInside(point_))
Draw:2822:OctreeQuery.cpp:66:        if ((drawable->GetDrawableFlags() & drawableFlags_) && (drawable->GetViewMask() & viewMask_))
Draw:2823:OctreeQuery.cpp:68:            if (inside || sphere_.IsInsideFast(drawable->GetWorldBoundingBox()))
Draw:2824:OctreeQuery.cpp:88:        if ((drawable->GetDrawableFlags() & drawableFlags_) && (drawable->GetViewMask() & viewMask_))
Draw:2825:OctreeQuery.cpp:90:            if (inside || box_.IsInsideFast(drawable->GetWorldBoundingBox()))
Draw:2826:OctreeQuery.cpp:110:        if ((drawable->GetDrawableFlags() & drawableFlags_) && (drawable->GetViewMask() & viewMask_))
Draw:2827:OctreeQuery.cpp:112:            if (inside || frustum_.IsInsideFast(drawable->GetWorldBoundingBox()))
Draw:2828:Octree.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Draw:2829:Octree.cpp:53:    Octree* octree = reinterpret_cast<Octree*>(item->aux_);
Draw:2830:Octree.cpp:54:    Drawable** start = reinterpret_cast<Drawable**>(item->start_);
Draw:2831:Octree.cpp:55:    Drawable** end = reinterpret_cast<Drawable**>(item->end_);
Draw:2832:Octree.cpp:56:    const RayOctreeQuery& query = *octree->rayQuery_;
Draw:2833:Octree.cpp:57:    PODVector<RayQueryResult>& results = octree->rayQueryResults_[threadIndex];
Draw:2834:Octree.cpp:62:        drawable->ProcessRayQuery(query, results);
Draw:2835:Octree.cpp:69:    const FrameInfo& frame = *(reinterpret_cast<FrameInfo*>(item->aux_));
Draw:2836:Octree.cpp:70:    Drawable** start = reinterpret_cast<Drawable**>(item->start_);
Draw:2837:Octree.cpp:71:    Drawable** end = reinterpret_cast<Drawable**>(item->end_);
Draw:2838:Octree.cpp:77:            drawable->Update(frame);
Draw:2839:Octree.cpp:107:            (*i)->SetOctant(root_);
Draw:2840:Octree.cpp:108:            root_->drawables_.Push(*i);
Draw:2841:Octree.cpp:109:            root_->QueueUpdate(*i);
Draw:2842:Octree.cpp:156:    const BoundingBox& box = drawable->GetWorldBoundingBox();
Draw:2843:Octree.cpp:158:    // If root octant, insert all non-occludees here, so that octant occlusion does not hide the drawable.
Draw:2844:Octree.cpp:162:        insertHere = !drawable->IsOccludee() || cullingBox_.IsInside(box) != INSIDE || CheckDrawableFit(box);
Draw:2845:Octree.cpp:168:        Octant* oldOctant = drawable->octant_;
Draw:2846:Octree.cpp:174:                oldOctant->RemoveDrawable(drawable, false);
Draw:2847:Octree.cpp:184:        GetOrCreateChild(x + y + z)->InsertDrawable(drawable);
Draw:2848:Octree.cpp:193:    if (level_ >= root_->GetNumLevels() || boxSize.x_ >= halfSize_.x_ || boxSize.y_ >= halfSize_.y_ ||
Draw:2849:Octree.cpp:199:        if (box.min_.x_ <= worldBoundingBox_.min_.x_ - 0.5f * halfSize_.x_ ||
Draw:2850:Octree.cpp:201:            box.min_.y_ <= worldBoundingBox_.min_.y_ - 0.5f * halfSize_.y_ ||
Draw:2851:Octree.cpp:203:            box.min_.z_ <= worldBoundingBox_.min_.z_ - 0.5f * halfSize_.z_ ||
Draw:2852:Octree.cpp:218:        (*i)->SetOctant(0);
Draw:2853:Octree.cpp:223:            children_[i]->ResetRoot();
Draw:2854:Octree.cpp:229:    if (debug && debug->IsInside(worldBoundingBox_))
Draw:2855:Octree.cpp:231:        debug->AddBoundingBox(worldBoundingBox_, Color(0.25f, 0.25f, 0.25f), depthTest);
Draw:2856:Octree.cpp:236:                children_[i]->DrawDebugGeometry(debug, depthTest);
Draw:2857:Octree.cpp:246:    cullingBox_ = BoundingBox(worldBoundingBox_.min_ - halfSize_, worldBoundingBox_.max_ + halfSize_);
Draw:2858:Octree.cpp:273:            children_[i]->GetDrawablesInternal(query, inside);
Draw:2859:Octree.cpp:292:            if ((drawable->GetDrawableFlags() & query.drawableFlags_) && (drawable->GetViewMask() & query.viewMask_))
Draw:2860:Octree.cpp:293:                drawable->ProcessRayQuery(query, query.result_);
Draw:2861:Octree.cpp:300:            children_[i]->GetDrawablesInternal(query);
Draw:2862:Octree.cpp:319:            if ((drawable->GetDrawableFlags() & query.drawableFlags_) && (drawable->GetViewMask() & query.viewMask_))
Draw:2863:Octree.cpp:327:            children_[i]->GetDrawablesOnlyInternal(query, drawables);
Draw:2864:Octree.cpp:333:    Octant(BoundingBox(-DEFAULT_OCTREE_SIZE, DEFAULT_OCTREE_SIZE), 0, 0, this),
Draw:2865:Octree.cpp:338:    rayQueryResults_.Resize(workQueue ? workQueue->GetNumThreads() + 1 : 1);
Draw:2866:Octree.cpp:356:    context->RegisterFactory<Octree>(SUBSYSTEM_CATEGORY);
Draw:2867:Octree.cpp:358:    Vector3 defaultBoundsMin = -Vector3::ONE * DEFAULT_OCTREE_SIZE;
Draw:2868:Octree.cpp:404:        // (for example physics objects) should not perform non-threadsafe work when marked dirty
Draw:2869:Octree.cpp:407:        scene->BeginThreadedUpdate();
Draw:2870:Octree.cpp:409:        int numWorkItems = queue->GetNumThreads() + 1; // Worker threads + main thread
Draw:2871:Octree.cpp:416:            SharedPtr<WorkItem> item = queue->GetFreeItem();
Draw:2872:Octree.cpp:417:            item->priority_ = M_MAX_UNSIGNED;
Draw:2873:Octree.cpp:418:            item->workFunction_ = UpdateDrawablesWork;
Draw:2874:Octree.cpp:419:            item->aux_ = const_cast<FrameInfo*>(&frame);
Draw:2875:Octree.cpp:422:            if (i < numWorkItems - 1 && end - start > drawablesPerItem)
Draw:2876:Octree.cpp:425:            item->start_ = &(*start);
Draw:2877:Octree.cpp:426:            item->end_ = &(*end);
Draw:2878:Octree.cpp:427:            queue->AddWorkItem(item);
Draw:2879:Octree.cpp:432:        queue->Complete(M_MAX_UNSIGNED);
Draw:2880:Octree.cpp:433:        scene->EndThreadedUpdate();
Draw:2881:Octree.cpp:445:        scene->SendEvent(E_SCENEDRAWABLEUPDATEFINISHED, eventData);
Draw:2882:Octree.cpp:457:            drawable->updateQueued_ = false;
Draw:2883:Octree.cpp:458:            Octant* octant = drawable->GetOctant();
Draw:2884:Octree.cpp:459:            const BoundingBox& box = drawable->GetWorldBoundingBox();
Draw:2885:Octree.cpp:462:            if (!octant || octant->GetRoot() != this)
Draw:2886:Octree.cpp:465:            if (drawable->IsOccludee() && octant->GetCullingBox().IsInside(box) == INSIDE && octant->CheckDrawableFit(box))
Draw:2887:Octree.cpp:472:            octant = drawable->GetOctant();
Draw:2888:Octree.cpp:473:            if (octant != this && octant->GetCullingBox().IsInside(box) != INSIDE)
Draw:2889:Octree.cpp:476:                    " octant box " + octant->GetCullingBox().ToOpenGL\OGLTexture.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLTexture.h:112:    /// Return the non-internal texture format corresponding to an OpenGL internal format.
OpenGL\OGLTexture2D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLTexture2D.h:63:    /// Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.
OpenGL\OGLTexture2D.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLTexture2D.cpp:54:    context->RegisterFactory<Texture2D>();
OpenGL\OGLTexture2D.cpp:64:    if (graphics_->IsDeviceLost())
OpenGL\OGLTexture2D.cpp:73:    if (!loadImage_->Load(source))
OpenGL\OGLTexture2D.cpp:81:        loadImage_->PrecalculateLevels();
OpenGL\OGLTexture2D.cpp:86:    loadParameters_ = cache->GetTempResource<XMLFile>(xmlName, false);
OpenGL\OGLTexture2D.cpp:94:     if (!graphics_ || graphics_->IsDeviceLost())
OpenGL\OGLTexture2D.cpp:114:        renderSurface_->OnDeviceLost();
OpenGL\OGLTexture2D.cpp:123:        if (cache->Exists(GetName()))
OpenGL\OGLTexture2D.cpp:124:            dataLost_ = !cache->ReloadResource(this);
OpenGL\OGLTexture2D.cpp:143:        if (!graphics_->IsDeviceLost())
OpenGL\OGLTexture2D.cpp:147:                if (graphics_->GetTexture(i) == this)
OpenGL\OGLTexture2D.cpp:148:                    graphics_->SetTexture(i, 0);
OpenGL\OGLTexture2D.cpp:155:            renderSurface_->Release();
OpenGL\OGLTexture2D.cpp:162:            renderSurface_->Release();
OpenGL\OGLTexture2D.cpp:218:    if (graphics_->IsDeviceLost())
OpenGL\OGLTexture2D.cpp:239:    graphics_->SetTextureForUpdate(this);
OpenGL\OGLTexture2D.cpp:259:    graphics_->SetTexture(0, 0);
OpenGL\OGLTexture2D.cpp:276:        quality = renderer->GetTextureQuality();
OpenGL\OGLTexture2D.cpp:278:    if (!image->IsCompressed())
OpenGL\OGLTexture2D.cpp:281:        unsigned components = image->GetComponents();
OpenGL\OGLTexture2D.cpp:284:            image = image->ConvertToRGBA();
OpenGL\OGLTexture2D.cpp:287:            components = image->GetComponents();
OpenGL\OGLTexture2D.cpp:290:        unsigned char* levelData = image->GetData();
OpenGL\OGLTexture2D.cpp:291:        int levelWidth = image->GetWidth();
OpenGL\OGLTexture2D.cpp:292:        int levelHeight = image->GetHeight();
OpenGL\OGLTexture2D.cpp:298:            image = image->GetNextLevel();
OpenGL\OGLTexture2D.cpp:299:            levelData = image->GetData();
OpenGL\OGLTexture2D.cpp:300:            levelWidth = image->GetWidth();
OpenGL\OGLTexture2D.cpp:301:            levelHeight = image->GetHeight();
OpenGL\OGLTexture2D.cpp:335:            if (i < levels_ - 1)
OpenGL\OGLTexture2D.cpp:337:                image = image->GetNextLevel();
OpenGL\OGLTexture2D.cpp:338:                levelData = image->GetData();
OpenGL\OGLTexture2D.cpp:339:                levelWidth = image->GetWidth();
OpenGL\OGLTexture2D.cpp:340:                levelHeight = image->GetHeight();
OpenGL\OGLTexture2D.cpp:346:        int width = image->GetWidth();
OpenGL\OGLTexture2D.cpp:347:        int height = image->GetHeight();
OpenGL\OGLTexture2D.cpp:348:        unsigned levels = image->GetNumCompressedLevels();
OpenGL\OGLTexture2D.cpp:349:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
OpenGL\OGLTexture2D.cpp:360:            mipsToSkip = levels - 1;
OpenGL\OGLTexture2D.cpp:362:            --mipsToSkip;
OpenGL\OGLTexture2D.cpp:366:        SetNumLevels(Max((int)(levels - mipsToSkip), 1));
OpenGL\OGLTexture2D.cpp:369:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
OpenGL\OGLTexture2D.cpp:371:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
OpenGL\OGLTexture2D.cpp:413:    if (graphics_->IsDeviceLost())
OpenGL\OGLTexture2D.cpp:419:    graphics_->SetTextureForUpdate(const_cast<Texture2D*>(this));
OpenGL\OGLTexture2D.cpp:426:    graphics_->SetTexture(0, 0);
OpenGL\OGLTexture2D.cpp:441:    if (graphics_->IsDeviceLost())
OpenGL\OGLTexture2D.cpp:457:        (format == GL_DEPTH_COMPONENT && !graphics_->GetShadowMapFormat()))
OpenGL\OGLTexture2D.cpp:462:            renderSurface_->CreateRenderBuffer(width_, height_, format);
OpenGL\OGLTexture2D.cpp:472:    graphics_->SetTextureForUpdate(this);
OpenGL\OGLTexture2D.cpp:502:    glTexParameteri(target_, GL_TEXTURE_MAX_LEVEL, levels_ - 1);
OpenGL\OGLTexture2D.cpp:507:    graphics_->SetTexture(0, 0);
OpenGL\OGLTexture2D.cpp:514:    if (renderSurface_ && renderSurface_->GetUpdateMode() == SURFACE_UPDATEALWAYS)
OpenGL\OGLTexture2D.cpp:515:        renderSurface_->QueueUpdate();
OpenGL\OGLTexture3D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLTexture3D.h:61:    /// Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.
OpenGL\OGLTexture3D.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLTexture3D.cpp:57:    context->RegisterFactory<Texture3D>();
OpenGL\OGLTexture3D.cpp:69:    if (graphics_->IsDeviceLost())
OpenGL\OGLTexture3D.cpp:79:    cache->ResetDependencies(this);
OpenGL\OGLTexture3D.cpp:82:    if (!loadParameters_->Load(source))
OpenGL\OGLTexture3D.cpp:88:    XMLElement textureElem = loadParameters_->GetRoot();
OpenGL\OGLTexture3D.cpp:102:        loadImage_ = cache->GetTempResource<Image>(name);
OpenGL\OGLTexture3D.cpp:105:            loadImage_->PrecalculateLevels();
OpenGL\OGLTexture3D.cpp:106:        cache->StoreResourceDependency(this, name);
OpenGL\OGLTexture3D.cpp:119:        SharedPtr<File> file = GetSubsystem<ResourceCache>()->GetFile(name);
OpenGL\OGLTexture3D.cpp:121:        if (!loadImage_->LoadColorLUT(*(file.Get())))
OpenGL\OGLTexture3D.cpp:129:            loadImage_->PrecalculateLevels();
OpenGL\OGLTexture3D.cpp:130:        cache->StoreResourceDependency(this, name);
OpenGL\OGLTexture3D.cpp:142:    if (!graphics_ || graphics_->IsDeviceLost())
OpenGL\OGLTexture3D.cpp:162:        renderSurface_->OnDeviceLost();
OpenGL\OGLTexture3D.cpp:171:        if (cache->Exists(GetName()))
OpenGL\OGLTexture3D.cpp:172:            dataLost_ = !cache->ReloadResource(this);
OpenGL\OGLTexture3D.cpp:188:        if (!graphics_ || graphics_->IsDeviceLost())
OpenGL\OGLTexture3D.cpp:193:            if (graphics_->GetTexture(i) == this)
OpenGL\OGLTexture3D.cpp:194:                graphics_->SetTexture(i, 0);
OpenGL\OGLTexture3D.cpp:198:            renderSurface_->Release();
OpenGL\OGLTexture3D.cpp:206:            renderSurface_->Release();
OpenGL\OGLTexture3D.cpp:263:    if (graphics_->IsDeviceLost())
OpenGL\OGLTexture3D.cpp:285:    graphics_->SetTextureForUpdate(this);
OpenGL\OGLTexture3D.cpp:307:    graphics_->SetTexture(0, 0);
OpenGL\OGLTexture3D.cpp:324:        quality = renderer->GetTextureQuality();
OpenGL\OGLTexture3D.cpp:326:    if (!image->IsCompressed())
OpenGL\OGLTexture3D.cpp:329:        unsigned components = image->GetComponents();
OpenGL\OGLTexture3D.cpp:332:            image = image->ConvertToRGBA();
OpenGL\OGLTexture3D.cpp:335:            components = image->GetComponents();
OpenGL\OGLTexture3D.cpp:338:        unsigned char* levelData = image->GetData();
OpenGL\OGLTexture3D.cpp:339:        int levelWidth = image->GetWidth();
OpenGL\OGLTexture3D.cpp:340:        int levelHeight = image->GetHeight();
OpenGL\OGLTexture3D.cpp:341:        int levelDepth = image->GetDepth();
OpenGL\OGLTexture3D.cpp:347:            image = image->GetNextLevel();
OpenGL\OGLTexture3D.cpp:348:            levelData = image->GetData();
OpenGL\OGLTexture3D.cpp:349:            levelWidth = image->GetWidth();
OpenGL\OGLTexture3D.cpp:350:            levelHeight = image->GetHeight();
OpenGL\OGLTexture3D.cpp:351:            levelDepth = image->GetDepth();
OpenGL\OGLTexture3D.cpp:385:            if (i < levels_ - 1)
OpenGL\OGLTexture3D.cpp:387:                image = image->GetNextLevel();
OpenGL\OGLTexture3D.cpp:388:                levelData = image->GetData();
OpenGL\OGLTexture3D.cpp:389:                levelWidth = image->GetWidth();
OpenGL\OGLTexture3D.cpp:390:                levelHeight = image->GetHeight();
OpenGL\OGLTexture3D.cpp:391:                levelDepth = image->GetDepth();
OpenGL\OGLTexture3D.cpp:397:        int width = image->GetWidth();
OpenGL\OGLTexture3D.cpp:398:        int height = image->GetHeight();
OpenGL\OGLTexture3D.cpp:399:        int depth = image->GetDepth();
OpenGL\OGLTexture3D.cpp:400:        unsigned levels = image->GetNumCompressedLevels();
OpenGL\OGLTexture3D.cpp:401:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
OpenGL\OGLTexture3D.cpp:412:            mipsToSkip = levels - 1;
OpenGL\OGLTexture3D.cpp:414:            --mipsToSkip;
OpenGL\OGLTexture3D.cpp:419:        SetNumLevels(Max((int)(levels - mipsToSkip), 1));
OpenGL\OGLTexture3D.cpp:422:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
OpenGL\OGLTexture3D.cpp:424:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
OpenGL\OGLTexture3D.cpp:466:    if (graphics_->IsDeviceLost())
OpenGL\OGLTexture3D.cpp:472:    graphics_->SetTextureForUpdate(const_cast<Texture3D*>(this));
OpenGL\OGLTexture3D.cpp:479:    graphics_->SetTexture(0, 0);
OpenGL\OGLTexture3D.cpp:498:    if (graphics_->IsDeviceLost())
OpenGL\OGLTexture3D.cpp:511:    graphics_->SetTextureForUpdate(this);
OpenGL\OGLTexture3D.cpp:540:    glTexParameteri(target_, GL_TEXTURE_MAX_LEVEL, levels_ - 1);
OpenGL\OGLTexture3D.cpp:544:    graphics_->SetTexture(0, 0);
OpenGL\OGLTexture3D.cpp:552:    if (renderSurface_ && renderSurface_->GetUpdateMode() == SURFACE_UPDATEALWAYS)
OpenGL\OGLTexture3D.cpp:553:        renderSurface_->QueueUpdate();
OpenGL\OGLTextureCube.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLTextureCube.cpp:55:    return SharedPtr<Image>(src->GetSubimage(IntRect(tileX * tileWidth, tileY * tileHeight, (tileX + 1) * tileWidth, (tileY + 1) * tileHeight)));
OpenGL\OGLTextureCube.cpp:79:    context->RegisterFactory<TextureCube>();
OpenGL\OGLTextureCube.cpp:91:    if (graphics_->IsDeviceLost())
OpenGL\OGLTextureCube.cpp:98:    cache->ResetDependencies(this);
OpenGL\OGLTextureCube.cpp:104:    if (!loadParameters_->Load(source))
OpenGL\OGLTextureCube.cpp:112:    XMLElement textureElem = loadParameters_->GetRoot();
OpenGL\OGLTextureCube.cpp:123:        SharedPtr<Image> image = cache->GetTempResource<Image>(name);
OpenGL\OGLTextureCube.cpp:133:            faceWidth = image->GetWidth() / MAX_CUBEMAP_FACES;
OpenGL\OGLTextureCube.cpp:134:            faceHeight = image->GetHeight();
OpenGL\OGLTextureCube.cpp:144:            faceWidth = image->GetWidth() / MAX_CUBEMAP_FACES;
OpenGL\OGLTextureCube.cpp:145:            faceHeight = image->GetHeight();
OpenGL\OGLTextureCube.cpp:151:            faceWidth = image->GetWidth() / 4;
OpenGL\OGLTextureCube.cpp:152:            faceHeight = image->GetHeight() / 3;
OpenGL\OGLTextureCube.cpp:162:            faceWidth = image->GetWidth() / 3;
OpenGL\OGLTextureCube.cpp:163:            faceHeight = image->GetHeight() / 4;
OpenGL\OGLTextureCube.cpp:172:                loadImages_[FACE_NEGATIVE_Z]->FlipVertical();
OpenGL\OGLTextureCube.cpp:173:                loadImages_[FACE_NEGATIVE_Z]->FlipHorizontal();
OpenGL\OGLTextureCube.cpp:178:            faceWidth = image->GetWidth() / 3;
OpenGL\OGLTextureCube.cpp:179:            faceHeight = image->GetHeight() / 2;
OpenGL\OGLTextureCube.cpp:201:            loadImages_.Push(cache->GetTempResource<Image>(name));
OpenGL\OGLTextureCube.cpp:202:            cache->StoreResourceDependency(this, name);
OpenGL\OGLTextureCube.cpp:214:                loadImages_[i]->PrecalculateLevels();
OpenGL\OGLTextureCube.cpp:224:    if (!graphics_ || graphics_->IsDeviceLost())
OpenGL\OGLTextureCube.cpp:248:            renderSurfaces_[i]->OnDeviceLost();
OpenGL\OGLTextureCube.cpp:258:        if (cache->Exists(GetName()))
OpenGL\OGLTextureCube.cpp:259:            dataLost_ = !cache->ReloadResource(this);
OpenGL\OGLTextureCube.cpp:278:        if (!graphics_->IsDeviceLost())
OpenGL\OGLTextureCube.cpp:282:                if (graphics_->GetTexture(i) == this)
OpenGL\OGLTextureCube.cpp:283:                    graphics_->SetTexture(i, 0);
OpenGL\OGLTextureCube.cpp:292:                renderSurfaces_[i]->Release();
OpenGL\OGLTextureCube.cpp:308:        LOGERROR("Depth-stencil usage not supported for cube maps");
OpenGL\OGLTextureCube.cpp:326:            renderSurfaces_[i]->SetTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i);
OpenGL\OGLTextureCube.cpp:368:    if (graphics_->IsDeviceLost())
OpenGL\OGLTextureCube.cpp:389:    graphics_->SetTextureForUpdate(this);
OpenGL\OGLTextureCube.cpp:413:    graphics_->SetTexture(0, 0);
OpenGL\OGLTextureCube.cpp:420:    if (!image->Load(source))
OpenGL\OGLTextureCube.cpp:439:        quality = renderer->GetTextureQuality();
OpenGL\OGLTextureCube.cpp:441:    if (!image->IsCompressed())
OpenGL\OGLTextureCube.cpp:444:        unsigned components = image->GetComponents();
OpenGL\OGLTextureCube.cpp:447:            image = image->ConvertToRGBA();
OpenGL\OGLTextureCube.cpp:450:            components = image->GetComponents();
OpenGL\OGLTextureCube.cpp:453:        unsigned char* levelData = image->GetData();
OpenGL\OGLTextureCube.cpp:454:        int levelWidth = image->GetWidth();
OpenGL\OGLTextureCube.cpp:455:        int levelHeight = image->GetHeight();
OpenGL\OGLTextureCube.cpp:467:            image = image->GetNextLevel();
OpenGL\OGLTextureCube.cpp:468:            levelData = image->GetData();
OpenGL\OGLTextureCube.cpp:469:            levelWidth = image->GetWidth();
OpenGL\OGLTextureCube.cpp:470:            levelHeight = image->GetHeight();
OpenGL\OGLTextureCube.cpp:519:            if (i < levels_ - 1)
OpenGL\OGLTextureCube.cpp:521:                image = image->GetNextLevel();
OpenGL\OGLTextureCube.cpp:522:                levelData = image->GetData();
OpenGL\OGLTextureCube.cpp:523:                levelWidth = image->GetWidth();
OpenGL\OGLTextureCube.cpp:524:                levelHeight = image->GetHeight();
OpenGL\OGLTextureCube.cpp:530:        int width = image->GetWidth();
OpenGL\OGLTextureCube.cpp:531:        int height = image->GetHeight();
OpenGL\OGLTextureCube.cpp:532:        unsigned levels = image->GetNumCompressedLevels();
OpenGL\OGLTextureCube.cpp:533:        unsigned format = graphics_->GetFormat(image->GetCompressedFormat());
OpenGL\OGLTextureCube.cpp:550:            mipsToSkip = levels - 1;
OpenGL\OGLTextureCube.cpp:552:            --mipsToSkip;
OpenGL\OGLTextureCube.cpp:559:            SetNumLevels(Max((int)(levels - mipsToSkip), 1));
OpenGL\OGLTextureCube.cpp:576:        for (unsigned i = 0; i < levels_ && i < levels - mipsToSkip; ++i)
OpenGL\OGLTextureCube.cpp:578:            CompressedLevel level = image->GetCompressedLevel(i + mipsToSkip);
OpenGL\OGLTextureCube.cpp:624:    if (graphics_->IsDeviceLost())
OpenGL\OGLTextureCube.cpp:630:    graphics_->SetTextureForUpdate(const_cast<TextureCube*>(this));
OpenGL\OGLTextureCube.cpp:637:    graphics_->SetTexture(0, 0);
OpenGL\OGLTextureCube.cpp:652:    if (graphics_->IsDeviceLost())
OpenGL\OGLTextureCube.cpp:661:    graphics_->SetTextureForUpdate(this);
OpenGL\OGLTextureCube.cpp:696:    glTexParameteri(target_, GL_TEXTURE_MAX_LEVEL, levels_ - 1);
OpenGL\OGLTextureCube.cpp:701:    graphics_->SetTexture(0, 0);
OpenGL\OGLTextureCube.cpp:710:        if (renderSurfaces_[i] && renderSurfaces_[i]->GetUpdateMode() == SURFACE_UPDATEALWAYS)
OpenGL\OGLTextureCube.cpp:711:            renderSurfaces_[i]->QueueUpdate();
OpenGL\OGLTextureCube.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLTextureCube.h:65:    /// Set data of one face from an image. Return true if successful. Optionally make a single channel image alpha-only.
OpenGL\OGLVertexBuffer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLVertexBuffer.cpp:149:        if (!graphics_->IsDeviceLost())
OpenGL\OGLVertexBuffer.cpp:153:                if (graphics_->GetVertexBuffer(i) == this)
OpenGL\OGLVertexBuffer.cpp:154:                    graphics_->SetVertexBuffer(0);
OpenGL\OGLVertexBuffer.cpp:157:            graphics_->SetVBO(0);
OpenGL\OGLVertexBuffer.cpp:219:        if (!graphics_->IsDeviceLost())
OpenGL\OGLVertexBuffer.cpp:221:            graphics_->SetVBO(object_);
OpenGL\OGLVertexBuffer.cpp:266:        if (!graphics_->IsDeviceLost())
OpenGL\OGLVertexBuffer.cpp:268:            graphics_->SetVBO(object_);
OpenGL\OGLVertexBuffer.cpp:318:        lockScratchData_ = graphics_->ReserveScratchBuffer(count * vertexSize_);
OpenGL\OGLVertexBuffer.cpp:337:            graphics_->FreeScratchBuffer(lockScratchData_);
OpenGL\OGLVertexBuffer.cpp:399:        if (graphics_->IsDeviceLost())
OpenGL\OGLVertexBuffer.cpp:413:        graphics_->SetVBO(object_);
OpenGL\OGLVertexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
OpenGL\OGLVertexBuffer.h:56:    /// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
ParticleEffect.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
ParticleEffect.cpp:47:static const Vector3 DEFAULT_DIRECTION_MIN(-1.0f, -1.0f, -1.0f);
ParticleEffect.cpp:89:    context->RegisterFactory<ParticleEffect>();
ParticleEffect.cpp:148:            GetSubsystem<ResourceCache>()->BackgroundLoadResource<Material>(loadMaterialName_, true, this);
ParticleEffect.cpp:287:        SetMaterial(GetSubsystem<ResourceCache>()->GetResource<Material>(loadMaterialName_));
ParticleEffect.cpp:337:        material_ = GetSubsystem<ResourceCache>()->GetResource<Material>(source.GetChild("material").GetAttribute("name"));
ParticleEffect.cpp:474:    XMLElement materialElem = xml->CreateRoot("particleeffect");
ParticleEffect.cpp:477:    return xml->Save(dest);
ParticleEffect.cpp:740:            for (unsigned j = s; j > i; j--)
ParticleEffect.cpp:742:                colorFrames_[j].color_ = colorFrames_[j - 1].color_;
ParticleEffect.cpp:743:                colorFrames_[j].time_ = colorFrames_[j - 1].time_;
ParticleEffect.cpp:765:    for (unsigned i = index; i < s - 1 ; i++)
ParticleEffect.cpp:771:    colorFrames_.Resize(s - 1);
ParticleEffect.cpp:810:            for (unsigned j = s; j > i; j--)
ParticleEffect.cpp:812:                textureFrames_[j].uv_ = textureFrames_[j - 1].uv_;
ParticleEffect.cpp:813:                textureFrames_[j].time_ = textureFrames_[j - 1].time_;
ParticleEffect.cpp:835:    for (unsigned i = index; i < s - 1 ; i++)
ParticleEffect.cpp:841:    textureFrames_.Resize(s - 1);
ParticleEffect.h:2:// Copyright (c) 2008-2015 the Urho3D project.
ParticleEffect.h:60:    /// Return interpolated value with another color-time pair at the time specified.
ParticleEffect.h:63:        float timeInterval = next.time_ - time_;
ParticleEffect.h:66:            float t = (time - time_) / timeInterval;
ParticleEmitter.h:2:// Copyright (c) 2008-2015 the Urho3D project.
ParticleEmitter.h:118:    /// Handle scene post-update event.
ParticleEmitter.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
ParticleEmitter.cpp:58:    context->RegisterFactory<ParticleEmitter>(GEOMETRY_CATEGORY);
ParticleEmitter.cpp:110:        float activeTime = effect_->GetActiveTime();
ParticleEmitter.cpp:114:            periodTimer_ -= activeTime;
ParticleEmitter.cpp:119:        float inactiveTime = effect_->GetInactiveTime();
ParticleEmitter.cpp:123:            periodTimer_ -= inactiveTime;
ParticleEmitter.cpp:135:        float intervalMin = 1.0f / effect_->GetMaxEmissionRate();
ParticleEmitter.cpp:136:        float intervalMax = 1.0f / effect_->GetMinEmissionRate();
ParticleEmitter.cpp:139:        if (emissionTimer_ < -intervalMax)
ParticleEmitter.cpp:140:            emissionTimer_ = -intervalMax;
ParticleEmitter.cpp:146:            emissionTimer_ -= Lerp(intervalMin, intervalMax, Random(1.0f));
ParticleEmitter.cpp:149:                --counter;
ParticleEmitter.cpp:158:    Vector3 relativeConstantForce = node_->GetWorldRotation().Inverse() * effect_->GetConstantForce();
ParticleEmitter.cpp:162:        scaleVector = node_->GetWorldScale();
ParticleEmitter.cpp:182:            const Vector3& constantForce = effect_->GetConstantForce();
ParticleEmitter.cpp:191:            float dampingForce = effect_->GetDampingForce();
ParticleEmitter.cpp:194:                Vector3 force = -dampingForce * particle.velocity_;
ParticleEmitter.cpp:203:            float sizeAdd = effect_->GetSizeAdd();
ParticleEmitter.cpp:204:            float sizeMul = effect_->GetSizeMul();
ParticleEmitter.cpp:211:                    particle.scale_ *= (lastTimeStep_ * (sizeMul - 1.0f)) + 1.0f;
ParticleEmitter.cpp:217:            const Vector<ColorFrame>& colorFrames_ = effect_->GetColorFrames();
ParticleEmitter.cpp:220:                if (index < colorFrames_.Size() - 1)
ParticleEmitter.cpp:225:                if (index < colorFrames_.Size() - 1)
ParticleEmitter.cpp:233:            const Vector<TextureFrame>& textureFrames_ = effect_->GetTextureFrames();
ParticleEmitter.cpp:234:            if (textureFrames_.Size() && texIndex < textureFrames_.Size() - 1)
ParticleEmitter.cpp:307:        i->enabled_ = false;
ParticleEmitter.cpp:324:    SetMaterial(effect_->GetMaterial());
ParticleEmitter.cpp:325:    SetNumParticles(effect_->GetNumParticles());
ParticleEmitter.cpp:326:    SetRelative(effect_->IsRelative());
ParticleEmitter.cpp:327:    SetScaled(effect_->IsScaled());
ParticleEmitter.cpp:328:    SetSorted(effect_->IsSorted());
ParticleEmitter.cpp:329:    SetAnimationLodBias(effect_->GetAnimationLodBias());
ParticleEmitter.cpp:335:    SetEffect(cache->GetResource<ParticleEffect>(value.name_));
ParticleEmitter.cpp:350:        i->velocity_ = value[index++].GetVector3();
ParticleEmitter.cpp:351:        i->size_ = value[index++].GetVector2();
ParticleEmitter.cpp:352:        i->timer_ = value[index++].GetFloat();
ParticleEmitter.cpp:353:        i->timeToLive_ = value[index++].GetFloat();
ParticleEmitter.cpp:354:        i->scale_ = value[index++].GetFloat();
ParticleEmitter.cpp:355:        i->rotationSpeed_ = value[index++].GetFloat();
ParticleEmitter.cpp:356:        i->colorIndex_ = value[index++].GetInt();
ParticleEmitter.cpp:357:        i->texIndex_ = value[index++].GetInt();
ParticleEmitter.cpp:374:        ret.Push(i->velocity_);
ParticleEmitter.cpp:375:        ret.Push(i->size_);
ParticleEmitter.cpp:376:        ret.Push(i->timer_);
ParticleEmitter.cpp:377:        ret.Push(i->timeToLive_);
ParticleEmitter.cpp:378:        ret.Push(i->scale_);
ParticleEmitter.cpp:379:        ret.Push(i->rotationSpeed_);
ParticleEmitter.cpp:380:        ret.Push(i->colorIndex_);
ParticleEmitter.cpp:381:        ret.Push(i->texIndex_);
ParticleEmitter.cpp:400:        ret.Push(i->position_);
ParticleEmitter.cpp:401:        ret.Push(i->size_);
ParticleEmitter.cpp:402:        ret.Push(Vector4(i->uv_.min_.x_, i->uv_.min_.y_, i->uv_.max_.x_, i->uv_.max_.y_));
ParticleEmitter.cpp:403:        ret.Push(i->color_);
ParticleEmitter.cpp:404:        ret.Push(i->rotation_);
ParticleEmitter.cpp:405:        ret.Push(i->enabled_);
ParticleEmitter.cpp:436:    switch (effect_->GetEmitterType())
ParticleEmitter.cpp:441:                Random(2.0f) - 1.0f,
ParticleEmitter.cpp:442:                Random(2.0f) - 1.0f,
ParticleEmitter.cpp:443:                Random(2.0f) - 1.0f
ParticleEmitter.cpp:446:            startPos = effect_->GetEmitterSize() * dir * 0.5f;
ParticleEmitter.cpp:452:            const Vector3& emitterSize = effect_->GetEmitterSize();
ParticleEmitter.cpp:454:                Random(emitterSize.x_) - emitterSize.x_ * 0.5f,
ParticleEmitter.cpp:455:                Random(emitterSize.y_) - emitterSize.y_ * 0.5f,
ParticleEmitter.cpp:456:                Random(emitterSize.z_) - emitterSize.z_ * 0.5f
ParticleEmitter.cpp:462:    startDir = effect_->GetRandomDirection();
ParticleEmitter.cpp:467:        startPos = node_->GetWorldTransform() * startPos;
ParticleEmitter.cpp:468:        startDir = node_->GetWorldRotation() * startDir;
ParticleEmitter.cpp:471:    particle.velocity_ = effect_->GetRandomVelocity() * startDir;
ParticleEmitter.cpp:472:    particle.size_ = effect_->GetRandomSize();
ParticleEmitter.cpp:474:    particle.timeToLive_ = effect_->GetRandomTimeToLive();
ParticleEmitter.cpp:476:    particle.rotationSpeed_ = effect_->GetRandomRotationSpeed();
ParticleEmitter.cpp:482:    const Vector<TextureFrame>& textureFrames_ = effect_->GetTextureFrames();
ParticleEmitter.cpp:484:    billboard.rotation_ = effect_->GetRandomRotation();
ParticleEmitter.cpp:485:    const Vector<ColorFrame>& colorFrames_ = effect_->GetColorFrames();
ParticleEmitter.cpp:511:    if ((effect_ && effect_->GetUpdateInvisible()) || viewFrameNumber_ != lastUpdateFrameNumber_)
ParticleEmitter.cpp:521:    // When particle effect file is live-edited, remove existing particles and reapply the effect parameters
Renderer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Renderer.h:68:/// Per-vertex light vertex shader variations.
Renderer.h:149:/// High-level rendering subsystem. Manages drawing of 3D views.
Renderer.h:301:    /// Allocate a rendertarget or depth-stencil texture for deferred rendering or postprocessing. Should only be called during actual rendering, not before.
Renderer.h:303:    /// Allocate a depth-stencil surface that does not need to be readable. Should only be called during actual rendering, not before.
Renderer.h:307:    /// Allocate a temporary shadow camera and a scene node for it. Is thread-safe.
RenderSurface.h:2:// Copyright (c) 2008-2015 the Urho3D project.
RenderPath.h:2:// Copyright (c) 2008-2015 the Urho3D project.
RenderPath.h:134:    /// Set depth-stencil output name. When empty, will assign a depth-stencil buffer automatically.
RenderPath.h:147:    /// Return depth-stencil output name.
RenderPath.h:176:    /// Depth-stencil output name.
RenderPath.h:192:    /// Use lit base pass optimization for forward per-pixel lights.
RenderPath.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
RenderPath.cpp:273:    return i != shaderParameters_.End() ? i->second_ : Variant::EMPTY;
RenderPath.cpp:297:    newRenderPath->renderTargets_ = renderTargets_;
RenderPath.cpp:298:    newRenderPath->commands_ = commands_;
RenderPath.cpp:315:    XMLElement rootElem = file->GetRoot();
RenderPath.cpp:406:    for (unsigned i = renderTargets_.Size() - 1; i < renderTargets_.Size(); --i)
RenderPath.cpp:438:    for (unsigned i = commands_.Size() - 1; i < commands_.Size(); --i)
RenderPath.cpp:453:            j->second_ = value;
RenderPath.cpp:465:            return j->second_;
Renderer.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Renderer.cpp:56:    -1, 1, 0,
Renderer.cpp:58:    1, -1, 0,
Renderer.cpp:59:    -1, -1, 0,
Renderer.cpp:70:    -0.423169f, -1.000000f, 0.423169f,
Renderer.cpp:71:    -0.423169f, -1.000000f, -0.423169f,
Renderer.cpp:72:    0.423169f, -1.000000f, -0.423169f,
Renderer.cpp:73:    0.423169f, -1.000000f, 0.423169f,
Renderer.cpp:74:    0.423169f, 1.000000f, -0.423169f,
Renderer.cpp:75:    -0.423169f, 1.000000f, -0.423169f,
Renderer.cpp:76:    -0.423169f, 1.000000f, 0.423169f,
Renderer.cpp:78:    -1.000000f, 0.423169f, -0.423169f,
Renderer.cpp:79:    -1.000000f, -0.423169f, -0.423169f,
Renderer.cpp:80:    -1.000000f, -0.423169f, 0.423169f,
Renderer.cpp:81:    -1.000000f, 0.423169f, 0.423169f,
Renderer.cpp:82:    0.423169f, 0.423169f, -1.000000f,
Renderer.cpp:83:    0.423169f, -0.423169f, -1.000000f,
Renderer.cpp:84:    -0.423169f, -0.423169f, -1.000000f,
Renderer.cpp:85:    -0.423169f, 0.423169f, -1.000000f,
Renderer.cpp:87:    1.000000f, -0.423169f, 0.423169f,
Renderer.cpp:88:    1.000000f, -0.423169f, -0.423169f,
Renderer.cpp:89:    1.000000f, 0.423169f, -0.423169f,
Renderer.cpp:90:    0.423169f, -0.423169f, 1.000000f,
Renderer.cpp:92:    -0.423169f, 0.423169f, 1.000000f,
Renderer.cpp:93:    -0.423169f, -0.423169f, 1.000000f
Renderer.cpp:147:    0.00001f, -0.00001f, 0.00001f,
Renderer.cpp:148:    -0.00001f, -0.00001f, 0.00001f,
Renderer.cpp:149:    -0.00001f, 0.00001f, 0.00001f,
Renderer.cpp:151:    1.00000f, -1.00000f, 0.99999f,
Renderer.cpp:152:    -1.00000f,  -1.00000f, 0.99999f,
Renderer.cpp:153:    -1.00000f, 1.00000f, 0.99999f,
Renderer.cpp:313:    if (newRenderPath->Load(xmlFile))
Renderer.cpp:363:    if (!graphics_ || !graphics_->GetShadowMapFormat())
Renderer.cpp:391:    // If no hardware PCF, do not allow to select one-sample quality
Renderer.cpp:392:    if (!graphics_->GetHardwareShadowSupport())
Renderer.cpp:394:    if (!graphics_->GetHiresShadowMapFormat())
Renderer.cpp:421:        if ((int)i->second_.Size() > maxShadowMaps_)
Renderer.cpp:422:            i->second_.Resize(maxShadowMaps_);
Renderer.cpp:493:            numGeometries += views_[i]->GetGeometries().Size();
Renderer.cpp:507:            numLights += views_[i]->GetLights().Size();
Renderer.cpp:523:        const Vector<LightBatchQueue>& lightQueues = views_[i]->GetLightQueues();
Renderer.cpp:527:            if (i->shadowMap_)
Renderer.cpp:543:            numOccluders += views_[i]->GetOccluders().Size();
Renderer.cpp:557:    if (!graphics_ || !graphics_->IsInitialized() || graphics_->IsDeviceLost())
Renderer.cpp:561:    frame_.frameNumber_ = GetSubsystem<Time>()->GetFrameNumber();
Renderer.cpp:574:    for (unsigned i = viewports_.Size() - 1; i < viewports_.Size(); --i)
Renderer.cpp:591:        if (!viewport->GetView() || resetViews_)
Renderer.cpp:592:            viewport->AllocateView();
Renderer.cpp:594:        View* view = viewport->GetView();
Renderer.cpp:597:        if (!view->Define(renderTarget, viewport))
Renderer.cpp:602:        const IntRect& viewRect = viewport->GetRect();
Renderer.cpp:603:        Scene* scene = viewport->GetScene();
Renderer.cpp:607:        Octree* octree = scene->GetComponent<Octree>();
Renderer.cpp:613:            frame_.camera_ = viewport->GetCamera();
Renderer.cpp:616:                frame_.viewSize_ = IntVector2(graphics_->GetWidth(), graphics_->GetHeight());
Renderer.cpp:617:            octree->Update(frame_);
Renderer.cpp:622:            DebugRenderer* debug = scene->GetComponent<DebugRenderer>();
Renderer.cpp:624:                debug->SetView(viewport->GetCamera());
Renderer.cpp:629:        view->Update(frame_);
Renderer.cpp:637:            renderTarget->WasUpdated();
Renderer.cpp:647:    assert(graphics_ && graphics_->IsInitialized() && !graphics_->IsDeviceLost());
Renderer.cpp:652:    if (faceSelectCubeMap_ && faceSelectCubeMap_->IsDataLost())
Renderer.cpp:655:    graphics_->SetDefaultTextureFilterMode(textureFilterMode_);
Renderer.cpp:656:    graphics_->SetTextureAnisotropy(textureAnisotropy_);
Renderer.cpp:661:        graphics_->SetBlendMode(BLEND_REPLACE);
Renderer.cpp:662:        graphics_->SetColorWrite(true);
Renderer.cpp:663:        graphics_->SetDepthWrite(true);
Renderer.cpp:664:        graphics_->SetScissorTest(false);
Renderer.cpp:665:        graphics_->SetStencilTest(false);
Renderer.cpp:666:        graphics_->ResetRenderTargets();
Renderer.cpp:667:        graphics_->Clear(CLEAR_COLOR | CLEAR_DEPTH | CLEAR_STENCIL, defaultZone_->GetFogColor());
Renderer.cpp:675:        for (unsigned i = views_.Size() - 1; i < views_.Size(); --i)
Renderer.cpp:682:            RenderSurface* renderTarget = views_[i]->GetRenderTarget();
Renderer.cpp:687:            eventData[P_TEXTURE] = (renderTarget ? renderTarget->GetParentTexture() : 0);
Renderer.cpp:688:            eventData[P_SCENE] = views_[i]->GetScene();
Renderer.cpp:689:            eventData[P_CAMERA] = views_[i]->GetCamera();
Renderer.cpp:694:            views_[i]->Render();
Renderer.cpp:700:        numPrimitives_ = graphics_->GetNumPrimitives();
Renderer.cpp:701:        numBatches_ = graphics_->GetNumBatches();
Renderer.cpp:712:    /// \todo Because debug geometry is per-scene, if two cameras show views of the same area, occlusion is not shown correctly
Renderer.cpp:719:        if (!view || !view->GetDrawDebug())
Renderer.cpp:721:        Octree* octree = view->GetOctree();
Renderer.cpp:724:        DebugRenderer* debug = octree->GetComponent<DebugRenderer>();
Renderer.cpp:725:        if (!debug || !debug->IsEnabledEffective())
Renderer.cpp:729:        const PODVector<Drawable*>& geometries = view->GetGeometries();
Renderer.cpp:730:        const PODVector<Light*>& lights = view->GetLights();
Renderer.cpp:736:                geometries[i]->DrawDebugGeometry(debug, depthTest);
Renderer.cpp:744:                lights[i]->DrawDebugGeometry(debug, depthTest);
Renderer.cpp:755:        unsigned numViewports = renderTarget->GetNumViewports();
Renderer.cpp:758:            QueueViewport(renderTarget, renderTarget->GetViewport(i));
Renderer.cpp:773:    switch (light->GetLightType())
Renderer.cpp:793:    LightType type = light->GetLightType();
Renderer.cpp:794:    const FocusParameters& parameters = light->GetShadowFocus();
Renderer.cpp:795:    float size = (float)shadowMapSize_ * light->GetShadowResolution();
Renderer.cpp:799:        const Matrix3x4& view = camera->GetView();
Renderer.cpp:800:        const Matrix4& projection = camera->GetProjection();
Renderer.cpp:807:            Vector3 center = view * light->GetNode()->GetWorldPosition();
Renderer.cpp:808:            float extent = 0.58f * light->GetRange();
Renderer.cpp:809:            lightBox.Define(center + Vector3(extent, extent, extent), center - Vector3(extent, extent, extent));
Renderer.cpp:814:            Frustum lightFrustum = light->GetFrustum().Transformed(view);
Renderer.cpp:821:        // Clamp pixel amount to a sufficient minimum to avoid self-shadowing artifacts due to loss of precision
Renderer.cpp:835:        unsigned numSplits = light->GetNumShadowSplits();
Renderer.cpp:867:    unsigned shadowMapFormat = (shadowQuality_ & SHADOWQUALITY_LOW_24BIT) ? graphics_->GetHiresShadowMapFormat() :
Renderer.cpp:868:        graphics_->GetShadowMapFormat();
Renderer.cpp:874:    unsigned dummyColorFormat = graphics_->GetDummyColorFormat();
Renderer.cpp:878:        if (!newShadowMap->SetSize(width, height, shadowMapFormat, TEXTURE_DEPTHSTENCIL))
Renderer.cpp:882:            --retries;
Renderer.cpp:888:            newShadowMap->SetFilterMode(FILTER_BILINEAR);
Renderer.cpp:889:            newShadowMap->SetShadowCompare(true);
Renderer.cpp:894:            newShadowMap->SetFilterMode(graphics_->GetHardwareShadowSupport() ? FILTER_BILINEAR : FILTER_NEAREST);
Renderer.cpp:904:                    colorShadowMaps_[searchKey]->SetSize(width, height, dummyColorFormat, TEXTURE_RENDERTARGET);
Renderer.cpp:907:                newShadowMap->GetRenderSurface()->SetLinkedRenderTarget(colorShadowMaps_[searchKey]->GetRenderSurface());
Renderer.cpp:952:    // Reuse depth-stencil buffers whenever the size matches, instead of allocating new
Renderer.cpp:964:            newTex2D->SetSize(width, height, format, depthStencil ? TEXTURE_DEPTHSTENCIL : TEXTURE_RENDERTARGET);
Renderer.cpp:972:                graphics_->ResetRenderTargets();
Renderer.cpp:973:                graphics_->SetRenderTarget(0, newTex2D);
Renderer.cpp:974:                graphics_->SetDepthStencil((RenderSurface*)0);
Renderer.cpp:975:                graphics_->SetViewport(IntRect(0, 0, width, height));
Renderer.cpp:976:                graphics_->Clear(CLEAR_COLOR);
Renderer.cpp:985:            newTexCube->SetSize(width, format, TEXTURE_RENDERTARGET);
Renderer.cpp:990:        newBuffer->SetSRGB(srgb);
Renderer.cpp:991:        newBuffer->SetFilterMode(filtered ? FILTER_BILINEAR : FILTER_NEAREST);
Renderer.cpp:992:        newBuffer->ResetUseTimer();
Renderer.cpp:1001:        buffer->ResetUseTimer();
Renderer.cpp:1008:    // Return the default depth-stencil surface if applicable
Renderer.cpp:1010:    if (width == graphics_->GetWidth() && height == graphics_->GetHeight() && graphics_->GetMultiSample() <= 1)
Renderer.cpp:1014:        return static_cast<Texture2D*>(GetScreenBuffer(width, height, Graphics::GetDepthStencilFormat(), false, false, false))->
Renderer.cpp:1029:    int height = (int)((float)occlusionBufferSize_ / camera->GetAspectRatio() + 0.5f);
Renderer.cpp:1032:    buffer->SetSize(width, height);
Renderer.cpp:1033:    buffer->SetView(camera);
Renderer.cpp:1034:    buffer->ResetUseTimer();
Renderer.cpp:1047:        newNode->CreateComponent<Camera>();
Renderer.cpp:1051:    Camera* camera = shadowCameraNodes_[numShadowCameras_++]->GetComponent<Camera>();
Renderer.cpp:1052:    camera->SetOrthographic(false);
Renderer.cpp:1053:    camera->SetZoom(1.0f);
Renderer.cpp:1062:    Vector<SharedPtr<ShaderVariation> >& vertexShaders = pass->GetVertexShaders();
Renderer.cpp:1063:    Vector<SharedPtr<ShaderVariation> >& pixelShaders = pass->GetPixelShaders();
Renderer.cpp:1064:    if (!vertexShaders.Size() || !pixelShaders.Size() || pass->GetShadersLoadedFrameNumber() !=
Renderer.cpp:1068:        pass->ReleaseShaders();
Renderer.cpp:1075:        bool heightFog = batch.zone_ && batch.zone_->GetHeightFog();
Renderer.cpp:1085:        if (pass->GetLightingMode() == LIGHTING_PERPIXEL)
Renderer.cpp:1096:            Light* light = lightQueue->light_;
Renderer.cpp:1101:            bool materialHasSpecular = batch.material_ ? batch.material_->GetSpecular() : true;
Renderer.cpp:1102:            if (specularLighting_ && light->GetSpecularIntensity() > 0.0f && materialHasSpecular)
Renderer.cpp:1104:            if (allowShadows && lightQueue->shadowMap_)
Renderer.cpp:1110:            switch (light->GetLightType())
Renderer.cpp:1122:                if (light->GetShapeTexture())
Renderer.cpp:1139:            if (pass->GetLightingMode() == LIGHTING_PERVERTEX)
Renderer.cpp:1143:                    numVertexLights = batch.lightQueue_->vertexLights_.Size();
Renderer.cpp:1164:            LOGERROR("Technique " + tech->GetName() + " has missing shaders");
Renderer.cpp:1175:    Light* light = batch.lightQueue_->light_;
Renderer.cpp:1177:    switch (light->GetLightType())
Renderer.cpp:1188:        if (light->GetShapeTexture())
Renderer.cpp:1195:    if (batch.lightQueue_->shadowMap_)
Renderer.cpp:1198:    if (specularLighting_ && light->GetSpecularIntensity() > 0.0f)
Renderer.cpp:1201:    if (batch.camera_->IsOrthographic())
Renderer.cpp:1208:        batch.vertexShader_ = graphics_->GetShader(VS, vsName, deferredLightVSVariations[vsi] + vsDefines);
Renderer.cpp:1210:        batch.vertexShader_ = graphics_->GetShader(VS, vsName, deferredLightVSVariations[vsi]);
Renderer.cpp:1213:        batch.pixelShader_ = graphics_->GetShader(PS, psName, deferredLightPSVariations_[psi] + psDefines);
Renderer.cpp:1215:        batch.pixelShader_ = graphics_->GetShader(PS, psName, deferredLightPSVariations_[psi]);
Renderer.cpp:1221:    if (camera && camera->GetReverseCulling())
Renderer.cpp:1229:    graphics_->SetCullMode(mode);
Renderer.cpp:1237:    unsigned oldSize = instancingBuffer_->GetVertexCount();
Renderer.cpp:1245:    if (!instancingBuffer_->SetSize(newSize, INSTANCING_BUFFER_MASK, true))
Renderer.cpp:1249:        instancingBuffer_->SetSize(oldSize, INSTANCING_BUFFER_MASK, true);
Renderer.cpp:1270:    if (light && light->GetLightType() != LIGHT_DIRECTIONAL)
Renderer.cpp:1271:        graphics_->SetScissorTest(true, GetLightScissor(light, camera));
Renderer.cpp:1273:        graphics_->SetScissorTest(false);
Renderer.cpp:1280:        LightType type = light->GetLightType();
Renderer.cpp:1283:            graphics_->SetStencilTest(false);
Renderer.cpp:1288:        const Matrix3x4& view = camera->GetView();
Renderer.cpp:1289:        const Matrix4& projection = camera->GetProjection();
Renderer.cpp:1290:        Vector3 cameraPos = camera->GetNode()->GetWorldPosition();
Renderer.cpp:1294:            lightDist = Sphere(light->GetNode()->GetWorldPosition(), light->GetRange() * 1.25f).Distance(cameraPos);
Renderer.cpp:1296:            lightDist = light->GetFrustum().Distance(cameraPos);
Renderer.cpp:1301:            graphics_->SetStencilTest(false);
Renderer.cpp:1308:            graphics_->Clear(CLEAR_STENCIL);
Renderer.cpp:1314:        if (lightDist < camera->GetNearClip() * 2.0f)
Renderer.cpp:1317:            graphics_->SetDepthTest(CMP_GREATER);
Renderer.cpp:1322:            graphics_->SetDepthTest(CMP_LESSEQUAL);
Renderer.cpp:1325:        graphics_->SetColorWrite(false);
Renderer.cpp:1326:        graphics_->SetDepthWrite(false);
Renderer.cpp:1327:        graphics_->SetStencilTest(true, CMP_ALWAYS, OP_REF, OP_KEEP, OP_KEEP, lightStencilValue_);
Renderer.cpp:1328:        graphics_->SetShaders(graphics_->GetShader(VS, "Stencil"), graphics_->GetShader(PS, "Stencil"));
Renderer.cpp:1329:        graphics_->SetShaderParameter(VSP_VIEWPROJ, projection * view);
Renderer.cpp:1330:        graphics_->SetShaderParameter(VSP_MODEL, light->GetVolumeTransform(camera));
Renderer.cpp:1332:        geometry->Draw(graphics_);
Renderer.cpp:1334:        graphics_->ClearTransformSources();
Renderer.cpp:1335:        graphics_->SetColorWrite(true);
Renderer.cpp:1336:        graphics_->SetStencilTest(true, CMP_EQUAL, OP_KEEP, OP_KEEP, OP_KEEP, lightStencilValue_);
Renderer.cpp:1342:        graphics_->SetStencilTest(false);
Renderer.cpp:1351:        return i->second_;
Renderer.cpp:1353:    const Matrix3x4& view = camera->GetView();
Renderer.cpp:1354:    const Matrix4& projection = camera->GetProjection();
Renderer.cpp:1356:    assert(light->GetLightType() != LIGHT_DIRECTIONAL);
Renderer.cpp:1357:    if (light->GetLightType() == LIGHT_SPOT)
Renderer.cpp:1359:        Frustum viewFrustum(light->GetFrustum().Transformed(view));
Renderer.cpp:1364:        BoundingBox viewBox(light->GetWorldBoundingBox().Transformed(view));
Renderer.cpp:1378:    for (unsigned i = occlusionBuffers_.Size() - 1; i < occlusionBuffers_.Size(); --i)
Renderer.cpp:1380:        if (occlusionBuffers_[i]->GetUseTimer() > MAX_BUFFER_AGE)
Renderer.cpp:1390:        Vector<SharedPtr<Texture> >& buffers = current->second_;
Renderer.cpp:1391:        for (unsigned j = buffers.Size() - 1; j < buffers.Size(); --j)
Renderer.cpp:1394:            if (buffer->GetUseTimer() > MAX_BUFFER_AGE)
Renderer.cpp:1396:                LOGDEBUG("Removed unused screen buffer size " + String(buffer->GetWidth()) + "x" + String(buffer->GetHeight()) + " format " + String(buffer->GetFormat()));
Renderer.cpp:1402:            screenBufferAllocations_.Erase(current->first_);
Renderer.cpp:1411:        i->second_.Clear();
Renderer.cpp:1417:        i->second_ = 0;
Renderer.cpp:1425:    if (!graphics || !graphics->IsInitialized() || !cache)
Renderer.cpp:1432:    if (!graphics_->GetShadowMapFormat())
Renderer.cpp:1437:    defaultLightRamp_ = cache->GetResource<Texture2D>("Textures/Ramp.png");
Renderer.cpp:1438:    defaultLightSpot_ = cache->GetResource<Texture2D>("Textures/Spot.png");
Renderer.cpp:1442:    defaultRenderPath_->Load(cache->GetResource<XMLFile>("RenderPaths/Forward.xml"));
Renderer.cpp:1465:    shadersChangedFrameNumber_ = GetSubsystem<Time>()->GetFrameNumber();
Renderer.cpp:1469:    unsigned shadows = (graphics_->GetHardwareShadowSupport() ? 1 : 0) | (shadowQuality_ & SHADOWQUALITY_HIGH_16BIT);
Renderer.cpp:1486:    unsigned shadows = (graphics_->GetHardwareShadowSupport() ? 1 : 0) | (shadowQuality_ & SHADOWQUALITY_HIGH_16BIT);
Renderer.cpp:1488:    Vector<SharedPtr<ShaderVariation> >& vertexShaders = pass->GetVertexShaders();
Renderer.cpp:1489:    Vector<SharedPtr<ShaderVariation> >& pixelShaders = pass->GetPixelShaders();
Renderer.cpp:1495:    if (pass->GetLightingMode() == LIGHTING_PERPIXEL)
Renderer.cpp:1506:            vertexShaders[j] = graphics_->GetShader(VS, pass->GetVertexShader(), pass->GetVertexShaderDefines() + " " +
Renderer.cpp:1516:                pixelShaders[j] = graphics_->GetShader(PS, pass->GetPixelShader(), pass->GetPixelShaderDefines() + " " +
Renderer.cpp:1520:                pixelShaders[j] = graphics_->GetShader(PS, pass->GetPixelShader(), pass->GetPixelShaderDefines() + " " +
Renderer.cpp:1527:        if (pass->GetLightingMode() == LIGHTING_PERVERTEX)
Renderer.cpp:1534:                vertexShaders[j] = graphics_->GetShader(VS, pass->GetVertexShader(), pass->GetVertexShaderDefines() + " " +
Renderer.cpp:1543:                vertexShaders[j] = graphics_->GetShader(VS, pass->GetVertexShader(), pass->GetVertexShaderDefines() + " " +
Renderer.cpp:1551:            pixelShaders[j] = graphics_->GetShader(PS, pass->GetPixelShader(), pass->GetPixelShaderDefines() + " " +
Renderer.cpp:1556:    pass->MarkShadersLoaded(shadersChangedFrameNumber_);
Renderer.cpp:1564:    cache->GetResources<Material>(materials);
Renderer.cpp:1567:        materials[i]->ReleaseShaders();
Renderer.cpp:1575:    cache->GetResources(textures, Texture2D::GetTypeStatic());
Renderer.cpp:1577:        cache->ReloadResource(textures[i]);
Renderer.cpp:1579:    cache->GetResources(textures, TextureCube::GetTypeStatic());
Renderer.cpp:1581:        cache->ReloadResource(textures[i]);
Renderer.cpp:1587:    dlvb->SetShadowed(true);
Renderer.cpp:1588:    dlvb->SetSize(4, MASK_POSITION);
Renderer.cpp:1589:    dlvb->SetData(dirLightVertexData);
Renderer.cpp:1592:    dlib->SetShadowed(true);
Renderer.cpp:1593:    dlib->SetSize(6, false);
Renderer.cpp:1594:    dlib->SetData(dirLightIndexData);
Renderer.cpp:1597:    dirLightGeometry_->SetVertexBuffer(0, dlvb);
Renderer.cpp:1598:    dirLightGeometry_->SetIndexBuffer(dlib);
Renderer.cpp:1599:    dirLightGeometry_->SetDrawRange(TRIANGLE_LIST, 0, dlib->GetIndexCount());
Renderer.cpp:1602:    slvb->SetShadowed(true);
Renderer.cpp:1603:    slvb->SetSize(8, MASK_POSITION);
Renderer.cpp:1604:    slvb->SetData(spotLightVertexData);
Renderer.cpp:1607:    slib->SetShadowed(true);
Renderer.cpp:1608:    slib->SetSize(36, false);
Renderer.cpp:1609:    slib->SetData(spotLightIndexData);
Renderer.cpp:1612:    spotLightGeometry_->SetVertexBuffer(0, slvb);
Renderer.cpp:1613:    spotLightGeometry_->SetIndexBuffer(slib);
Renderer.cpp:1614:    spotLightGeometry_->SetDrawRange(TRIANGLE_LIST, 0, slib->GetIndexCount());
Renderer.cpp:1617:    plvb->SetShadowed(true);
Renderer.cpp:1618:    plvb->SetSize(24, MASK_POSITION);
Renderer.cpp:1619:    plvb->SetData(pointLightVertexData);
Renderer.cpp:1622:    plib->SetShadowed(true);
Renderer.cpp:1623:    plib->SetSize(132, false);
Renderer.cpp:1624:    plib->SetData(pointLightIndexData);
Renderer.cpp:1627:    pointLightGeometry_->SetVertexBuffer(0, plvb);
Renderer.cpp:1628:    pointLightGeometry_->SetIndexBuffer(plib);
Renderer.cpp:1629:    pointLightGeometry_->SetDrawRange(TRIANGLE_LIST, 0, plib->GetIndexCount());
Renderer.cpp:1632:    if (graphics_->GetShadowMapFormat())
Renderer.cpp:1635:        faceSelectCubeMap_->SetNumLevels(1);
Renderer.cpp:1636:        faceSelectCubeMap_->SetSize(1, graphics_->GetRGBAFormat());
Renderer.cpp:1637:        faceSelectCubeMap_->SetFilterMode(FILTER_NEAREST);
Renderer.cpp:1640:        indirectionCubeMap_->SetNumLevels(1);
Renderer.cpp:1641:        indirectionCubeMap_->SetSize(256, graphics_->GetRGBAFormat());
Renderer.cpp:1642:        indirectionCubeMap_->SetFilterMode(FILTER_BILINEAR);
Renderer.cpp:1643:        indirectionCubeMap_->SetAddressMode(COORD_U, ADDRESS_CLAMP);
Renderer.cpp:1644:        indirectionCubeMap_->SetAddressMode(COORD_V, ADDRESS_CLAMP);
Renderer.cpp:1645:        indirectionCubeMap_->SetAddressMode(COORD_W, ADDRESS_CLAMP);
Renderer.cpp:1663:        faceSelectCubeMap_->SetData((CubeMapFace)i, 0, 0, 0, 1, 1, data);
Renderer.cpp:1677:                dest[1] = 255 - y;
Renderer.cpp:1679:                dest[3] = 255 * 2 / 3 - faceY;
Renderer.cpp:1690:        indirectionCubeMap_->SetData((CubeMapFace)i, 0, 0, 0, 256, 256, data);
Renderer.cpp:1693:    faceSelectCubeMap_->ClearDataLost();
Renderer.cpp:1694:    indirectionCubeMap_->ClearDataLost();
Renderer.cpp:1700:    if (!graphics_->GetInstancingSupport())
Renderer.cpp:1708:    if (!instancingBuffer_->SetSize(INSTANCING_BUFFER_DEFAULT_SIZE, INSTANCING_BUFFER_MASK, true))
Shader.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Shader.cpp:55:            --braceLevel;
Shader.cpp:76:    cache->ResetDependencies(this);
Shader.cpp:81:    context->RegisterFactory<Shader>();
Shader.cpp:117:        i->second_->Release();
Shader.cpp:119:        i->second_->Release();
Shader.cpp:143:            variations.Insert(MakePair(definesHash, i->second_));
Shader.cpp:149:                variations.Insert(MakePair(definesHash, i->second_));
Shader.cpp:151:            i->second_->SetName(GetFileName(GetName()));
Shader.cpp:152:            i->second_->SetDefines(normalizedDefines);
Shader.cpp:158:    return i->second_;
Shader.cpp:165:    // If the source if a non-packaged file, store the timestamp
Shader.cpp:167:    if (file && !file->IsPackaged())
Shader.cpp:170:        String fullName = cache->GetResourceFileName(file->GetName());
Shader.cpp:171:        unsigned fileTimeStamp = fileSystem->GetLastModifiedTime(fullName);
Shader.cpp:178:        cache->StoreResourceDependency(this, source.GetName());
Shader.cpp:188:            SharedPtr<File> includeFile = cache->GetFile(includeFileName);
Shader.h:2:// Copyright (c) 2008-2015 the Urho3D project.
ShaderPrecache.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
ShaderPrecache.cpp:41:    if (GetSubsystem<FileSystem>()->FileExists(fileName))
ShaderPrecache.cpp:87:    String vsName = vs->GetName();
ShaderPrecache.cpp:88:    String psName = ps->GetName();
ShaderPrecache.cpp:89:    const String& vsDefines = vs->GetDefines();
ShaderPrecache.cpp:90:    const String& psDefines = ps->GetDefines();
ShaderPrecache.cpp:109:    XMLFile xmlFile(graphics->GetContext());
ShaderPrecache.cpp:127:        ShaderVariation* vs = graphics->GetShader(VS, shader.GetAttribute("vs"), vsDefines);
ShaderPrecache.cpp:128:        ShaderVariation* ps = graphics->GetShader(PS, shader.GetAttribute("ps"), psDefines);
ShaderPrecache.cpp:130:        graphics->SetShaders(vs, ps);
ShaderPrecache.h:2:// Copyright (c) 2008-2015 the Urho3D project.
ShaderProgram.h:2:// Copyright (c) 2008-2015 the Urho3D project.
ShaderVariation.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Skeleton.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Skeleton.h:74:    /// Local-space bounding box.
Skeleton.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Skeleton.cpp:113:        i->node_.Reset();
Skeleton.cpp:135:        if (i->animated_ && i->node_)
Skeleton.cpp:136:            i->node_->SetTransform(i->initialPosition_, i->initialRotation_, i->initialScale_);
Skeleton.cpp:144:        if (i->animated_ && i->node_)
Skeleton.cpp:145:            i->node_->SetTransformSilent(i->initialPosition_, i->initialRotation_, i->initialScale_);
Skeleton.cpp:174:        if (i->nameHash_ == nameHash)
Skybox.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Skybox.cpp:48:    context->RegisterFactory<Skybox>(GEOMETRY_CATEGORY);
Skybox.cpp:69:    Matrix3x4 customWorldTransform = node_->GetWorldTransform();
Skybox.cpp:70:    customWorldTransform.SetTranslation(node_->GetWorldPosition() + frame.camera_->GetEffectiveWorldTransform().Translation());
Skybox.cpp:75:        batches_[i].worldTransform_ = &it->second_;
Skybox.cpp:83:    worldBoundingBox_.Define(-M_LARGE_VALUE, M_LARGE_VALUE);
Skybox.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Skybox.h:45:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
Skybox.h:49:    /// Recalculate the world-space bounding box.
StaticModel.h:2:// Copyright (c) 2008-2015 the Urho3D project.
StaticModel.h:32:/// Static model per-geometry extra data.
StaticModel.h:56:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
StaticModel.h:99:    /// Recalculate the world-space bounding box.
StaticModel.h:101:    /// Set local-space bounding box.
StaticModel.h:110:    /// Extra per-geometry data.
StaticModelGroup.h:2:// Copyright (c) 2008-2015 the Urho3D project.
StaticModelGroup.h:30:/// Renders several object instances while culling and receiving light as one unit. Can be used as a CPU-side optimization, but note that also regular StaticModels will use instanced rendering if possible.
StaticModelGroup.h:47:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
StaticModelGroup.h:74:    /// Recalculate the world-space bounding box.
StaticModel.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
StaticModel.cpp:58:    context->RegisterFactory<StaticModel>(GEOMETRY_CATEGORY);
StaticModel.cpp:85:        Matrix3x4 inverse(node_->GetWorldTransform().Inverse());
StaticModel.cpp:88:        Vector3 normal = -query.ray_.direction_;
StaticModel.cpp:101:                    float geometryDistance = geometry->GetHitDistance(localRay, &geometryNormal);
StaticModel.cpp:105:                        normal = (node_->GetWorldTransform() * Vector4(geometryNormal, 0.0f)).Normalized();
StaticModel.cpp:130:    distance_ = frame.camera_->GetDistance(worldBoundingBox.Center());
StaticModel.cpp:136:        const Matrix3x4& worldTransform = node_->GetWorldTransform();
StaticModel.cpp:138:            batches_[i].distance_ = frame.camera_->GetDistance(worldTransform * geometryData_[i].center_);
StaticModel.cpp:142:    float newLodDistance = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
StaticModel.cpp:175:        if (mat && !mat->GetOcclusion())
StaticModel.cpp:178:        triangles += geometry->GetIndexCount() / 3;
StaticModel.cpp:196:            if (!material->GetOcclusion())
StaticModel.cpp:198:            buffer->SetCullMode(material->GetCullMode());
StaticModel.cpp:201:            buffer->SetCullMode(CULL_CCW);
StaticModel.cpp:209:        geometry->GetRawData(vertexData, vertexSize, indexData, indexSize, elementMask);
StaticModel.cpp:214:        unsigned indexStart = geometry->GetIndexStart();
StaticModel.cpp:215:        unsigned indexCount = geometry->GetIndexCount();
StaticModel.cpp:218:        if (!buffer->Draw(node_->GetWorldTransform(), vertexData, vertexSize, indexData, indexSize, indexStart, indexCount))
StaticModel.cpp:235:        animatedModel->SetModel(model);
StaticModel.cpp:250:        SetNumGeometries(model->GetNumGeometries());
StaticModel.cpp:251:        const Vector<Vector<SharedPtr<Geometry> > >& geometries = model->GetGeometries();
StaticModel.cpp:252:        const PODVector<Vector3>& geometryCenters = model->GetGeometryCenters();
StaticModel.cpp:253:        const Matrix3x4* worldTransform = node_ ? &node_->GetWorldTransform() : (const Matrix3x4*)0;
StaticModel.cpp:261:        SetBoundingBox(model->GetBoundingBox());
StaticModel.cpp:304:        useFileName = ReplaceExtension(model_->GetName(), ".txt");
StaticModel.cpp:307:    SharedPtr<File> file = cache->GetFile(useFileName, false);
StaticModel.cpp:312:    while (!file->IsEof() && index < batches_.Size())
StaticModel.cpp:314:        Material* material = cache->GetResource<Material>(file->ReadLine());
StaticModel.cpp:332:    Vector3 localPosition = node_->GetWorldTransform().Inverse() * point;
StaticModel.cpp:338:    // Early-out if point is not inside bounding box
StaticModel.cpp:342:    Ray localRay(point, Vector3(1.0f, -1.0f, 1.0f));
StaticModel.cpp:349:            if (geometry->IsInside(localRay))
StaticModel.cpp:374:    SetModel(cache->GetResource<Model>(value.name_));
StaticModel.cpp:381:        SetMaterial(i, cache->GetResource<Material>(value.names_[i]));
StaticModel.cpp:400:    worldBoundingBox_ = boundingBox_.Transformed(node_->GetWorldTransform());
StaticModel.cpp:431:            if (batchGeometries[j] && lodDistance_ <= batchGeometries[j]->GetLodDistance())
StaticModel.cpp:435:        unsigned newLodLevel = j - 1;
StaticModel.cpp:447:    model_.Reset(); // Set null to allow to be re-set
StaticModelGroup.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
StaticModelGroup.cpp:54:    context->RegisterFactory<StaticModelGroup>(GEOMETRY_CATEGORY);
StaticModelGroup.cpp:71:            node->RemoveListener(this);
StaticModelGroup.cpp:83:            Node* node = scene->GetNode(nodeIDsAttr_[i].GetUInt());
StaticModelGroup.cpp:87:                node->AddListener(this);
StaticModelGroup.cpp:100:    // If no bones or no bone-level testing, use the Drawable test
StaticModelGroup.cpp:117:        Vector3 normal = -query.ray_.direction_;
StaticModelGroup.cpp:119:        // Then proceed to OBB and triangle-level tests if necessary
StaticModelGroup.cpp:136:                        float geometryDistance = geometry->GetHitDistance(localRay, &geometryNormal);
StaticModelGroup.cpp:165:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
StaticModelGroup.cpp:166:    distance_ = frame.camera_->GetDistance(worldBoundingBox.Center());
StaticModelGroup.cpp:172:            batches_[i].distance_ = frame.camera_->GetDistance(worldTransform * geometryData_[i].center_);
StaticModelGroup.cpp:185:    float newLodDistance = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
StaticModelGroup.cpp:196:    // Make sure instance transforms are up-to-date
StaticModelGroup.cpp:209:        if (mat && !mat->GetOcclusion())
StaticModelGroup.cpp:212:        triangles += numWorldTransforms_ * geometry->GetIndexCount() / 3;
StaticModelGroup.cpp:220:    // Make sure instance transforms are up-to-date
StaticModelGroup.cpp:235:                if (!material->GetOcclusion())
StaticModelGroup.cpp:237:                buffer->SetCullMode(material->GetCullMode());
StaticModelGroup.cpp:240:                buffer->SetCullMode(CULL_CCW);
StaticModelGroup.cpp:248:            geometry->GetRawData(vertexData, vertexSize, indexData, indexSize, elementMask);
StaticModelGroup.cpp:253:            unsigned indexStart = geometry->GetIndexStart();
StaticModelGroup.cpp:254:            unsigned indexCount = geometry->GetIndexCount();
StaticModelGroup.cpp:257:            if (!buffer->Draw(worldTransforms_[i], vertexData, vertexSize, indexData, indexSize, indexStart, indexCount))
StaticModelGroup.cpp:275:    node->AddListener(this);
StaticModelGroup.cpp:289:    node->RemoveListener(this);
StaticModelGroup.cpp:303:            node->RemoveListener(this);
StaticModelGroup.cpp:333:        while (numInstances--)
StaticModelGroup.cpp:365:        if (!node || !node->IsEnabled())
StaticModelGroup.cpp:368:        const Matrix3x4& worldTransform = node->GetWorldTransform();
StaticModelGroup.cpp:392:        nodeIDsAttr_.Push(node ? node->GetID() : 0);
Tangent.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Tangent.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Tangent.cpp:82:        float x1 = v2.x_ - v1.x_;
Tangent.cpp:83:        float x2 = v3.x_ - v1.x_;
Tangent.cpp:84:        float y1 = v2.y_ - v1.y_;
Tangent.cpp:85:        float y2 = v3.y_ - v1.y_;
Tangent.cpp:86:        float z1 = v2.z_ - v1.z_;
Tangent.cpp:87:        float z2 = v3.z_ - v1.z_;
Tangent.cpp:89:        float s1 = w2.x_ - w1.x_;
Tangent.cpp:90:        float s2 = w3.x_ - w1.x_;
Tangent.cpp:91:        float t1 = w2.y_ - w1.y_;
Tangent.cpp:92:        float t2 = w3.y_ - w1.y_;
Tangent.cpp:94:        float r = 1.0f / (s1 * t2 - s2 * t1);
Tangent.cpp:95:        Vector3 sdir((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r,
Tangent.cpp:96:                (t2 * z1 - t1 * z2) * r);
Tangent.cpp:97:        Vector3 tdir((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r,
Tangent.cpp:98:                (s1 * z2 - s2 * z1) * r);
Tangent.cpp:116:        // Gram-Schmidt orthogonalize
Tangent.cpp:117:        xyz = (t - n * n.DotProduct(t)).Normalized();
Tangent.cpp:120:        w = n.CrossProduct(t).DotProduct(tan2[i]) < 0.0f ? -1.0f : 1.0f;
Technique.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Technique.cpp:188:    context->RegisterFactory<Technique>();
Technique.cpp:198:    if (!xml->Load(source))
Technique.cpp:201:    XMLElement rootElem = xml->GetRoot();
Technique.cpp:209:    // End with space so that the pass-specific defines can be appended
Technique.cpp:226:                newPass->SetIsDesktop(passElem.GetBool("desktop"));
Technique.cpp:231:                newPass->SetVertexShader(passElem.GetAttribute("vs"));
Technique.cpp:232:                newPass->SetVertexShaderDefines(passElem.GetAttribute("vsdefines"));
Technique.cpp:236:                newPass->SetVertexShader(globalVS);
Technique.cpp:237:                newPass->SetVertexShaderDefines(globalVSDefines + passElem.GetAttribute("vsdefines"));
Technique.cpp:241:                newPass->SetPixelShader(passElem.GetAttribute("ps"));
Technique.cpp:242:                newPass->SetPixelShaderDefines(passElem.GetAttribute("psdefines"));
Technique.cpp:246:                newPass->SetPixelShader(globalPS);
Technique.cpp:247:                newPass->SetPixelShaderDefines(globalPSDefines + passElem.GetAttribute("psdefines"));
Technique.cpp:253:                newPass->SetLightingMode((PassLightingMode)GetStringListIndex(lighting.CString(), lightingModeNames,
Technique.cpp:260:                newPass->SetBlendMode((BlendMode)GetStringListIndex(blend.CString(), blendModeNames, BLEND_REPLACE));
Technique.cpp:267:                    newPass->SetDepthTestMode(CMP_ALWAYS);
Technique.cpp:269:                    newPass->SetDepthTestMode((CompareMode)GetStringListIndex(depthTest.CString(), compareModeNames, CMP_LESS));
Technique.cpp:273:                newPass->SetDepthWrite(passElem.GetBool("depthwrite"));
Technique.cpp:276:                newPass->SetAlphaMask(passElem.GetBool("alphamask"));
Technique.cpp:278:                newPass->SetAlphaMask(globalAlphaMask);
Technique.cpp:298:        Pass* pass = i->Get();
Technique.cpp:300:            pass->ReleaseShaders();
Technique.cpp:311:    unsigned passIndex = newPass->GetIndex();
Technique.cpp:327:    else if (i->second_ < passes_.Size() && passes_[i->second_].Get())
Technique.cpp:329:        passes_[i->second_].Reset();
Technique.cpp:337:    return i != passIndices.End() ? HasPass(i->second_) : false;
Technique.cpp:343:    return i != passIndices.End() ? GetPass(i->second_) : 0;
Technique.cpp:349:    return i != passIndices.End() ? GetSupportedPass(i->second_) : 0;
Technique.cpp:358:        if (i->Get())
Technique.cpp:371:        Pass* pass = i->Get();
Technique.cpp:373:            ret.Push(pass->GetName());
Technique.cpp:385:        Pass* pass = i->Get();
Technique.cpp:395:    // Initialize built-in pass indices on first call
Technique.cpp:411:        return i->second_;
Technique.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Technique.h:77:    /// Return pass index. This is used for optimal render-time pass queries that avoid map lookups.
Technique.h:172:    /// Return whether has a pass by name. This overload should not be called in time-critical rendering loops; use a pre-acquired pass index instead.
Technique.h:176:    /// Return a pass by name, or null if not found. This overload should not be called in time-critical rendering loops; use a pre-acquired pass index instead.
Technique.h:183:        return pass && (!pass->IsDesktop() || desktopSupport_) ? pass : 0;
Technique.h:186:    /// Return a supported pass by name. This overload should not be called in time-critical rendering loops; use a pre-acquired pass index instead.
Technique.h:205:    /// Index for deferred G-buffer pass. Initialized once GetPassIndex() has been called for the first time.
Technique.h:207:    /// Index for per-pixel light pass. Initialized once GetPassIndex() has been called for the first time.
Terrain.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Terrain.cpp:105:    indexBuffer_->SetShadowed(true);
Terrain.cpp:114:    context->RegisterFactory<Terrain>(GEOMETRY_CATEGORY);
Terrain.cpp:139:    // Change of any non-accessor attribute requires recreation of the terrain
Terrain.cpp:157:            patches_[i]->SetEnabled(enabled);
Terrain.cpp:211:            patches_[i]->SetMaterial(material);
Terrain.cpp:223:            patches_[i]->SetDrawDistance(distance);
Terrain.cpp:235:            patches_[i]->SetShadowDistance(distance);
Terrain.cpp:247:            patches_[i]->SetLodBias(bias);
Terrain.cpp:259:            patches_[i]->SetViewMask(mask);
Terrain.cpp:271:            patches_[i]->SetLightMask(mask);
Terrain.cpp:283:            patches_[i]->SetShadowMask(mask);
Terrain.cpp:295:            patches_[i]->SetZoneMask(mask);
Terrain.cpp:307:            patches_[i]->SetMaxLights(num);
Terrain.cpp:319:            patches_[i]->SetCastShadows(enable);
Terrain.cpp:331:            patches_[i]->SetOccluder(enable);
Terrain.cpp:343:            patches_[i]->SetOccludee(enable);
Terrain.cpp:382:        Vector3 position = node_->GetWorldTransform().Inverse() * worldPosition;
Terrain.cpp:383:        float xPos = (position.x_ - patchWorldOrigin_.x_) / spacing_.x_;
Terrain.cpp:384:        float zPos = (position.z_ - patchWorldOrigin_.y_) / spacing_.z_;
Terrain.cpp:385:        float xFrac = xPos - floorf(xPos);
Terrain.cpp:386:        float zFrac = zPos - floorf(zPos);
Terrain.cpp:394:            xFrac = 1.0f - xFrac;
Terrain.cpp:395:            zFrac = 1.0f - zFrac;
Terrain.cpp:404:        float h = h1 * (1.0f - xFrac - zFrac) + h2 * xFrac + h3 * zFrac;
Terrain.cpp:406:        return node_->GetWorldScale().y_ * h + node_->GetWorldPosition().y_;
Terrain.cpp:416:        Vector3 position = node_->GetWorldTransform().Inverse() * worldPosition;
Terrain.cpp:417:        float xPos = (position.x_ - patchWorldOrigin_.x_) / spacing_.x_;
Terrain.cpp:418:        float zPos = (position.z_ - patchWorldOrigin_.y_) / spacing_.z_;
Terrain.cpp:419:        float xFrac = xPos - floorf(xPos);
Terrain.cpp:420:        float zFrac = zPos - floorf(zPos);
Terrain.cpp:428:            xFrac = 1.0f - xFrac;
Terrain.cpp:429:            zFrac = 1.0f - zFrac;
Terrain.cpp:438:        Vector3 n = (n1 * (1.0f - xFrac - zFrac) + n2 * xFrac + n3 * zFrac).Normalized();
Terrain.cpp:439:        return node_->GetWorldRotation() * n;
Terrain.cpp:450:    Vector3 position = node_->GetWorldTransform().Inverse() * worldPosition;
Terrain.cpp:451:    int xPos = (int)((position.x_ - patchWorldOrigin_.x_) / spacing_.x_);
Terrain.cpp:452:    int zPos = (int)((position.z_ - patchWorldOrigin_.y_) / spacing_.z_);
Terrain.cpp:456:    return IntVector2(xPos, numVertices_.y_ - zPos);
Terrain.cpp:464:    VertexBuffer* vertexBuffer = patch->GetVertexBuffer();
Terrain.cpp:465:    Geometry* geometry = patch->GetGeometry();
Terrain.cpp:466:    Geometry* maxLodGeometry = patch->GetMaxLodGeometry();
Terrain.cpp:467:    Geometry* minLodGeometry = patch->GetMinLodGeometry();
Terrain.cpp:469:    if (vertexBuffer->GetVertexCount() != row * row)
Terrain.cpp:470:        vertexBuffer->SetSize(row * row, MASK_POSITION | MASK_NORMAL | MASK_TEXCOORD1 | MASK_TANGENT);
Terrain.cpp:474:    float* vertexData = (float*)vertexBuffer->Lock(0, vertexBuffer->GetVertexCount());
Terrain.cpp:480:        const IntVector2& coords = patch->GetCoordinates();
Terrain.cpp:507:                Vector2 texCoord((float)xPos / (float)numVertices_.x_, 1.0f - (float)zPos / (float)numVertices_.y_);
Terrain.cpp:512:                Vector3 xyz = (Vector3::RIGHT - normal * normal.DotProduct(Vector3::RIGHT)).Normalized();
Terrain.cpp:520:        vertexBuffer->Unlock();
Terrain.cpp:521:        vertexBuffer->ClearDataLost();
Terrain.cpp:524:    patch->SetBoundingBox(box);
Terrain.cpp:528:        unsigned lastDrawRange = drawRanges_.Size() - 1;
Terrain.cpp:530:        geometry->SetIndexBuffer(indexBuffer_);
Terrain.cpp:531:        geometry->SetDrawRange(TRIANGLE_LIST, drawRanges_[0].first_, drawRanges_[0].second_, false);
Terrain.cpp:532:        geometry->SetRawVertexData(cpuVertexData, sizeof(Vector3), MASK_POSITION);
Terrain.cpp:533:        maxLodGeometry->SetIndexBuffer(indexBuffer_);
Terrain.cpp:534:        maxLodGeometry->SetDrawRange(TRIANGLE_LIST, drawRanges_[0].first_, drawRanges_[0].second_, false);
Terrain.cpp:535:        maxLodGeometry->SetRawVertexData(cpuVertexData, sizeof(Vector3), MASK_POSITION);
Terrain.cpp:536:        minLodGeometry->SetIndexBuffer(indexBuffer_);
Terrain.cpp:537:        minLodGeometry->SetDrawRange(TRIANGLE_LIST, drawRanges_[lastDrawRange].first_, drawRanges_[lastDrawRange].second_, false);
Terrain.cpp:538:        minLodGeometry->SetRawVertexData(cpuVertexData, sizeof(Vector3), MASK_POSITION);
Terrain.cpp:541:    // Offset the occlusion geometry by vertex spacing to reduce possibility of over-aggressive occlusion
Terrain.cpp:542:    patch->SetOcclusionOffset(-0.5f * (spacing_.x_ + spacing_.z_));
Terrain.cpp:543:    patch->ResetLod();
Terrain.cpp:548:    Geometry* geometry = patch->GetGeometry();
Terrain.cpp:551:    unsigned lodLevel = patch->GetLodLevel();
Terrain.cpp:553:    if (lodLevel < numLodLevels_ - 1)
Terrain.cpp:555:        TerrainPatch* north = patch->GetNorthPatch();
Terrain.cpp:556:        TerrainPatch* south = patch->GetSouthPatch();
Terrain.cpp:557:        TerrainPatch* west = patch->GetWestPatch();
Terrain.cpp:558:        TerrainPatch* east = patch->GetEastPatch();
Terrain.cpp:560:        if (north && north->GetLodLevel() > lodLevel)
Terrain.cpp:562:        if (south && south->GetLodLevel() > lodLevel)
Terrain.cpp:564:        if (west && west->GetLodLevel() > lodLevel)
Terrain.cpp:566:        if (east && east->GetLodLevel() > lodLevel)
Terrain.cpp:571:        geometry->SetDrawRange(TRIANGLE_LIST, drawRanges_[drawRangeIndex].first_, drawRanges_[drawRangeIndex].second_, false);
Terrain.cpp:577:    SetMaterial(cache->GetResource<Material>(value.name_));
Terrain.cpp:583:    Image* image = cache->GetResource<Image>(value.name_);
Terrain.cpp:635:        numPatches_ = IntVector2((heightMap_->GetWidth() - 1) / patchSize_, (heightMap_->GetHeight() - 1) / patchSize_);
Terrain.cpp:637:        patchWorldOrigin_ = Vector2(-0.5f * (float)numPatches_.x_ * patchWorldSize_.x_, -0.5f * (float)numPatches_.y_ *
Terrain.cpp:675:        node_->GetChildrenWithComponent<TerrainPatch>(oldPatchNodes);
Terrain.cpp:679:            Vector<String> coords = (*i)->GetName().Substring(6).Split('_');
Terrain.cpp:689:                node_->RemoveChild(*i);
Terrain.cpp:703:        const unsigned char* src = heightMap_->GetData();
Terrain.cpp:705:        unsigned imgComps = heightMap_->GetComponents();
Terrain.cpp:706:        unsigned imgRow = heightMap_->GetWidth() * imgComps;
Terrain.cpp:707:        IntRect updateRegion(-1, -1, -1, -1);
Terrain.cpp:717:                    float newHeight = (float)src[imgRow * (numVertices_.y_ - 1 - z) + x] * spacing_.y_;
Terrain.cpp:743:                    float newHeight = ((float)src[imgRow * (numVertices_.y_ - 1 - z) + imgComps * x] + (float)src[imgRow *
Terrain.cpp:744:                        (numVertices_.y_ - 1 - z) + imgComps * x + 1] / 256.0f) * spacing_.y_;
Terrain.cpp:765:            int lodExpand = 1 << (numLodLevels_ - 1);
Terrain.cpp:767:            updateRegion.left_ -= lodExpand;
Terrain.cpp:769:            updateRegion.top_ -= lodExpand;
Terrain.cpp:773:            int eX = Min(updateRegion.right_ / patchSize_, numPatches_.x_ - 1);
Terrain.cpp:775:            int eY = Min(updateRegion.bottom_ / patchSize_, numPatches_.y_ - 1);
Terrain.cpp:796:                    Node* patchNode = node_->GetChild(nodeName);
Terrain.cpp:802:                        patchNode = node_->CreateChild(nodeName, LOCAL);
Terrain.cpp:803:                        patchNode->SetTemporary(true);
Terrain.cpp:806:                    patchNode->SetPosition(Vector3(patchWorldOrigin_.x_ + (float)x * patchWorldSize_.x_, 0.0f, patchWorldOrigin_.y_ +
Terrain.cpp:809:                    TerrainPatch* patch = patchNode->GetComponent<TerrainPatch>();
Terrain.cpp:812:                        patch = patchNode->CreateComponent<TerrainPatch>();
Terrain.cpp:813:                        patch->SetOwner(this);
Terrain.cpp:814:                        patch->SetCoordinates(IntVector2(x, z));
Terrain.cpp:817:                        patch->SetEnabled(enabled);
Terrain.cpp:818:                        patch->SetMaterial(material_);
Terrain.cpp:819:                        patch->SetDrawDistance(drawDistance_);
Terrain.cpp:820:                        patch->SetShadowDistance(shadowDistance_);
Terrain.cpp:821:                        patch->SetLodBias(lodBias_);
Terrain.cpp:822:                        patch->SetViewMask(viewMask_);
Terrain.cpp:823:                        patch->SetLightMask(lightMask_);
Terrain.cpp:824:                        patch->SetShadowMask(shadowMask_);
Terrain.cpp:825:                        patch->SetZoneMask(zoneMask_);
Terrain.cpp:826:                        patch->SetMaxLights(maxLights_);
Terrain.cpp:827:                        patch->SetCastShadows(castShadows_);
Terrain.cpp:828:                        patch->SetOccluder(occluder_);
Terrain.cpp:829:                        patch->SetOccludee(occludee_);
Terrain.cpp:851:                    const IntVector2& coords = patch->GetCoordinates();
Terrain.cpp:862:                                GetSourceHeight(x - 1, z - 1) + GetSourceHeight(x, z - 1) * 2.0f + GetSourceHeight(x + 1, z - 1) +
Terrain.cpp:863:                                GetSourceHeight(x - 1, z) * 2.0f + GetSourceHeight(x, z) * 4.0f + GetSourceHeight(x + 1, z) * 2.0f +
Terrain.cpp:864:                                GetSourceHeight(x - 1, z + 1) + GetSourceHeight(x, z + 1) * 2.0f + GetSourceHeight(x + 1, z + 1)
Terrain.cpp:895:        node_->SendEvent(E_TERRAINCREATED, eventData);
Terrain.cpp:911:       +----+----+      +---------+
Terrain.cpp:916:       +----+----+      +----+----+
Terrain.cpp:920:        unsigned combinations = (i < numLodLevels_ - 1) ? 16 : 1;
Terrain.cpp:933:                zEnd -= skip;
Terrain.cpp:939:                xEnd -= skip;
Terrain.cpp:958:                int z = patchSize_ - skip;
Terrain.cpp:970:                    if (x < patchSize_ - skip * 2 || (j & STITCH_EAST) == 0)
Terrain.cpp:994:                    if (x < patchSize_ - skip * 2 || (j & STITCH_EAST) == 0)
Terrain.cpp:1018:                    if (x < patchSize_ - skip * 2 || (j & STITCH_NORTH) == 0)
Terrain.cpp:1030:                int x = patchSize_ - skip;
Terrain.cpp:1042:                    if (z < patchSize_ - skip * 2 || (j & STITCH_NORTH) == 0)
Terrain.cpp:1051:            drawRanges_.Push(MakePair(indexStart, indices.Size() - indexStart));
Terrain.cpp:1055:    indexBuffer_->SetSize(indices.Size(), false);
Terrain.cpp:1056:    indexBuffer_->SetData(&indices[0]);
Terrain.cpp:1064:    x = Clamp(x, 0, numVertices_.x_ - 1);
Terrain.cpp:1065:    z = Clamp(z, 0, numVertices_.y_ - 1);
Terrain.cpp:1074:    x = Clamp(x, 0, numVertices_.x_ - 1);
Terrain.cpp:1075:    z = Clamp(z, 0, numVertices_.y_ - 1);
Terrain.cpp:1092:        xFrac = 1.0f - xFrac;
Terrain.cpp:1093:        zFrac = 1.0f - zFrac;
Terrain.cpp:1102:    return h1 * (1.0f - xFrac - zFrac) + h2 * xFrac + h3 * zFrac;
Terrain.cpp:1108:    float nSlope = GetRawHeight(x, z - 1) - baseHeight;
Terrain.cpp:1109:    float neSlope = GetRawHeight(x + 1, z - 1) - baseHeight;
Terrain.cpp:1110:    float eSlope = GetRawHeight(x + 1, z) - baseHeight;
Terrain.cpp:1111:    float seSlope = GetRawHeight(x + 1, z + 1) - baseHeight;
Terrain.cpp:1112:    float sSlope = GetRawHeight(x, z + 1) - baseHeight;
Terrain.cpp:1113:    float swSlope = GetRawHeight(x - 1, z + 1) - baseHeight;
Terrain.cpp:1114:    float wSlope = GetRawHeight(x - 1, z) - baseHeight;
Terrain.cpp:1115:    float nwSlope = GetRawHeight(x - 1, z - 1) - baseHeight;
Terrain.cpp:1119:        Vector3(-neSlope, up, neSlope) +
Terrain.cpp:1120:        Vector3(-eSlope, up, 0.0f) +
Terrain.cpp:1121:        Vector3(-seSlope, up, -seSlope) +
Terrain.cpp:1122:        Vector3(0.0f, up, -sSlope) +
Terrain.cpp:1123:        Vector3(swSlope, up, -swSlope) +
Terrain.cpp:1132:    const IntVector2& coords = patch->GetCoordinates();
Terrain.cpp:1133:    PODVector<float>& lodErrors = patch->GetLodErrors();
Terrain.cpp:1155:                        float error = Abs(GetLodHeight(x, z, i) - GetRawHeight(x, z));
Terrain.cpp:1171:    const IntVector2& coords = patch->GetCoordinates();
Terrain.cpp:1172:    patch->SetNeighbors(GetPatch(coords.x_, coords.y_ + 1), GetPatch(coords.x_, coords.y_ - 1),
Terrain.cpp:1173:        GetPatch(coords.x_ - 1, coords.y_), GetPatch(coords.x_ + 1, coords.y_));
Terrain.cpp:1178:    if (image && image->IsCompressed())
Terrain.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Terrain.h:62:    /// Set heightmap image. Dimensions should be a power of two + 1. Uses 8-bit grayscale, or optionally red as MSB and green as LSB for 16-bit accuracy. Return true if successful.
Terrain.h:80:    /// Set maximum number of per-pixel lights for patches. Default 0 is unlimited.
Terrain.h:131:    /// Return maximum number of per-pixel lights.
Terrain.h:168:    /// Get slope-based terrain normal at position.
Terrain.h:197:    /// Origin of patches on the XZ-plane.
Terrain.h:199:    /// Size of a patch on the XZ-plane.
TerrainPatch.h:2:// Copyright (c) 2008-2015 the Urho3D project.
TerrainPatch.h:49:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
TerrainPatch.h:70:    /// Set local-space bounding box.
TerrainPatch.h:107:    /// Recalculate the world-space bounding box.
TerrainPatch.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
TerrainPatch.cpp:55:    geometry_->SetVertexBuffer(0, vertexBuffer_, MASK_POSITION | MASK_NORMAL | MASK_TEXCOORD1 | MASK_TANGENT);
TerrainPatch.cpp:56:    maxLodGeometry_->SetVertexBuffer(0, vertexBuffer_, MASK_POSITION | MASK_NORMAL | MASK_TEXCOORD1 | MASK_TANGENT);
TerrainPatch.cpp:57:    minLodGeometry_->SetVertexBuffer(0, vertexBuffer_, MASK_POSITION | MASK_NORMAL | MASK_TEXCOORD1 | MASK_TANGENT);
TerrainPatch.cpp:70:    context->RegisterFactory<TerrainPatch>();
TerrainPatch.cpp:85:        Matrix3x4 inverse(node_->GetWorldTransform().Inverse());
TerrainPatch.cpp:88:        Vector3 normal = -query.ray_.direction_;
TerrainPatch.cpp:93:            distance = geometry_->GetHitDistance(localRay, &geometryNormal);
TerrainPatch.cpp:94:            normal = (node_->GetWorldTransform() * Vector4(geometryNormal, 0.0f)).Normalized();
TerrainPatch.cpp:114:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
TerrainPatch.cpp:115:    distance_ = frame.camera_->GetDistance(GetWorldBoundingBox().Center());
TerrainPatch.cpp:118:    lodDistance_ = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
TerrainPatch.cpp:137:    if (vertexBuffer_->IsDataLost())
TerrainPatch.cpp:140:            owner_->CreatePatchGeometry(this);
TerrainPatch.cpp:142:            vertexBuffer_->ClearDataLost();
TerrainPatch.cpp:146:        owner_->UpdatePatchLod(this);
TerrainPatch.cpp:168:    if (mat && !mat->GetOcclusion())
TerrainPatch.cpp:171:        return minLodGeometry_->GetIndexCount() / 3;
TerrainPatch.cpp:180:        if (!material->GetOcclusion())
TerrainPatch.cpp:182:        buffer->SetCullMode(material->GetCullMode());
TerrainPatch.cpp:185:        buffer->SetCullMode(CULL_CCW);
TerrainPatch.cpp:193:    minLodGeometry_->GetRawData(vertexData, vertexSize, indexData, indexSize, elementMask);
TerrainPatch.cpp:198:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
TerrainPatch.cpp:204:    return buffer->Draw(occlusionTransform, vertexData, vertexSize, indexData, indexSize, minLodGeometry_->GetIndexStart(),
TerrainPatch.cpp:205:        minLodGeometry_->GetIndexCount());
TerrainPatch.cpp:280:    worldBoundingBox_ = boundingBox_.Transformed(node_->GetWorldTransform());
TerrainPatch.cpp:286:        lodLevel = Min((int)lodLevel, north_->GetLodLevel() + 1);
TerrainPatch.cpp:288:        lodLevel = Min((int)lodLevel, south_->GetLodLevel() + 1);
TerrainPatch.cpp:290:        lodLevel = Min((int)lodLevel, west_->GetLodLevel() + 1);
TerrainPatch.cpp:292:        lodLevel = Min((int)lodLevel, east_->GetLodLevel() + 1);
Texture.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Texture2D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Texture3D.h:2:// Copyright (c) 2008-2015 the Urho3D project.
TextureCube.h:2:// Copyright (c) 2008-2015 the Urho3D project.
VertexBuffer.h:2:// Copyright (c) 2008-2015 the Urho3D project.
VertexDeclaration.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Viewport.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Viewport.cpp:99:            renderPath_ = renderer->GetDefaultRenderPath();
Viewport.cpp:106:    if (newRenderPath->Load(file))
Viewport.cpp:141:        screenX = (float)x / (float)graphics->GetWidth();
Viewport.cpp:142:        screenY = (float)y / (float)graphics->GetHeight();
Viewport.cpp:146:        screenX = float(x - rect_.left_) / (float)rect_.Width();
Viewport.cpp:147:        screenY = float(y - rect_.top_) / (float)rect_.Height();
Viewport.cpp:150:    return camera_->GetScreenRay(screenX, screenY);
Viewport.cpp:158:    Vector2 screenPoint = camera_->WorldToScreenPoint(worldPos);
Viewport.cpp:165:        x = (int)(screenPoint.x_ * graphics->GetWidth());
Viewport.cpp:166:        y = (int)(screenPoint.y_ * graphics->GetHeight());
Viewport.cpp:188:        screenX = (float)x / (float)graphics->GetWidth();
Viewport.cpp:189:        screenY = (float)y / (float)graphics->GetHeight();
Viewport.cpp:193:        screenX = float(x - rect_.left_) / (float)rect_.Width();
Viewport.cpp:194:        screenY = float(y - rect_.top_) / (float)rect_.Height();
Viewport.cpp:197:    return camera_->ScreenToWorldPoint(Vector3(screenX, screenY, depth));
Viewport.h:2:// Copyright (c) 2008-2015 the Urho3D project.
View.h:2:// Copyright (c) 2008-2015 the Urho3D project.
View.h:96:/// Per-thread geometry, light and scene range collection structure.
View.h:156:    /// Set global (per-frame) shader parameters. Called by Batch and internally by View.
View.h:158:    /// Set camera-specific shader parameters. Called by Batch and internally by View.
View.h:160:    /// Set G-buffer offset and inverse size shader parameters. Called by Batch and internally by View.
View.h:182:    /// Set textures for current render command. Return whether depth write is allowed (depth-stencil not bound as a texture.)
View.h:206:    /// Process shadow casters' visibilities and build their combined view- or projection-space bounding box.
View.h:234:    /// Return the proper depth-stencil surface to use for a rendertarget.
View.h:246:        Zone* drawableZone = drawable->GetZone();
View.h:253:        return drawable->GetLightMask() & GetZone(drawable)->GetLightMask();
View.h:259:        return drawable->GetShadowMask() & GetZone(drawable)->GetShadowMask();
View.h:339:    /// Per-thread octree query results.
View.h:341:    /// Per-thread geometries, lights and Z range collection results.
View.h:364:    /// Per-pixel light queues.
View.h:366:    /// Per-vertex light queues.
Voxel.h:25:	VOXEL_TYPE_CROSSED_PAIR,    // CORNER-TO-CORNER PAIRS, WITH NORMAL VECTOR BUMPED UPWARDS
Voxel.h:29:	VOXEL_TYPE_FLOOR_VHEIGHT_03 = 12,  // DIAGONAL IS SW-NE
Voxel.h:30:	VOXEL_TYPE_FLOOR_VHEIGHT_12,       // DIAGONAL IS SE-NW
VoxelBuilder.h:20:// VOXEL CONFIG MODE 0 - is 2 uints per vertex
VoxelBuilder.cpp:15:    { -1,0,0 }, // west
VoxelBuilder.cpp:16:    { 0,-1,0 }, // south
VoxelBuilder.cpp:18:    { 0,0,-1 }, // down
VoxelBuilder.cpp:20:    {  URHO3D_RSQRT2,0, -URHO3D_RSQRT2 }, // east & down
VoxelBuilder.cpp:24:    { -URHO3D_RSQRT2,0, URHO3D_RSQRT2 }, // west & up
VoxelBuilder.cpp:25:    { 0,-URHO3D_RSQRT2, URHO3D_RSQRT2 }, // south & up
VoxelBuilder.cpp:27:    {  URHO3D_RSQRT3, URHO3D_RSQRT3,-URHO3D_RSQRT3 }, // ne & down
VoxelBuilder.cpp:29:    { 0, URHO3D_RSQRT2, -URHO3D_RSQRT2 }, // north & down
VoxelBuilder.cpp:31:    {  URHO3D_RSQRT2,0, -URHO3D_RSQRT2 }, // east & down
VoxelBuilder.cpp:32:    { 0, URHO3D_RSQRT2, -URHO3D_RSQRT2 }, // north & down
VoxelBuilder.cpp:33:    { -URHO3D_RSQRT2,0, -URHO3D_RSQRT2 }, // west & down
VoxelBuilder.cpp:34:    { 0,-URHO3D_RSQRT2, -URHO3D_RSQRT2 }, // south & down
VoxelBuilder.cpp:35:    { -URHO3D_RSQRT3, URHO3D_RSQRT3, URHO3D_RSQRT3 }, // NW & up
VoxelBuilder.cpp:36:    { -URHO3D_RSQRT3, URHO3D_RSQRT3,-URHO3D_RSQRT3 }, // NW & down
VoxelBuilder.cpp:37:    { -URHO3D_RSQRT2,0, URHO3D_RSQRT2 }, // west & up
VoxelBuilder.cpp:38:    { -URHO3D_RSQRT2,0, -URHO3D_RSQRT2 }, // west & down
VoxelBuilder.cpp:41:    { -URHO3D_RSQRT3, URHO3D_RSQRT3,URHO3D_RSQRT3 }, // NW & up crossed
VoxelBuilder.cpp:42:    { -URHO3D_RSQRT3,-URHO3D_RSQRT3,URHO3D_RSQRT3 }, // SW & up crossed
VoxelBuilder.cpp:43:    {  URHO3D_RSQRT3,-URHO3D_RSQRT3,URHO3D_RSQRT3 }, // SE & up crossed
VoxelBuilder.cpp:44:    { -URHO3D_RSQRT3,-URHO3D_RSQRT3, URHO3D_RSQRT3 }, // SW & up
VoxelBuilder.cpp:45:    { -URHO3D_RSQRT3,-URHO3D_RSQRT3,-URHO3D_RSQRT3 }, // SW & up
VoxelBuilder.cpp:46:    { 0,-URHO3D_RSQRT2, URHO3D_RSQRT2 }, // south & up
VoxelBuilder.cpp:47:    { 0,-URHO3D_RSQRT2, -URHO3D_RSQRT2 }, // south & down
VoxelBuilder.cpp:71:		unsigned numSlots = 2; // (unsigned)Min((float)numChunks, Max(1.0f, ceil((float)queue->GetNumThreads() / (float)VOXEL_MAX_NUM_WORKERS_PER_CHUNK)) * 2.0f);
VoxelBuilder.cpp:106:		sharedIndexBuffer_->SetSize(VOXEL_CHUNK_SIZE * 6, true, false);
VoxelBuilder.cpp:107:		sharedIndexBuffer_->SetData(&data.Front());
VoxelBuilder.cpp:113:		workQueue->Complete(M_MAX_UNSIGNED);
VoxelBuilder.cpp:119:		int numQuads = workload->numQuads;
VoxelBuilder.cpp:123:		VoxelWorkSlot* slot = workload->slot;
VoxelBuilder.cpp:124:		int threadIndex = workload->threadIndex;
VoxelBuilder.cpp:134:		unsigned int* workData = (unsigned int*)slot->workBuffers[threadIndex];
VoxelBuilder.cpp:151:			workload->box.Merge(position);
VoxelBuilder.cpp:189:			MutexLock lock(slot->dataMutex);
VoxelBuilder.cpp:190:			slot->cpuData += cpuData;
VoxelBuilder.cpp:191:			slot->gpuData += gpuData;
VoxelBuilder.cpp:192:			slot->numQuads += numQuads;
VoxelBuilder.cpp:194:		workload->cpuData.Clear();
VoxelBuilder.cpp:195:		workload->gpuData.Clear();
VoxelBuilder.cpp:200:		VoxelWorkload* workload = (VoxelWorkload*)workItem->aux_;
VoxelBuilder.cpp:201:		workload->threadIndex = threadIndex;
VoxelBuilder.cpp:202:		workload->builder->BuildWorkload(workload);
VoxelBuilder.cpp:207:		unsigned char width = chunk->GetSizeX();
VoxelBuilder.cpp:208:		unsigned char depth = chunk->GetSizeZ();
VoxelBuilder.cpp:214:		if (voxelDefinition->blocktype.Size() > 0)
VoxelBuilder.cpp:215:			height = voxelDefinition->blocktype.Size() / (width * depth);
VoxelBuilder.cpp:220:		if (sharedIndexBuffer_->GetIndexSize() == 0)
VoxelBuilder.cpp:245:				job->slot = slot;
VoxelBuilder.cpp:246:				slot->job = job;
VoxelBuilder.cpp:260:		job->chunk = chunk;
VoxelBuilder.cpp:261:		job->width = width;
VoxelBuilder.cpp:262:		job->depth = depth;
VoxelBuilder.cpp:263:		job->append = append;
VoxelBuilder.cpp:264:		job->yOffset = yOffset;
VoxelBuilder.cpp:265:		job->voxelDefinition = voxelDefinition;
VoxelBuilder.cpp:266:		job->slot = 0;
VoxelBuilder.cpp:274:		VoxelChunk* chunk = job->chunk;
VoxelBuilder.cpp:275:		VoxelWorkSlot* slot = job->slot;
VoxelBuilder.cpp:277:		unsigned char workloadsX = (unsigned char)ceil((float)chunk->GetSizeX() / (float)VOXEL_WORKER_SIZE_X);
VoxelBuilder.cpp:278:		unsigned char workloadsY = (unsigned char)ceil((float)chunk->GetSizeY() / (float)VOXEL_WORKER_SIZE_Y);
VoxelBuilder.cpp:279:		unsigned char workloadsZ = (unsigned char)ceil((float)chunk->GetSizeZ() / (float)VOXEL_WORKER_SIZE_Z);
VoxelBuilder.cpp:287:					workload->builder = this;
VoxelBuilder.cpp:288:					workload->slot = slot;
VoxelBuilder.cpp:289:					workload->index[0] = x; 
VoxelBuilder.cpp:290:					workload->index[1] = y; 
VoxelBuilder.cpp:291:					workload->index[2] = z; 
VoxelBuilder.cpp:292:					workload->start[0] = x * VOXEL_WORKER_SIZE_X;
VoxelBuilder.cpp:293:					workload->start[1] = 0;
VoxelBuilder.cpp:294:					workload->start[2] = z * VOXEL_WORKER_SIZE_Z;
VoxelBuilder.cpp:295:					workload->size[0] = Min((int)chunk->GetSizeX(), (x + 1) * VOXEL_WORKER_SIZE_X);
VoxelBuilder.cpp:296:					workload->size[1] = Min((int)chunk->GetSizeY(), (y + 1) * VOXEL_WORKER_SIZE_Y);
VoxelBuilder.cpp:297:					workload->size[2] = Min((int)chunk->GetSizeZ(), (z + 1) * VOXEL_WORKER_SIZE_Z);
VoxelBuilder.cpp:298:					workload->threadIndex = 0;
VoxelBuilder.cpp:299:					workload->numQuads = 0;
VoxelBuilder.cpp:302:					workItem->priority_ = M_MAX_UNSIGNED;
VoxelBuilder.cpp:303:					workItem->aux_ = workload;
VoxelBuilder.cpp:304:					workItem->sendEvent_ = true;
VoxelBuilder.cpp:305:					workItem->workFunction_ = BuildWorkloadHandler;
VoxelBuilder.cpp:308:					slot->workCounter++;
VoxelBuilder.cpp:309:					slot->workloads.Push(workload);
VoxelBuilder.cpp:310:					workQueue->AddWorkItem(workItem);
VoxelBuilder.cpp:318:		VoxelWorkSlot* slot = workload->slot;
VoxelBuilder.cpp:319:		MutexLock lock(slot->dataMutex);
VoxelBuilder.cpp:330:			MutexLock lock(workload->slot->workMutex);
VoxelBuilder.cpp:331:			workload->slot->failed = true;
VoxelBuilder.cpp:334:		DecrementWorkSlot(workload->slot, workload);
VoxelBuilder.cpp:349:		unsigned threadIndex = workload->threadIndex;
VoxelBuilder.cpp:350:		VoxelWorkSlot* slot = workload->slot;
VoxelBuilder.cpp:351:		VoxelJob* job = slot->job;
VoxelBuilder.cpp:352:		VoxelDefinition* definition = job->voxelDefinition;
VoxelBuilder.cpp:354:		stbvox_mesh_maker* mm = &slot->meshMakers[threadIndex];
VoxelBuilder.cpp:355:		stbvox_set_input_stride(mm, job->width, job->width * job->depth);
VoxelBuilder.cpp:359:		map->blocktype = &definition->blocktype.Front();
VoxelBuilder.cpp:360:		map->block_tex1_face = &definition->blockTex1Face.Front();
VoxelBuilder.cpp:361:		map->block_tex2_face = &definition->blockTex2Face.Front();
VoxelBuilder.cpp:362:		map->block_geometry = &definition->blockGeometry.Front();
VoxelBuilder.cpp:363:		map->block_vheight = &definition->blockVHeight.Front();
VoxelBuilder.cpp:364:		map->geometry = &definition->geometry.Front();
VoxelBuilder.cpp:367:		stbvox_set_buffer(mm, 0, 0, slot->workBuffers[threadIndex], VOXEL_WORKER_BUFFER_SIZE);
VoxelBuilder.cpp:372:		for (unsigned y = 0; y < workload->size[1]; y += 16)
VoxelBuilder.cpp:376:				workload->start[0] + 1,
VoxelBuilder.cpp:377:				workload->start[2] + 1,
VoxelBuilder.cpp:378:				workload->start[1] + 1,
VoxelBuilder.cpp:379:				workload->start[0] + workload->size[0] - 1,
VoxelBuilder.cpp:380:				workload->start[2] + workload->size[2] - 1,
VoxelBuilder.cpp:381:				workload->start[1] + Min(y+16, workload->size[1] - 1)
VoxelBuilder.cpp:389:		workload->numQuads += stbvox_get_quad_count(mm, 0);
VoxelBuilder.cpp:395:		VoxelJob* job = slot->job;
VoxelBuilder.cpp:396:		VoxelChunk* chunk = job->chunk;
VoxelBuilder.cpp:397:		VertexBuffer* vb = chunk->GetVertexBuffer();
VoxelBuilder.cpp:398:		int numVertices = slot->numQuads * 4;
VoxelBuilder.cpp:399:		int start = job->append ? vb->GetVertexCount() : 0;
VoxelBuilder.cpp:400:		int end = job->append ? vb->GetVertexSize() + numVertices : numVertices;
VoxelBuilder.cpp:401:		vb->SetSize(end, MASK_POSITION | MASK_TEXCOORD1 | MASK_NORMAL, true);
VoxelBuilder.cpp:402:		vb->SetDataRange((void*)slot->gpuData.Front(), start, end);
VoxelBuilder.cpp:405:		chunk->SetBoundingBox(slot->box);
VoxelBuilder.cpp:406:		chunk->SetMaterial(cache->GetResource<Material>("Materials/GreenSquare.xml"));
VoxelBuilder.cpp:407:		chunk->SetCastShadows(true);
VoxelBuilder.cpp:410:			Geometry* geo = chunk->GetGeometry();
VoxelBuilder.cpp:417:			//geo->GetRawData(vertexData, vertexCount, indexData, indexCount, mask);
VoxelBuilder.cpp:420:			geo->SetIndexBuffer(sharedIndexBuffer_);
VoxelBuilder.cpp:421:			geo->SetDrawRange(TRIANGLE_LIST, 0, end, false);
VoxelBuilder.cpp:422:			//geo->SetRawVertexData(cpuData, sizeof(Vector3), MASK_POSITION);
VoxelBuilder.cpp:428:		if (!slot->failed)
VoxelBuilder.cpp:437:		if (workItem->workFunction_ != BuildWorkloadHandler)
VoxelBuilder.cpp:440:		VoxelWorkload* workload = (VoxelWorkload*)workItem->aux_;
VoxelBuilder.cpp:441:		VoxelWorkSlot* slot = workload->slot;
VoxelBuilder.cpp:442:		if (slot->workCounter == 0)
VoxelBuilder.cpp:451:		MutexLock lock(slot->workMutex);
VoxelBuilder.cpp:452:		slot->workCounter--;
VoxelBuilder.cpp:453:		return slot->workCounter;
VoxelBuilder.cpp:458:		slot->free = true;
VoxelBuilder.cpp:459:		slot->failed = false;
VoxelBuilder.cpp:460:		slot->workCounter = 0;
VoxelBuilder.cpp:461:		slot->numQuads = 0;
VoxelBuilder.cpp:462:		slot->box = BoundingBox();
VoxelBuilder.cpp:463:		for (unsigned i = 0; i < slot->workloads.Size(); ++i)
VoxelBuilder.cpp:464:			delete slot->workloads[i];
VoxelBuilder.cpp:466:		slot->workloads.Clear();
VoxelBuilder.cpp:467:		slot->cpuData.Clear();
VoxelBuilder.cpp:468:		slot->gpuData.Clear();
VoxelBuilder.cpp:470:		if (slot->job)
VoxelBuilder.cpp:472:			delete slot->job;
VoxelBuilder.cpp:473:			slot->job = 0;
VoxelBuilder.cpp:485:				slot->free = false;
VoxelChunk.h:29:    /// Calculate distance and prepare batches for rendering. May be called from worker thread(s), possibly re-entrantly.
VoxelChunk.h:48:    /// Set local-space bounding box.
VoxelChunk.h:62:    /// Recalculate the world-space bounding box.
VoxelChunk.cpp:22:    geometry_->SetVertexBuffer(0, vertexBuffer_, MASK_POSITION | MASK_NORMAL | MASK_TEXCOORD1);
VoxelChunk.cpp:35:    context->RegisterFactory<VoxelChunk>(GEOMETRY_CATEGORY);
VoxelChunk.cpp:56:    /* if (geometry_->GetIndexBuffer()) */
VoxelChunk.cpp:58:    /* geometry_->GetIndexBuffer()->GetIndexCount() / 3 : 0; */
VoxelChunk.cpp:64:    const Matrix3x4& worldTransform = node_->GetWorldTransform();
VoxelChunk.cpp:65:    distance_ = frame.camera_->GetDistance(GetWorldBoundingBox().Center());
VoxelChunk.cpp:68:    lodDistance_ = frame.camera_->GetLodDistance(distance_, scale, lodBias_);
VoxelChunk.cpp:76:    /* if (vertexBuffer_->IsDataLost()) */
VoxelChunk.cpp:79:    /*         owner_->BuildChunk(this); */
VoxelChunk.cpp:81:    /*         vertexBuffer_->ClearDataLost(); */
VoxelChunk.cpp:85:    /*     owner_->UpdatePatchLod(this); */
VoxelChunk.cpp:90:    worldBoundingBox_ = boundingBox_.Transformed(node_->GetWorldTransform());
VoxelChunk.cpp:116:        Matrix3x4 inverse(node_->GetWorldTransform().Inverse());
VoxelChunk.cpp:119:        Vector3 normal = -query.ray_.direction_;
VoxelChunk.cpp:124:            distance = geometry_->GetHitDistance(localRay, &geometryNormal);
VoxelChunk.cpp:125:            normal = (node_->GetWorldTransform() * Vector4(geometryNormal, 0.0f)).Normalized();
Zone.h:2:// Copyright (c) 2008-2015 the Urho3D project.
Zone.h:50:    /// Set local-space bounding box. Will be used as an oriented bounding box to test whether objects or the camera are inside.
Zone.h:114:    /// Recalculate the world-space bounding box.
Zone.h:133:    /// Last world-space bounding box.
VoxelSet.h:52:    ///// Set maximum number of per-pixel lights for patches. Default 0 is unlimited.
Zone.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
Zone.cpp:37:static const Vector3 DEFAULT_BOUNDING_BOX_MIN(-10.0f, -10.0f, -10.0f);
Zone.cpp:71:    context->RegisterFactory<Zone>(SCENE_CATEGORY);
Zone.cpp:105:        debug->AddBoundingBox(boundingBox_, node_->GetWorldTransform(), Color::GREEN, depthTest);
Zone.cpp:191:        inverseWorld_ = node_ ? node_->GetWorldTransform().Inverse() : Matrix3x4::IDENTITY;
Zone.cpp:230:    zoneTexture_ = static_cast<Texture*>(cache->GetResource(value.type_, value.name_));
Zone.cpp:242:    if (scene && scene->IsThreadedUpdate())
Zone.cpp:244:        scene->DelayedMarkedDirty(this);
Zone.cpp:258:    worldBoundingBox_ = boundingBox_.Transformed(node_->GetWorldTransform());
Zone.cpp:271:        const Matrix3x4& worldTransform = node_->GetWorldTransform();
Zone.cpp:279:            octant_->GetRoot()->GetDrawables(query);
Zone.cpp:288:            int priority = zone->GetPriority();
Zone.cpp:289:            if (priority > bestPriority && zone != this && zone->IsInside(minZPosition))
Zone.cpp:298:            ambientStartColor_ = bestZone->GetAmbientColor();
Zone.cpp:305:            octant_->GetRoot()->GetDrawables(query);
Zone.cpp:313:            int priority = zone->GetPriority();
Zone.cpp:314:            if (priority > bestPriority && zone != this && zone->IsInside(maxZPosition))
Zone.cpp:323:            ambientEndColor_ = bestZone->GetAmbientColor();
Zone.cpp:340:        octant_->GetRoot()->GetDrawables(query);
Zone.cpp:345:            unsigned drawableFlags = drawable->GetDrawableFlags();
Zone.cpp:347:                drawable->SetZone(0);
Zone.cpp:351:                zone->lastAmbientStartZone_.Reset();
Zone.cpp:352:                zone->lastAmbientEndZone_.Reset();
View.cpp:2:// Copyright (c) 2008-2015 the Urho3D project.
View.cpp:83:            if (drawable->GetCastShadows() && (drawable->GetDrawableFlags() & drawableFlags_) &&
View.cpp:84:                (drawable->GetViewMask() & viewMask_))
View.cpp:86:                if (inside || frustum_.IsInsideFast(drawable->GetWorldBoundingBox()))
View.cpp:110:            unsigned char flags = drawable->GetDrawableFlags();
View.cpp:113:                drawable->IsOccluder())) && (drawable->GetViewMask() & viewMask_))
View.cpp:115:                if (inside || frustum_.IsInsideFast(drawable->GetWorldBoundingBox()))
View.cpp:138:            return buffer_->IsVisible(box) ? INSIDE : OUTSIDE;
View.cpp:142:            if (result != OUTSIDE && !buffer_->IsVisible(box))
View.cpp:155:            if ((drawable->GetDrawableFlags() & drawableFlags_) && (drawable->GetViewMask() & viewMask_))
View.cpp:157:                if (inside || frustum_.IsInsideFast(drawable->GetWorldBoundingBox()))
View.cpp:169:    View* view = reinterpret_cast<View*>(item->aux_);
View.cpp:170:    Drawable** start = reinterpret_cast<Drawable**>(item->start_);
View.cpp:171:    Drawable** end = reinterpret_cast<Drawable**>(item->end_);
View.cpp:172:    OcclusionBuffer* buffer = view->occlusionBuffer_;
View.cpp:173:    const Matrix3x4& viewMatrix = view->camera_->GetView();
View.cpp:176:    unsigned cameraViewMask = view->camera_->GetViewMask();
View.cpp:177:    bool cameraZoneOverride = view->cameraZoneOverride_;
View.cpp:178:    PerThreadSceneResult& result = view->sceneResults_[threadIndex];
View.cpp:184:        if (!buffer || !drawable->IsOccludee() || buffer->IsVisible(drawable->GetWorldBoundingBox()))
View.cpp:186:            drawable->UpdateBatches(view->frame_);
View.cpp:187:            // If draw distance non-zero, update and check it
View.cpp:188:            float maxDistance = drawable->GetDrawDistance();
View.cpp:191:                if (drawable->GetDistance() > maxDistance)
View.cpp:195:            drawable->MarkInView(view->frame_);
View.cpp:198:            if (drawable->GetDrawableFlags() & DRAWABLE_GEOMETRY)
View.cpp:200:                Zone* drawableZone = drawable->GetZone();
View.cpp:201:                if (!cameraZoneOverride && (drawable->IsZoneDirty() || !drawableZone || (drawableZone->GetViewMask() &
View.cpp:203:                    view->FindZone(drawable);
View.cpp:205:                const BoundingBox& geomBox = drawable->GetWorldBoundingBox();
View.cpp:214:                    float minZ = viewCenterZ - viewEdgeZ;
View.cpp:216:                    drawable->SetMinMaxZ(viewCenterZ - viewEdgeZ, viewCenterZ + viewEdgeZ);
View.cpp:221:                    drawable->SetMinMaxZ(M_LARGE_VALUE, M_LARGE_VALUE);
View.cpp:225:            else if (drawable->GetDrawableFlags() & DRAWABLE_LIGHT)
View.cpp:229:                if (!light->GetEffectiveColor().Equals(Color::BLACK))
View.cpp:238:    View* view = reinterpret_cast<View*>(item->aux_);
View.cpp:239:    LightQueryResult* query = reinterpret_cast<LightQueryResult*>(item->start_);
View.cpp:241:    view->ProcessLight(*query, threadIndex);
View.cpp:246:    const FrameInfo& frame = *(reinterpret_cast<FrameInfo*>(item->aux_));
View.cpp:247:    Drawable** start = reinterpret_cast<Drawable**>(item->start_);
View.cpp:248:    Drawable** end = reinterpret_cast<Drawable**>(item->end_);
View.cpp:255:            drawable->UpdateGeometry(frame);
View.cpp:261:    BatchQueue* queue = reinterpret_cast<BatchQueue*>(item->start_);
View.cpp:263:    queue->SortFrontToBack();
View.cpp:268:    BatchQueue* queue = reinterpret_cast<BatchQueue*>(item->start_);
View.cpp:270:    queue->SortBackToFront();
View.cpp:275:    LightBatchQueue* start = reinterpret_cast<LightBatchQueue*>(item->start_);
View.cpp:276:    start->litBaseBatches_.SortFrontToBack();
View.cpp:277:    start->litBatches_.SortFrontToBack();
View.cpp:282:    LightBatchQueue* start = reinterpret_cast<LightBatchQueue*>(item->start_);
View.cpp:283:    for (unsigned i = 0; i < start->shadowSplits_.Size(); ++i)
View.cpp:284:        start->shadowSplits_[i].shadowBatches_.SortFrontToBack();
View.cpp:300:    unsigned numThreads = GetSubsystem<WorkQueue>()->GetNumThreads() + 1; // Worker threads + main thread
View.cpp:312:    renderPath_ = viewport->GetRenderPath();
View.cpp:324:    drawDebug_ = viewport->GetDrawDebug();
View.cpp:338:    for (unsigned i = 0; i < renderPath_->commands_.Size(); ++i)
View.cpp:340:        const RenderPathCommand& command = renderPath_->commands_[i];
View.cpp:354:    for (unsigned i = 0; i < renderPath_->commands_.Size(); ++i)
View.cpp:356:        RenderPathCommand& command = renderPath_->commands_[i];
View.cpp:390:            info.batchQueue_ = &j->second_;
View.cpp:399:    scene_ = viewport->GetScene();
View.cpp:400:    camera_ = viewport->GetCamera();
View.cpp:403:    cameraZone_ = farClipZone_ = renderer_->GetDefaultZone();
View.cpp:407:        if (!scene_ || !camera_ || !camera_->IsEnabledEffective())
View.cpp:411:        if (scene_->IsAsyncLoading() && scene_->GetAsyncLoadMode() > LOAD_RESOURCES_ONLY)
View.cpp:414:        octree_ = scene_->GetComponent<Octree>();
View.cpp:420:        if (!camera_->IsProjectionValid())
View.cpp:424:    cameraNode_ = camera_ ? camera_->GetNode() : (Node*)0;
View.cpp:432:    for (unsigned i = 0; i < renderPath_->commands_.Size(); ++i)
View.cpp:434:        const RenderPathCommand& command = renderPath_->commands_[i];
View.cpp:438:        // Check if ambient pass and G-buffer rendering happens at the same time
View.cpp:454:    int rtWidth = renderTarget ? renderTarget->GetWidth() : graphics_->GetWidth();
View.cpp:455:    int rtHeight = renderTarget ? renderTarget->GetHeight() : graphics_->GetHeight();
View.cpp:456:    const IntRect& rect = viewport->GetRect();
View.cpp:460:        viewRect_.left_ = Clamp(rect.left_, 0, rtWidth - 1);
View.cpp:461:        viewRect_.top_ = Clamp(rect.top_, 0, rtHeight - 1);
View.cpp:475:        viewRect_.bottom_ = rtHeight - viewRect_.top_;
View.cpp:476:        viewRect_.top_ = viewRect_.bottom_ - viewSize_.y_;
View.cpp:480:    drawShadows_ = renderer_->GetDrawShadows();
View.cpp:481:    materialQuality_ = renderer_->GetMaterialQuality();
View.cpp:482:    maxOccluderTriangles_ = renderer_->GetMaxOccluderTriangles();
View.cpp:483:    minInstances_ = renderer_->GetMinInstances();
View.cpp:486:    unsigned viewOverrideFlags = camera_ ? camera_->GetViewOverrideFlags() : VO_NONE;
View.cpp:513:    eventData[P_TEXTURE] = (renderTarget_ ? renderTarget_->GetParentTexture() : 0);
View.cpp:516:    renderer_->SendEvent(E_BEGINVIEWUPDATE, eventData);
View.cpp:518:    int maxSortedInstances = renderer_->GetMaxSortedInstances();
View.cpp:528:        i->second_.Clear(maxSortedInstances);
View.cpp:532:        renderer_->SendEvent(E_ENDVIEWUPDATE, eventData);
View.cpp:537:    if (camera_ && camera_->GetAutoAspectRatio())
View.cpp:538:        camera_->SetAspectRatioInternal((float)frame_.viewSize_.x_ / (float)frame_.viewSize_.y_);
View.cpp:543:    renderer_->SendEvent(E_ENDVIEWUPDATE, eventData);
View.cpp:558:    graphics_->ClearParameterSources();
View.cpp:560:    if (renderer_->GetDynamicInstancing() && graphics_->GetInstancingSupport())
View.cpp:567:        if (camera_->GetAutoAspectRatio())
View.cpp:568:            camera_->SetAspectRatioInternal((float)(viewSize_.x_) / (float)(viewSize_.y_));
View.cpp:573:    if (renderer_->GetDrawShadows())
View.cpp:575:        graphics_->SetTexture(TU_FACESELECT, renderer_->GetFaceSelectCubeMap());
View.cpp:576:        graphics_->SetTexture(TU_INDIRECTION, renderer_->GetIndirectionCubeMap());
View.cpp:586:            camera_->SetFlipVertical(true);
View.cpp:594:    graphics_->SetFillMode(FILL_SOLID);
View.cpp:595:    graphics_->SetClipPlane(false);
View.cpp:596:    graphics_->SetColorWrite(true);
View.cpp:597:    graphics_->SetDepthBias(0.0f, 0.0f);
View.cpp:598:    graphics_->SetScissorTest(false);
View.cpp:599:    graphics_->SetStencilTest(false);
View.cpp:604:        DebugRenderer* debug = octree_->GetComponent<DebugRenderer>();
View.cpp:605:        if (debug && debug->IsEnabledEffective() && debug->HasContent())
View.cpp:609:            graphics_->SetRenderTarget(0, currentRenderTarget_);
View.cpp:611:                graphics_->SetRenderTarget(i, (RenderSurface*)0);
View.cpp:612:            graphics_->SetDepthStencil(GetDepthStencil(currentRenderTarget_));
View.cpp:613:            IntVector2 rtSizeNow = graphics_->GetRenderTargetDimensions();
View.cpp:616:            graphics_->SetViewport(viewport);
View.cpp:618:            debug->SetView(camera_);
View.cpp:619:            debug->Render();
View.cpp:625:        camera_->SetFlipVertical(false);
View.cpp:630:        BlitFramebuffer(currentRenderTarget_->GetParentTexture(), renderTarget_, true);
View.cpp:654:    graphics_->SetShaderParameter(VSP_DELTATIME, frame_.timeStep_);
View.cpp:655:    graphics_->SetShaderParameter(PSP_DELTATIME, frame_.timeStep_);
View.cpp:659:        float elapsedTime = scene_->GetElapsedTime();
View.cpp:660:        graphics_->SetShaderParameter(VSP_ELAPSEDTIME, elapsedTime);
View.cpp:661:        graphics_->SetShaderParameter(PSP_ELAPSEDTIME, elapsedTime);
View.cpp:670:    Matrix3x4 cameraEffectiveTransform = camera->GetEffectiveWorldTransform();
View.cpp:672:    graphics_->SetShaderParameter(VSP_CAMERAPOS, cameraEffectiveTransform.Translation());
View.cpp:673:    graphics_->SetShaderParameter(VSP_CAMERAROT, cameraEffectiveTransform.RotationMatrix());
View.cpp:674:    graphics_->SetShaderParameter(PSP_CAMERAPOS, cameraEffectiveTransform.Translation());
View.cpp:676:    float nearClip = camera->GetNearClip();
View.cpp:677:    float farClip = camera->GetFarClip();
View.cpp:678:    graphics_->SetShaderParameter(VSP_NEARCLIP, nearClip);
View.cpp:679:    graphics_->SetShaderParameter(VSP_FARCLIP, farClip);
View.cpp:680:    graphics_->SetShaderParameter(PSP_NEARCLIP, nearClip);
View.cpp:681:    graphics_->SetShaderParameter(PSP_FARCLIP, farClip);
View.cpp:684:    if (camera->IsOrthographic())
View.cpp:695:        depthMode.w_ = 1.0f / camera->GetFarClip();
View.cpp:697:    graphics_->SetShaderParameter(VSP_DEPTHMODE, depthMode);
View.cpp:699:    Vector4 depthReconstruct(farClip / (farClip - nearClip), -nearClip / (farClip - nearClip), camera->IsOrthographic() ? 1.0f :
View.cpp:700:        0.0f, camera->IsOrthographic() ? 0.0f : 1.0f);
View.cpp:701:    graphics_->SetShaderParameter(PSP_DEPTHRECONSTRUCT, depthReconstruct);
View.cpp:704:    camera->GetFrustumSize(nearVector, farVector);
View.cpp:705:    graphics_->SetShaderParameter(VSP_FRUSTUMSIZE, farVector);
View.cpp:709:        Matrix4 projection = camera->GetProjection();
View.cpp:712:        float constantBias = 2.0f * graphics_->GetDepthConstantBias();
View.cpp:717:        graphics_->SetShaderParameter(VSP_VIEWPROJ, projection * camera->GetView());
View.cpp:730:        1.0f - (((float)viewRect.top_) / texHeight + heightRange), widthRange, heightRange);
View.cpp:736:    graphics_->SetShaderParameter(VSP_GBUFFEROFFSETS, bufferUVOffset);
View.cpp:740:    graphics_->SetShaderParameter(PSP_GBUFFERINVSIZE, Vector4(invSizeX, invSizeY, 0.0f, 0.0f));
View.cpp:755:        ZoneOccluderOctreeQuery query(tempDrawables, camera_->GetFrustum(), DRAWABLE_GEOMETRY | DRAWABLE_ZONE, camera_->GetViewMask());
View.cpp:756:        octree_->GetDrawables(query);
View.cpp:761:    Vector3 cameraPos = cameraNode_->GetWorldPosition();
View.cpp:766:        unsigned char flags = drawable->GetDrawableFlags();
View.cpp:772:            int priority = zone->GetPriority();
View.cpp:775:            if (priority > bestPriority && zone->IsInside(cameraPos))
View.cpp:786:    cameraZoneOverride_ = cameraZone_->GetOverride();
View.cpp:789:        Vector3 farClipPos = cameraPos + cameraNode_->GetWorldDirection() * Vector3(0.0f, 0.0f, camera_->GetFarClip());
View.cpp:794:            int priority = (*i)->GetPriority();
View.cpp:795:            if (priority > bestPriority && (*i)->IsInside(farClipPos))
View.cpp:802:    if (farClipZone_ == renderer_->GetDefaultZone())
View.cpp:814:            occlusionBuffer_ = renderer_->GetOcclusionBuffer(camera_);
View.cpp:822:        OccludedFrustumOctreeQuery query(tempDrawables, camera_->GetFrustum(), occlusionBuffer_, DRAWABLE_GEOMETRY |
View.cpp:823:            DRAWABLE_LIGHT, camera_->GetViewMask());
View.cpp:824:        octree_->GetDrawables(query);
View.cpp:828:        FrustumOctreeQuery query(tempDrawables, camera_->GetFrustum(), DRAWABLE_GEOMETRY | 
View.cpp:829:            DRAWABLE_LIGHT, camera_->GetViewMask());
View.cpp:830:        octree_->GetDrawables(query);
View.cpp:845:        int numWorkItems = queue->GetNumThreads() + 1; // Worker threads + main thread
View.cpp:852:            SharedPtr<WorkItem> item = queue->GetFreeItem();
View.cpp:853:            item->priority_ = M_MAX_UNSIGNED;
View.cpp:854:            item->workFunction_ = CheckVisibilityWork;
View.cpp:855:            item->aux_ = this;
View.cpp:858:            if (i < numWorkItems - 1 && end - start > drawablesPerItem)
View.cpp:861:            item->start_ = &(*start);
View.cpp:862:            item->end_ = &(*end);
View.cpp:863:            queue->AddWorkItem(item);
View.cpp:868:        queue->Complete(M_MAX_UNSIGNED);
View.cpp:901:    // Sort the lights to brightest/closest first, and per-vertex lights first so that per-vertex base pass can be evaluated first
View.cpp:905:        light->SetIntensitySortValue(camera_->GetDistance(light->GetNode()->GetWorldPosition()));
View.cpp:906:        light->SetLightQueue(0);
View.cpp:935:        SharedPtr<WorkItem> item = queue->GetFreeItem();
View.cpp:936:        item->priority_ = M_MAX_UNSIGNED;
View.cpp:937:        item->workFunction_ = ProcessLightWork;
View.cpp:938:        item->aux_ = this;
View.cpp:943:        item->start_ = &query;
View.cpp:944:        queue->AddWorkItem(item);
View.cpp:948:    queue->Complete(M_MAX_UNSIGNED);
View.cpp:959:        // Preallocate light queues: per-pixel lights which have lit geometries
View.cpp:964:            if (!i->light_->GetPerVertex() && i->litGeometries_.Size())
View.cpp:970:        unsigned maxSortedInstances = renderer_->GetMaxSortedInstances();
View.cpp:982:            // Per-pixel light
View.cpp:983:            if (!light->GetPerVertex())
View.cpp:989:                light->SetLightQueue(&lightQueue);
View.cpp:991:                lightQueue.negative_ = light->IsNegative();
View.cpp:1000:                    lightQueue.shadowMap_ = renderer_->GetShadowMap(light, camera_, viewSize_.x_, viewSize_.y_);
View.cpp:1027:                        if (!drawable->IsInView(frame_, true))
View.cpp:1029:                            drawable->MarkInView(frame_.frameNumber_);
View.cpp:1030:                            UpdateGeometryType type = drawable->GetUpdateGeometryType();
View.cpp:1038:                        const Vector<SourceBatch>& batches = drawable->GetBatches();
View.cpp:1048:                            Pass* pass = tech->GetSupportedPass(Technique::shadowPassIndex);
View.cpp:1067:                    drawable->AddLight(light);
View.cpp:1070:                    if (!drawable->GetMaxLights())
View.cpp:1080:                    volumeBatch.geometry_ = renderer_->GetLightGeometry(light);
View.cpp:1082:                    volumeBatch.worldTransform_ = &light->GetVolumeTransform(camera_);
View.cpp:1086:                    volumeBatch.distance_ = light->GetDistance();
View.cpp:1090:                    renderer_->SetLightVolumeBatchShaders(volumeBatch, lightVolumeCommand_->vertexShaderName_,
View.cpp:1091:                        lightVolumeCommand_->pixelShaderName_, lightVolumeCommand_->vertexShaderDefines_,
View.cpp:1092:                        lightVolumeCommand_->pixelShaderDefines_);
View.cpp:1096:            // Per-vertex light
View.cpp:1103:                    drawable->AddVertexLight(light);
View.cpp:1109:    // Process drawables with limited per-pixel light count
View.cpp:1117:            drawable->LimitLights();
View.cpp:1118:            const PODVector<Light*>& lights = drawable->GetLights();
View.cpp:1124:                LightBatchQueue* queue = light->GetLightQueue();
View.cpp:1139:        UpdateGeometryType type = drawable->GetUpdateGeometryType();
View.cpp:1145:        const Vector<SourceBatch>& batches = drawable->GetBatches();
View.cpp:1154:            if (srcBatch.material_ && srcBatch.material_->GetAuxViewFrameNumber() != frame_.frameNumber_ && !renderTarget_)
View.cpp:1166:                if (info.passIndex_ == basePassIndex_ && j < 32 && drawable->HasBasePass(j))
View.cpp:1169:                Pass* pass = tech->GetSupportedPass(info.passIndex_);
View.cpp:1182:                    const PODVector<Light*>& drawableVertexLights = drawable->GetVertexLights();
View.cpp:1185:                        // Limit vertex lights. If this is a deferred opaque batch, remove converted per-pixel lights,
View.cpp:1188:                        drawable->LimitVertexLights(deferred_ && destBatch.pass_->GetBlendMode() == BLEND_REPLACE);
View.cpp:1200:                            i->second_.light_ = 0;
View.cpp:1201:                            i->second_.shadowMap_ = 0;
View.cpp:1202:                            i->second_.vertexLights_ = drawableVertexLights;
View.cpp:1205:                        destBatch.lightQueue_ = &(i->second_);
View.cpp:1212:                if (allowInstancing && info.markToStencil_ && destBatch.lightMask_ != (destBatch.zone_->GetLightMask() & 0xff))
View.cpp:1229:        for (unsigned i = 0; i < renderPath_->commands_.Size(); ++i)
View.cpp:1231:            const RenderPathCommand& command = renderPath_->commands_[i];
View.cpp:1237:                SharedPtr<WorkItem> item = queue->GetFreeItem();
View.cpp:1238:                item->priority_ = M_MAX_UNSIGNED;
View.cpp:1239:                item->workFunction_ = command.sortMode_ == SORT_FRONTTOBACK ? SortBatchQueueFrontToBackWork : SortBatchQueueBackToFrontWork;
View.cpp:1240:                item->start_ = &batchQueues_[command.passIndex_];
View.cpp:1241:                queue->AddWorkItem(item);
View.cpp:1247:            SharedPtr<WorkItem> lightItem = queue->GetFreeItem();
View.cpp:1248:            lightItem->priority_ = M_MAX_UNSIGNED;
View.cpp:1249:            lightItem->workFunction_ = SortLightQueueWork;
View.cpp:1250:            lightItem->start_ = &(*i);
View.cpp:1251:            queue->AddWorkItem(lightItem);
View.cpp:1253:            if (i->shadowSplits_.Size())
View.cpp:1255:                SharedPtr<WorkItem> shadowItem = queue->GetFreeItem();
View.cpp:1256:                shadowItem->priority_ = M_MAX_UNSIGNED;
View.cpp:1257:                shadowItem->workFunction_ = SortShadowQueueWork;
View.cpp:1258:                shadowItem->start_ = &(*i);
View.cpp:1259:                queue->AddWorkItem(shadowItem);
View.cpp:1264:    // Update geometries. Split into threaded and non-threaded updates.
View.cpp:1268:            // In special cases (context loss, multi-view) a drawable may theoretically first have reported a threaded update, but will actually
View.cpp:1273:                if ((*i)->GetUpdateGeometryType() == UPDATE_MAIN_THREAD)
View.cpp:1280:            int numWorkItems = queue->GetNumThreads() + 1; // Worker threads + main thread
View.cpp:1287:                if (i < numWorkItems - 1 && end - start > drawablesPerItem)
View.cpp:1290:                SharedPtr<WorkItem> item = queue->GetFreeItem();
View.cpp:1291:                item->priority_ = M_MAX_UNSIGNED;
View.cpp:1292:                item->workFunction_ = UpdateDrawableGeometriesWork;
View.cpp:1293:                item->aux_ = const_cast<FrameInfo*>(&frame_);
View.cpp:1294:                item->start_ = &(*start);
View.cpp:1295:                item->end_ = &(*end);
View.cpp:1296:                queue->AddWorkItem(item);
View.cpp:1302:        // While the work queue is processed, update non-threaded geometries
View.cpp:1304:            (*i)->UpdateGeometry(frame_);
View.cpp:1308:    queue->Complete(M_MAX_UNSIGNED);
View.cpp:1315:    const Vector<SourceBatch>& batches = drawable->GetBatches();
View.cpp:1317:    bool allowLitBase = useLitBase_ && !lightQueue.negative_ && light == drawable->GetFirstLight() &&
View.cpp:1318:        drawable->GetVertexLights().Empty() && !zone->GetAmbientGradient();
View.cpp:1328:        // Do not create pixel lit forward passes for materials that render into the G-buffer
View.cpp:1329:        if (gBufferPassIndex_ != M_MAX_UNSIGNED && tech->HasPass(gBufferPassIndex_))
View.cpp:1336:        // Also vertex lighting or ambient gradient require the non-lit base pass, so skip in those cases
View.cpp:1339:            destBatch.pass_ = tech->GetSupportedPass(litBasePassIndex_);
View.cpp:1343:                drawable->SetBasePass(i);
View.cpp:1346:                destBatch.pass_ = tech->GetSupportedPass(lightPassIndex_);
View.cpp:1349:            destBatch.pass_ = tech->GetSupportedPass(lightPassIndex_);
View.cpp:1354:            destBatch.pass_ = tech->GetSupportedPass(litAlphaPassIndex_);
View.cpp:1377:            AddBatchToQueue(*alphaQueue, destBatch, tech, false, !renderer_->GetReuseShadowMaps());
View.cpp:1385:    if (!renderer_->GetReuseShadowMaps() && renderer_->GetDrawShadows() && !lightQueues_.Empty())
View.cpp:1391:            if (i->shadowMap_)
View.cpp:1407:        for (unsigned i = 0; i < renderPath_->commands_.Size(); ++i)
View.cpp:1409:            RenderPathCommand& command = renderPath_->commands_[i];
View.cpp:1414:        for (unsigned i = 0; i < renderPath_->commands_.Size(); ++i)
View.cpp:1416:            RenderPathCommand& command = renderPath_->commands_[i];
View.cpp:1436:                        graphics_->ResolveToTexture(dynamic_cast<Texture2D*>(viewportTextures_[0]), viewRect_);
View.cpp:1444:                            BlitFramebuffer(currentRenderTarget_->GetParentTexture(),
View.cpp:1454:                            currentViewportTexture_ = currentRenderTarget_->GetParentTexture();
View.cpp:1462:                    viewportTextures_[0] = currentRenderTarget_->GetParentTexture();
View.cpp:1499:                        clearColor = farClipZone_->GetFogColor();
View.cpp:1502:                    graphics_->Clear(command.clearFlags_, clearColor, command.clearDepth_, command.clearStencil_);
View.cpp:1515:                        graphics_->SetClipPlane(camera_->GetUseClipping(), camera_->GetClipPlane(), camera_->GetView(), camera_->GetProjection());
View.cpp:1542:                        if (renderer_->GetReuseShadowMaps() && i->shadowMap_)
View.cpp:1549:                        graphics_->SetClipPlane(camera_->GetUseClipping(), camera_->GetClipPlane(), camera_->GetView(), camera_->GetProjection());
View.cpp:1552:                        i->litBaseBatches_.Draw(this, false, false, allowDepthWrite);
View.cpp:1555:                        if (!i->litBatches_.IsEmpty())
View.cpp:1557:                            renderer_->OptimizeLightByScissor(i->light_, camera_);
View.cpp:1559:                                renderer_->OptimizeLightByStencil(i->light_, camera_);
View.cpp:1560:                            i->litBatches_.Draw(this, false, true, allowDepthWrite);
View.cpp:1564:                    graphics_->SetScissorTest(false);
View.cpp:1565:                    graphics_->SetStencilTest(false);
View.cpp:1579:                        if (renderer_->GetReuseShadowMaps() && i->shadowMap_)
View.cpp:1587:                        for (unsigned j = 0; j < i->volumeBatches_.Size(); ++j)
View.cpp:1589:                            SetupLightVolumeBatch(i->volumeBatches_[j]);
View.cpp:1590:                            i->volumeBatches_[j].Draw(this, false);
View.cpp:1594:                    graphics_->SetScissorTest(false);
View.cpp:1595:                    graphics_->SetStencilTest(false);
View.cpp:1602:                    GetSubsystem<UI>()->Render(false);
View.cpp:1626:            graphics_->SetRenderTarget(index, currentRenderTarget_);
View.cpp:1632:            if (!index && command.outputs_.Size() == 1 && texture && (texture->GetFormat() ==
View.cpp:1633:                Graphics::GetReadableDepthFormat() || texture->GetFormat() == Graphics::GetDepthStencilFormat()))
View.cpp:1638:                // On D3D actual depth-only rendering is illegal, we need a color rendertarget
View.cpp:1641:                    depthOnlyDummyTexture_ = renderer_->GetScreenBuffer(texture->GetWidth(), texture->GetHeight(),
View.cpp:1642:                        graphics_->GetDummyColorFormat(), false, false, false);
View.cpp:1645:                graphics_->SetRenderTarget(0, GetRenderSurfaceFromTexture(depthOnlyDummyTexture_));
View.cpp:1646:                graphics_->SetDepthStencil(GetRenderSurfaceFromTexture(texture));
View.cpp:1649:                graphics_->SetRenderTarget(index, GetRenderSurfaceFromTexture(texture, command.outputs_[index].second_));
View.cpp:1657:        graphics_->SetRenderTarget(index, (RenderSurface*)0);
View.cpp:1667:            graphics_->SetDepthStencil(GetRenderSurfaceFromTexture(depthTexture));
View.cpp:1672:    // viewport-sized, so they should use their full size as the viewport
View.cpp:1673:    IntVector2 rtSizeNow = graphics_->GetRenderTargetDimensions();
View.cpp:1678:        graphics_->SetDepthStencil(GetDepthStencil(graphics_->GetRenderTarget(0)));
View.cpp:1679:    graphics_->SetViewport(viewport);
View.cpp:1680:    graphics_->SetColorWrite(useColorWrite);
View.cpp:1697:            graphics_->SetTexture(i, currentViewportTexture_);
View.cpp:1709:            graphics_->SetTexture(i, texture);
View.cpp:1711:            if (graphics_->GetDepthStencil() && texture == graphics_->GetDepthStencil()->GetParentTexture())
View.cpp:1730:    ShaderVariation* vs = graphics_->GetShader(VS, command.vertexShaderName_, command.vertexShaderDefines_);
View.cpp:1733:    ShaderVariation* ps = graphics_->GetShader(PS, command.pixelShaderName_, command.pixelShaderDefines_);
View.cpp:1738:    graphics_->SetShaders(vs, ps);
View.cpp:1742:        graphics_->SetShaderParameter(k->first_, k->second_);
View.cpp:1747:    // During renderpath commands the G-Buffer or viewport texture is assumed to always be viewport-sized
View.cpp:1748:    IntRect viewport = graphics_->GetViewport();
View.cpp:1752:    // Set per-rendertarget inverse size / offset shader parameters as necessary
View.cpp:1753:    for (unsigned i = 0; i < renderPath_->renderTargets_.Size(); ++i)
View.cpp:1755:        const RenderTargetInfo& rtInfo = renderPath_->renderTargets_[i];
View.cpp:1765:        float width = (float)renderTargets_[nameHash]->GetWidth();
View.cpp:1766:        float height = (float)renderTargets_[nameHash]->GetHeight();
View.cpp:1769:        graphics_->SetShaderParameter(invSizeName, Vector2(1.0f / width, 1.0f / height));
View.cpp:1770:        graphics_->SetShaderParameter(offsetsName, Vector2(pixelUVOffset.x_ / width, pixelUVOffset.y_ / height));
View.cpp:1773:    graphics_->SetBlendMode(BLEND_REPLACE);
View.cpp:1774:    graphics_->SetDepthTest(CMP_ALWAYS);
View.cpp:1775:    graphics_->SetDepthWrite(false);
View.cpp:1776:    graphics_->SetFillMode(FILL_SOLID);
View.cpp:1777:    graphics_->SetClipPlane(false);
View.cpp:1778:    graphics_->SetScissorTest(false);
View.cpp:1779:    graphics_->SetStencilTest(false);
View.cpp:1815:    // Current command must be a viewport-reading & writing quad to begin the pingpong chain
View.cpp:1816:    RenderPathCommand& current = renderPath_->commands_[index];
View.cpp:1822:    for (unsigned i = index + 1; i < renderPath_->commands_.Size(); ++i)
View.cpp:1824:        RenderPathCommand& command = renderPath_->commands_[i];
View.cpp:1848:        renderTarget_->GetParentTexture()->GetFormat() != Graphics::GetRGBAFormat()))
View.cpp:1853:        for (unsigned i = 0; i < renderPath_->commands_.Size(); ++i)
View.cpp:1855:            const RenderPathCommand& command = renderPath_->commands_[i];
View.cpp:1868:    if (deferred_ && !renderTarget_ && graphics_->GetMultiSample() > 1)
View.cpp:1870:    // If viewport is smaller than whole texture/backbuffer in deferred rendering, need to reserve a buffer, as the G-buffer
View.cpp:1880:            for (unsigned i = 0; i < renderPath_->commands_.Size(); ++i)
View.cpp:1882:                const RenderPathCommand& command = renderPath_->commands_[i];
View.cpp:1905:    unsigned format = renderTarget_ ? renderTarget_->GetParentTexture()->GetFormat() : Graphics::GetRGBFormat();
View.cpp:1908:    if (renderer_->GetHDRRendering())
View.cpp:1916:    if (deferred_ && !renderer_->GetHDRRendering() && !Graphics::GetGL3Support())
View.cpp:1924:    for (unsigned i = 0; i < renderPath_->commands_.Size(); ++i)
View.cpp:1926:        const RenderPathCommand& command = renderPath_->commands_[i];
View.cpp:1942:        if (!renderTarget_ && graphics_->GetMultiSample() < 2)
View.cpp:1948:        if (renderTarget_ && renderTarget_->GetParentTexture()->GetType() == TextureCube::GetTypeStatic())
View.cpp:1953:        if (renderTarget_ && (viewSize_.x_ < renderTarget_->GetWidth() || viewSize_.y_ < renderTarget_->GetHeight()))
View.cpp:1962:    bool sRGB = renderTarget_ ? renderTarget_->GetParentTexture()->GetSRGB() : graphics_->GetSRGB();
View.cpp:1963:    substituteRenderTarget_ = needSubstitute ? GetRenderSurfaceFromTexture(renderer_->GetScreenBuffer(viewSize_.x_, viewSize_.y_,
View.cpp:1967:        viewportTextures_[i] = i < numViewportTextures ? renderer_->GetScreenBuffer(viewSize_.x_, viewSize_.y_, format, false, true, sRGB) :
View.cpp:1972:        viewportTextures_[1] = substituteRenderTarget_->GetParentTexture();
View.cpp:1975:    for (unsigned i = 0; i < renderPath_->renderTargets_.Size(); ++i)
View.cpp:1977:        const RenderTargetInfo& rtInfo = renderPath_->renderTargets_[i];
View.cpp:1999:        renderTargets_[rtInfo.name_] = renderer_->GetScreenBuffer(intWidth, intHeight, rtInfo.format_, rtInfo.cubemap_, rtInfo.filtered_,
View.cpp:2012:    // are always viewport-sized
View.cpp:2013:    IntVector2 srcSize(source->GetWidth(), source->GetHeight());
View.cpp:2014:    IntVector2 destSize = destination ? IntVector2(destination->GetWidth(), destination->GetHeight()) : IntVector2(
View.cpp:2015:        graphics_->GetWidth(), graphics_->GetHeight());
View.cpp:2020:    graphics_->SetBlendMode(BLEND_REPLACE);
View.cpp:2021:    graphics_->SetDepthTest(CMP_ALWAYS);
View.cpp:2022:    graphics_->SetDepthWrite(depthWrite);
View.cpp:2023:    graphics_->SetFillMode(FILL_SOLID);
View.cpp:2024:    graphics_->SetClipPlane(false);
View.cpp:2025:    graphics_->SetScissorTest(false);
View.cpp:2026:    graphics_->SetStencilTest(false);
View.cpp:2027:    graphics_->SetRenderTarget(0, destination);
View.cpp:2029:        graphics_->SetRenderTarget(i, (RenderSurface*)0);
View.cpp:2030:    graphics_->SetDepthStencil(GetDepthStencil(destination));
View.cpp:2031:    graphics_->SetViewport(destRect);
View.cpp:2034:    graphics_->SetShaders(graphics_->GetShader(VS, shaderName), graphics_->GetShader(PS, shaderName));
View.cpp:2038:    graphics_->SetTexture(TU_DIFFUSE, source);
View.cpp:2044:    Geometry* geometry = renderer_->GetQuadGeometry();
View.cpp:2050:    if (camera_ && camera_->GetFlipVertical())
View.cpp:2051:        projection.m11_ = -1.0f;
View.cpp:2052:    model.m23_ = nearQuad ? -1.0f : 1.0f;
View.cpp:2057:    graphics_->SetCullMode(CULL_NONE);
View.cpp:2058:    graphics_->SetShaderParameter(VSP_MODEL, model);
View.cpp:2059:    graphics_->SetShaderParameter(VSP_VIEWPROJ, projection);
View.cpp:2060:    graphics_->ClearTransformSources();
View.cpp:2062:    geometry->Draw(graphics_);
View.cpp:2067:    float occluderSizeThreshold_ = renderer_->GetOccluderSizeThreshold();
View.cpp:2068:    float halfViewSize = camera->GetHalfViewSize();
View.cpp:2069:    float invOrthoSize = 1.0f / camera->GetOrthoSize();
View.cpp:2076:        if (!occluder->IsInView(frame_, true))
View.cpp:2077:            occluder->UpdateBatches(frame_);
View.cpp:2080:        float maxDistance = occluder->GetDrawDistance();
View.cpp:2081:        if (maxDistance <= 0.0f || occluder->GetDistance() <= maxDistance)
View.cpp:2084:            const BoundingBox& box = occluder->GetWorldBoundingBox();
View.cpp:2087:            if (!camera->IsOrthographic())
View.cpp:2088:                compare = diagonal * halfViewSize / occluder->GetDistance();
View.cpp:2098:                occluder->SetSortValue((float)occluder->GetNumOccluderTriangles() / compare);
View.cpp:2117:    buffer->SetMaxTriangles(maxOccluderTriangles_);
View.cpp:2118:    buffer->Clear();
View.cpp:2125:            // For subsequent occluders, do a test against the pixel-level occlusion buffer to see if rendering is necessary
View.cpp:2126:            if (!buffer->IsVisible(occluder->GetWorldBoundingBox()))
View.cpp:2131:        if (!occluder->DrawOcclusion(buffer))
View.cpp:2135:    buffer->BuildDepthHierarchy();
View.cpp:2141:    LightType type = light->GetLightType();
View.cpp:2142:    const Frustum& frustum = camera_->GetFrustum();
View.cpp:2145:    bool isShadowed = drawShadows_ && light->GetCastShadows() && !light->GetPerVertex() && light->GetShadowIntensity() < 1.0f;
View.cpp:2146:    // If shadow distance non-zero, check it
View.cpp:2147:    if (isShadowed && light->GetShadowDistance() > 0.0f && light->GetDistance() > light->GetShadowDistance())
View.cpp:2163:            if (GetLightMask(geometries_[i]) & light->GetLightMask())
View.cpp:2170:            FrustumOctreeQuery octreeQuery(tempDrawables, light->GetFrustum(), DRAWABLE_GEOMETRY,
View.cpp:2171:                camera_->GetViewMask());
View.cpp:2172:            octree_->GetDrawables(octreeQuery);
View.cpp:2175:                if (tempDrawables[i]->IsInView(frame_) && (GetLightMask(tempDrawables[i]) & light->GetLightMask()))
View.cpp:2183:            SphereOctreeQuery octreeQuery(tempDrawables, Sphere(light->GetNode()->GetWorldPosition(), light->GetRange()),
View.cpp:2184:                DRAWABLE_GEOMETRY, camera_->GetViewMask());
View.cpp:2185:            octree_->GetDrawables(octreeQuery);
View.cpp:2188:                if (tempDrawables[i]->IsInView(frame_) && (GetLightMask(tempDrawables[i]) & light->GetLightMask()))
View.cpp:2210:        const Frustum& shadowCameraFrustum = shadowCamera->GetFrustum();
View.cpp:2227:                camera_->GetViewMask());
View.cpp:2228:            octree_->GetDrawables(query);
View.cpp:2246:    const Frustum& shadowCameraFrustum = shadowCamera->GetFrustum();
View.cpp:2247:    const Matrix3x4& lightView = shadowCamera->GetView();
View.cpp:2248:    const Matrix4& lightProj = shadowCamera->GetProjection();
View.cpp:2249:    LightType type = light->GetLightType();
View.cpp:2258:        lightViewFrustum = camera_->GetSplitFrustum(minZ_, maxZ_).Transformed(lightView);
View.cpp:2260:        lightViewFrustum = camera_->GetSplitFrustum(Max(minZ_, query.shadowNearSplits_[splitIndex]),
View.cpp:2275:        // In case this is a point or spot light query result reused for optimization, we may have non-shadowcasters included.
View.cpp:2277:        if (!drawable->GetCastShadows())
View.cpp:2280:        if (!(GetShadowMask(drawable) & light->GetLightMask()))
View.cpp:2283:        if (type == LIGHT_POINT && shadowCameraFrustum.IsInsideFast(drawable->GetWorldBoundingBox()) == OUTSIDE)
View.cpp:2289:        if (!drawable->IsInView(frame_, true))
View.cpp:2290:            drawable->UpdateBatches(frame_);
View.cpp:2291:        float maxShadowDistance = drawable->GetShadowDistance();
View.cpp:2292:        float drawDistance = drawable->GetDrawDistance();
View.cpp:2295:        if (maxShadowDistance > 0.0f && drawable->GetDistance() > maxShadowDistance)
View.cpp:2299:        lightViewBox = drawable->GetWorldBoundingBox().Transformed(lightView);
View.cpp:2304:            if (type == LIGHT_SPOT && light->GetShadowFocus().focus_)
View.cpp:2319:    if (shadowCamera->IsOrthographic())
View.cpp:2328:        if (drawable->IsInView(frame_))
View.cpp:2335:        float extrusionDistance = shadowCamera->GetFarClip();
View.cpp:2341:        // Calculate the endpoint box and merge it to the original. Because it's axis-aligned, it will be larger
View.cpp:2345:        BoundingBox extrudedBox(newCenter - newHalfSize, newCenter + newHalfSize);
View.cpp:2354:    unsigned width = shadowMap->GetWidth();
View.cpp:2355:    unsigned height = shadowMap->GetHeight();
View.cpp:2357:    switch (light->GetLightType())
View.cpp:2361:            int numSplits = light->GetNumShadowSplits();
View.cpp:2388:    switch (light->GetLightType())
View.cpp:2392:            const CascadeParameters& cascade = light->GetShadowCascade();
View.cpp:2394:            float nearSplit = camera_->GetNearClip();
View.cpp:2396:            int numSplits = light->GetNumShadowSplits();
View.cpp:2401:                if (nearSplit > camera_->GetFarClip())
View.cpp:2404:                farSplit = Min(camera_->GetFarClip(), cascade.splits_[splits]);
View.cpp:2409:                Camera* shadowCamera = renderer_->GetShadowCamera();
View.cpp:2423:            Camera* shadowCamera = renderer_->GetShadowCamera();
View.cpp:2425:            Node* cameraNode = shadowCamera->GetNode();
View.cpp:2426:            Node* lightNode = light->GetNode();
View.cpp:2428:            cameraNode->SetTransform(lightNode->GetWorldPosition(), lightNode->GetWorldRotation());
View.cpp:2429:            shadowCamera->SetNearClip(light->GetShadowNearFarRatio() * light->GetRange());
View.cpp:2430:            shadowCamera->SetFarClip(light->GetRange());
View.cpp:2431:            shadowCamera->SetFov(light->GetFov());
View.cpp:2432:            shadowCamera->SetAspectRatio(light->GetAspectRatio());
View.cpp:2442:                Camera* shadowCamera = renderer_->GetShadowCamera();
View.cpp:2444:                Node* cameraNode = shadowCamera->GetNode();
View.cpp:2447:                cameraNode->SetPosition(light->GetNode()->GetWorldPosition());
View.cpp:2448:                cameraNode->SetDirection(*directions[i]);
View.cpp:2449:                shadowCamera->SetNearClip(light->GetShadowNearFarRatio() * light->GetRange());
View.cpp:2450:                shadowCamera->SetFarClip(light->GetRange());
View.cpp:2451:                shadowCamera->SetFov(90.0f);
View.cpp:2452:                shadowCamera->SetAspectRatio(1.0f);
View.cpp:2465:    Node* shadowCameraNode = shadowCamera->GetNode();
View.cpp:2466:    Node* lightNode = light->GetNode();
View.cpp:2467:    float extrusionDistance = camera_->GetFarClip();
View.cpp:2468:    const FocusParameters& parameters = light->GetShadowFocus();
View.cpp:2471:    Vector3 pos = cameraNode_->GetWorldPosition() - extrusionDistance * lightNode->GetWorldDirection();
View.cpp:2472:    shadowCameraNode->SetTransform(pos, lightNode->GetWorldRotation());
View.cpp:2475:    farSplit = Min(farSplit, camera_->GetFarClip());
View.cpp:2483:    Frustum splitFrustum = camera_->GetSplitFrustum(nearSplit, farSplit);
View.cpp:2493:            if (drawable->GetMinZ() <= farSplit && drawable->GetMaxZ() >= nearSplit &&
View.cpp:2494:                (GetLightMask(drawable) & light->GetLightMask()))
View.cpp:2495:                litGeometriesBox.Merge(drawable->GetWorldBoundingBox());
View.cpp:2507:    const Matrix3x4& lightView = shadowCamera->GetView();
View.cpp:2517:    shadowCamera->SetOrthographic(true);
View.cpp:2518:    shadowCamera->SetAspectRatio(1.0f);
View.cpp:2519:    shadowCamera->SetNearClip(0.0f);
View.cpp:2520:    shadowCamera->SetFarClip(shadowBox.max_.z_);
View.cpp:2529:    const FocusParameters& parameters = light->GetShadowFocus();
View.cpp:2531:    LightType type = light->GetLightType();
View.cpp:2536:        shadowBox.max_.y_ = shadowCamera->GetOrthoSize() * 0.5f;
View.cpp:2537:        shadowBox.max_.x_ = shadowCamera->GetAspectRatio() * shadowBox.max_.y_;
View.cpp:2538:        shadowBox.min_.y_ = -shadowBox.max_.y_;
View.cpp:2539:        shadowBox.min_.x_ = -shadowBox.max_.x_;
View.cpp:2550:        // Scale the quantization parameters, because view size is in projection space (-1.0 - 1.0)
View.cpp:2551:        float invOrthoSize = 1.0f / shadowCamera->GetOrthoSize();
View.cpp:2557:            shadowCamera->SetZoom(1.0f / viewSize);
View.cpp:2562:    if (shadowCamera->GetZoom() >= 1.0f)
View.cpp:2564:        if (light->GetLightType() != LIGHT_POINT)
View.cpp:2565:            shadowCamera->SetZoom(shadowCamera->GetZoom() * ((shadowMapWidth - 2.0f) / shadowMapWidth));
View.cpp:2569:            shadowCamera->SetZoom(shadowCamera->GetZoom() * ((shadowMapWidth - 3.0f) / shadowMapWidth));
View.cpp:2571:            shadowCamera->SetZoom(shadowCamera->GetZoom() * ((shadowMapWidth - 4.0f) / shadowMapWidth));
View.cpp:2580:    Node* shadowCameraNode = shadowCamera->GetNode();
View.cpp:2581:    const FocusParameters& parameters = light->GetShadowFocus();
View.cpp:2590:    Vector2 viewSize(maxX - minX, maxY - minY);
View.cpp:2609:    shadowCamera->SetOrthoSize(viewSize);
View.cpp:2612:    Quaternion rot(shadowCameraNode->GetWorldRotation());
View.cpp:2614:    shadowCameraNode->Translate(rot * adjust, TS_WORLD);
View.cpp:2619:        Vector3 viewPos(rot.Inverse() * shadowCameraNode->GetWorldPosition());
View.cpp:2621:        float invActualSize = 1.0f / (shadowMapWidth - 2.0f);
View.cpp:2623:        Vector3 snap(-fmodf(viewPos.x_, texelSize.x_), -fmodf(viewPos.y_, texelSize.y_), 0.0f);
View.cpp:2624:        shadowCameraNode->Translate(rot * snap, TS_WORLD);
View.cpp:2630:    Vector3 center = drawable->GetWorldBoundingBox().Center();
View.cpp:2635:    // (possibly incorrect) and must be re-evaluated on the next frame
View.cpp:2636:    bool temporary = !camera_->GetFrustum().IsInside(center);
View.cpp:2639:    Zone* lastZone = drawable->GetZone();
View.cpp:2641:    if (lastZone && (lastZone->GetViewMask() & camera_->GetViewMask()) && lastZone->GetPriority() >= highestZonePriority_ &&
View.cpp:2642:        (drawable->GetZoneMask() & lastZone->GetZoneMask()) && lastZone->IsInside(center))
View.cpp:2649:            int priority = zone->GetPriority();
View.cpp:2650:            if (priority > bestPriority && (drawable->GetZoneMask() & zone->GetZoneMask()) && zone->IsInside(center))
View.cpp:2658:    drawable->SetZone(newZone, temporary);
View.cpp:2664:        return renderer_->GetDefaultMaterial()->GetTechniques()[0].technique_;
View.cpp:2666:    const Vector<TechniqueEntry>& techniques = material->GetTechniques();
View.cpp:2672:        float lodDistance = drawable->GetLodDistance();
View.cpp:2684:            if (!tech || (!tech->IsSupported()) || materialQuality_ < entry.qualityLevel_)
View.cpp:2697:    const HashMap<TextureUnit, SharedPtr<Texture> >& textures = material->GetTextures();
View.cpp:2701:        Texture* texture = i->second_.Get();
View.cpp:2702:        if (texture && texture->GetUsage() == TEXTURE_RENDERTARGET)
View.cpp:2705:            if (texture->GetType() == Texture2D::GetTypeStatic())
View.cpp:2708:                RenderSurface* target = tex2D->GetRenderSurface();
View.cpp:2709:                if (target && target->GetUpdateMode() == SURFACE_UPDATEVISIBLE)
View.cpp:2710:                    target->QueueUpdate();
View.cpp:2712:            else if (texture->GetType() == TextureCube::GetTypeStatic())
View.cpp:2717:                    RenderSurface* target = texCube->GetRenderSurface((CubeMapFace)j);
View.cpp:2718:                    if (target && target->GetUpdateMode() == SURFACE_UPDATEVISIBLE)
View.cpp:2719:                        target->QueueUpdate();
View.cpp:2725:    // Flag as processed so we can early-out next time we come across this material on the same frame
View.cpp:2726:    material->MarkForAuxView(frame_.frameNumber_);
View.cpp:2732:        batch.material_ = renderer_->GetDefaultMaterial();
View.cpp:2735:    if (allowInstancing && batch.geometryType_ == GEOM_STATIC && batch.geometry_->GetIndexBuffer())
View.cpp:2749:            renderer_->SetBatchShaders(newGroup, tech, allowShadows);
View.cpp:2754:        int oldSize = i->second_.instances_.Size();
View.cpp:2755:        i->second_.AddTransforms(batch);
View.cpp:2757:        if (oldSize < minInstances_ && (int)i->second_.instances_.Size() >= minInstances_)
View.cpp:2759:            i->second_.geometryType_ = GEOM_INSTANCED;
View.cpp:2760:            renderer_->SetBatchShaders(i->second_, tech, allowShadows);
View.cpp:2761:            i->second_.CalculateSortKey();
View.cpp:2766:        renderer_->SetBatchShaders(batch, tech, allowShadows);
View.cpp:2793:        totalInstances += i->second_.GetNumInstances();
View.cpp:2797:        for (unsigned j = 0; j < i->shadowSplits_.Size(); ++j)
View.cpp:2798:            totalInstances += i->shadowSplits_[j].shadowBatches_.GetNumInstances();
View.cpp:2799:        totalInstances += i->litBaseBatches_.GetNumInstances();
View.cpp:2800:        totalInstances += i->litBatches_.GetNumInstances();
View.cpp:2803:    if (!totalInstances || !renderer_->ResizeInstancingBuffer(totalInstances))
View.cpp:2806:    VertexBuffer* instancingBuffer = renderer_->GetInstancingBuffer();
View.cpp:2808:    void* dest = instancingBuffer->Lock(0, totalInstances, true);
View.cpp:2813:        i->second_.SetTransforms(dest, freeIndex);
View.cpp:2817:        for (unsigned j = 0; j < i->shadowSplits_.Size(); ++j)
View.cpp:2818:            i->shadowSplits_[j].shadowBatches_.SetTransforms(dest, freeIndex);
View.cpp:2819:        i->litBaseBatches_.SetTransforms(dest, freeIndex);
View.cpp:2820:        i->litBatches_.SetTransforms(dest, freeIndex);
View.cpp:2823:    instancingBuffer->Unlock();
View.cpp:2828:    Light* light = batch.lightQueue_->light_;
View.cpp:2829:    LightType type = light->GetLightType();
View.cpp:2830:    Vector3 cameraPos = cameraNode_->GetWorldPosition();
View.cpp:2833:    graphics_->SetBlendMode(light->IsNegative() ? BLEND_SUBTRACT : BLEND_ADD);
View.cpp:2834:    graphics_->SetDepthBias(0.0f, 0.0f);
View.cpp:2835:    graphics_->SetDepthWrite(false);
View.cpp:2836:    graphics_->SetFillMode(FILL_SOLID);
View.cpp:2837:    graphics_->SetClipPlane(false);
View.cpp:2842:            lightDist = Sphere(light->GetNode()->GetWorldPosition(), light->GetRange() * 1.25f).Distance(cameraPos);
View.cpp:2844:            lightDist = light->GetFrustum().Distance(cameraPos);
View.cpp:2847:        if (lightDist < camera_->GetNearClip() * 2.0f)
View.cpp:2849:            renderer_->SetCullMode(CULL_CW, camera_);
View.cpp:2850:            graphics_->SetDepthTest(CMP_GREATER);
View.cpp:2854:            renderer_->SetCullMode(CULL_CCW, camera_);
View.cpp:2855:            graphics_->SetDepthTest(CMP_LESSEQUAL);
View.cpp:2862:        light->GetVolumeTransform(camera_);
View.cpp:2863:        graphics_->SetCullMode(CULL_NONE);
View.cpp:2864:        graphics_->SetDepthTest(CMP_ALWAYS);
View.cpp:2867:    graphics_->SetScissorTest(false);
View.cpp:2869:        graphics_->SetStencilTest(true, CMP_NOTEQUAL, OP_KEEP, OP_KEEP, OP_KEEP, 0, light->GetLightMask());
View.cpp:2871:        graphics_->SetStencilTest(false);
View.cpp:2879:    graphics_->SetTexture(TU_SHADOWMAP, 0);
View.cpp:2881:    graphics_->SetColorWrite(false);
View.cpp:2882:    graphics_->SetFillMode(FILL_SOLID);
View.cpp:2883:    graphics_->SetClipPlane(false);
View.cpp:2884:    graphics_->SetStencilTest(false);
View.cpp:2885:    graphics_->SetRenderTarget(0, shadowMap->GetRenderSurface()->GetLinkedRenderTarget());
View.cpp:2887:        graphics_->SetRenderTarget(i, (RenderSurface*)0);
View.cpp:2888:    graphics_->SetDepthStencil(shadowMap);
View.cpp:2889:    graphics_->SetViewport(IntRect(0, 0, shadowMap->GetWidth(), shadowMap->GetHeight()));
View.cpp:2890:    graphics_->Clear(CLEAR_DEPTH);
View.cpp:2893:    const BiasParameters& parameters = queue.light_->GetShadowBias();
View.cpp:2900:        if (i > 0 && queue.light_->GetLightType() == LIGHT_DIRECTIONAL)
View.cpp:2902:            multiplier = Max(queue.shadowSplits_[i].shadowCamera_->GetFarClip() / queue.shadowSplits_[0].shadowCamera_->GetFarClip(), 1.0f);
View.cpp:2903:            multiplier = 1.0f + (multiplier - 1.0f) * queue.light_->GetShadowCascade().biasAutoAdjust_;
View.cpp:2911:        multiplier *= renderer_->GetMobileShadowBiasMul();
View.cpp:2912:        addition = renderer_->GetMobileShadowBiasAdd();
View.cpp:2915:        graphics_->SetDepthBias(multiplier * parameters.constantBias_ + addition, multiplier * parameters.slopeScaledBias_);
View.cpp:2920:            graphics_->SetViewport(shadowQueue.shadowViewport_);
View.cpp:2925:    graphics_->SetColorWrite(true);
View.cpp:2926:    graphics_->SetDepthBias(0.0f, 0.0f);
View.cpp:2931:    // If using the backbuffer, return the backbuffer depth-stencil
View.cpp:2934:    // Then check for linked depth-stencil
View.cpp:2935:    RenderSurface* depthStencil = renderTarget->GetLinkedDepthStencil();
View.cpp:2938:        depthStencil = renderer_->GetDepthStencil(renderTarget->GetWidth(), renderTarget->GetHeight());
View.cpp:2947:    if (texture->GetType() == Texture2D::GetTypeStatic())
View.cpp:2948:        return static_cast<Texture2D*>(texture)->GetRenderSurface();
View.cpp:2949:    else if (texture->GetType() == TextureCube::GetTypeStatic())
View.cpp:2950:        return static_cast<TextureCube*>(texture)->GetRenderSurface(face);
View.cpp:2967:    Texture* texture = cache->GetExistingResource<Texture2D>(name);
View.cpp:2969:        texture = cache->GetExistingResource<TextureCube>(name);
View.cpp:2971:        texture = cache->GetExistingResource<Texture3D>(name);
View.cpp:2984:                return cache->GetResource<Texture3D>(name);
View.cpp:2987:                return cache->GetResource<TextureCube>(name);
View.cpp:2990:            return cache->GetResource<Texture2D>(name);
VoxelSet.cpp:26:	context->RegisterFactory<VoxelSet>(GEOMETRY_CATEGORY);
VoxelSet.cpp:33:	// Change of any non-accessor attribute requires recreation of the terrain
